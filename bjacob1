From: Benoit Jacob <bjacob@mozilla.com>

Bug 600620 - 1/2 - Expose feature status block reason so that it can be used by about:support - r=vladimir, a=blocking2.0-b7

diff --git a/content/canvas/src/WebGLContext.cpp b/content/canvas/src/WebGLContext.cpp
--- a/content/canvas/src/WebGLContext.cpp
+++ b/content/canvas/src/WebGLContext.cpp
@@ -317,25 +317,25 @@ WebGLContext::SetDimensions(PRInt32 widt
 
     PRBool useOpenGL = PR_TRUE;
     PRBool useANGLE = PR_TRUE;
 
     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
     if (gfxInfo) {
         PRInt32 status;
         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_OPENGL, &status))) {
-            if (status == nsIGfxInfo::FEATURE_BLOCKED ||
-                status == nsIGfxInfo::FEATURE_NOT_AVAILABLE)
+            if (status == nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION ||
+                status == nsIGfxInfo::FEATURE_BLOCKED_DEVICE)
             {
                 useOpenGL = PR_FALSE;
             }
         }
         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_ANGLE, &status))) {
-            if (status == nsIGfxInfo::FEATURE_BLOCKED ||
-                status == nsIGfxInfo::FEATURE_NOT_AVAILABLE)
+            if (status == nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION ||
+                status == nsIGfxInfo::FEATURE_BLOCKED_DEVICE)
             {
                 useANGLE = PR_FALSE;
             }
         }
     }
 
     #ifdef XP_WIN
         // On Windows, we may have a choice of backends, including straight
diff --git a/gfx/layers/d3d9/LayerManagerD3D9.cpp b/gfx/layers/d3d9/LayerManagerD3D9.cpp
--- a/gfx/layers/d3d9/LayerManagerD3D9.cpp
+++ b/gfx/layers/d3d9/LayerManagerD3D9.cpp
@@ -75,18 +75,17 @@ LayerManagerD3D9::Initialize()
   /* Check the user preference for whether 3d video is enabled or not */ 
   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID); 
   prefs->GetBoolPref("gfx.3d_video.enabled", &mIs3DEnabled);
 
   nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
   if (gfxInfo) {
     PRInt32 status;
     if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS, &status))) {
-      if (status != nsIGfxInfo::FEATURE_STATUS_UNKNOWN &&
-          status != nsIGfxInfo::FEATURE_AVAILABLE)
+      if (status != nsIGfxInfo::FEATURE_NO_INFO)
       {
         NS_WARNING("Direct3D 9-accelerated layers are not supported on this system.");
         return PR_FALSE;
       }
     }
   }
 
   if (!mDefaultDeviceManager) {
diff --git a/gfx/layers/opengl/LayerManagerOGL.cpp b/gfx/layers/opengl/LayerManagerOGL.cpp
--- a/gfx/layers/opengl/LayerManagerOGL.cpp
+++ b/gfx/layers/opengl/LayerManagerOGL.cpp
@@ -149,18 +149,17 @@ LayerManagerOGL::Initialize(GLContext *a
   } else {
     if (mGLContext)
       CleanupResources();
 
     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
     if (gfxInfo) {
       PRInt32 status;
       if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_OPENGL_LAYERS, &status))) {
-        if (status != nsIGfxInfo::FEATURE_STATUS_UNKNOWN &&
-            status != nsIGfxInfo::FEATURE_AVAILABLE) {
+        if (status != nsIGfxInfo::FEATURE_NO_INFO) {
           NS_WARNING("OpenGL-accelerated layers are not supported on this system.");
           return PR_FALSE;
         }
       }
     }
 
     mGLContext = nsnull;
 
diff --git a/gfx/thebes/gfxWindowsPlatform.cpp b/gfx/thebes/gfxWindowsPlatform.cpp
--- a/gfx/thebes/gfxWindowsPlatform.cpp
+++ b/gfx/thebes/gfxWindowsPlatform.cpp
@@ -280,21 +280,21 @@ gfxWindowsPlatform::UpdateRenderMode()
     PRBool d2dDisabled = PR_FALSE;
     PRBool d2dForceEnabled = PR_FALSE;
     PRBool d2dBlocked = PR_FALSE;
 
     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
     if (gfxInfo) {
         PRInt32 status;
         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT2D, &status))) {
-            if (status != nsIGfxInfo::FEATURE_STATUS_UNKNOWN &&
-                status != nsIGfxInfo::FEATURE_AVAILABLE)
-            {
+            if (status != nsIGfxInfo::FEATURE_NO_INFO) {
                 d2dDisabled = PR_TRUE;
-                if (status == nsIGfxInfo::FEATURE_BLOCKED) {
+                if (status == nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION ||
+                    status == nsIGfxInfo::FEATURE_BLOCKED_DEVICE)
+                {
                     d2dBlocked = PR_TRUE;
                 }
             }
         }
     }
 
     rv = pref->GetBoolPref("gfx.direct2d.disabled", &d2dDisabled);
     if (NS_FAILED(rv))
diff --git a/widget/public/nsIGfxInfo.idl b/widget/public/nsIGfxInfo.idl
--- a/widget/public/nsIGfxInfo.idl
+++ b/widget/public/nsIGfxInfo.idl
@@ -88,25 +88,32 @@ interface nsIGfxInfo : nsISupports
   /* Whether WebGL is supported via OpenGL. */
   const long FEATURE_WEBGL_OPENGL = 6;
   /* Whether WebGL is supported via ANGLE (D3D9 -- does not check for the presence of ANGLE libs). */
   const long FEATURE_WEBGL_ANGLE = 7;
 
   /*
    * A set of return values from GetFeatureStatus
    */
-  /* We don't have any information about this feature on this hardware */
-  const long FEATURE_STATUS_UNKNOWN = 0;
-  /* This feature is available and can be used */
-  const long FEATURE_AVAILABLE = 1;
-  /* This feature is not available */
-  const long FEATURE_NOT_AVAILABLE = 2;
-  /* This feature is available, but is blocked due to a blocklist entry */
-  const long FEATURE_BLOCKED = 3;
+  /* We don't explicitly block or discourage the feature. Which means we'll try getting it from the
+   * hardware, and see what happens. */
+  const long FEATURE_NO_INFO = 1;
+  /* This feature is blocked on this driver version. Updating driver will typically unblock it. */
+  const long FEATURE_BLOCKED_DRIVER_VERSION = 2;
+  /* This feature is blocked on this device, regardless of driver version.
+   * Typically means we hit too many driver crashes without a good reason to hope for them to
+   * get fixed soon. */
+  const long FEATURE_BLOCKED_DEVICE = 3;
   /* This feature is available and can be used, but is not suggested (e.g. shouldn't be used by default */
-  const long FEATURE_NOT_SUGGESTED = 4;
+  const long FEATURE_DISCOURAGED = 4;
 
   /**
    * Ask about a feature, and return the status of that feature
    */
   long getFeatureStatus(in long aFeature);
+
+  /*
+   * Ask about a feature, return the minimum driver version required for it if its status is
+   * FEATURE_BLOCKED_DRIVER_VERSION, otherwise return an empty string. 
+   */
+  DOMString getFeatureSuggestedDriverVersion(in long aFeature);
 };
 
diff --git a/widget/src/cocoa/GfxInfo.mm b/widget/src/cocoa/GfxInfo.mm
--- a/widget/src/cocoa/GfxInfo.mm
+++ b/widget/src/cocoa/GfxInfo.mm
@@ -192,8 +192,13 @@ GfxInfo::GetFeatureStatus(PRInt32 aFeatu
         status = nsIGfxInfo::FEATURE_BLOCKED;
     }
   }
 
   *aStatus = status;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+GfxInfo::GetFeatureSuggestedDriverVersion(PRInt32 aFeature, nsAString& aSuggestedDriverVersion)
+{
+  return NS_OK;
+}
diff --git a/widget/src/windows/GfxInfo.cpp b/widget/src/windows/GfxInfo.cpp
--- a/widget/src/windows/GfxInfo.cpp
+++ b/widget/src/windows/GfxInfo.cpp
@@ -35,16 +35,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include <windows.h>
 #include "gfxWindowsPlatform.h"
 #include "GfxInfo.h"
 #include "nsUnicharUtils.h"
+#include "nsPrintfCString.h"
 #include "mozilla/FunctionTimer.h"
 
 #if defined(MOZ_CRASHREPORTER) && defined(MOZ_ENABLE_LIBXUL)
 #include "nsExceptionHandler.h"
 #include "nsICrashReporter.h"
 #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
 #include "nsIPrefService.h"
 #endif
@@ -309,16 +310,17 @@ GfxInfo::GetAdapterDeviceID(PRUint32 *aA
   ToUpperCase(device);
   PRInt32 start = device.Find(NS_LITERAL_CSTRING("&DEV_"));
   if (start != -1) {
     device.Cut(0, start + strlen("&DEV_"));
     device.Truncate(4);
   }
   nsresult err;
   *aAdapterDeviceID = device.ToInteger(&err, 16);
+
   return NS_OK;
 }
 
 void
 GfxInfo::AddCrashReportAnnotations()
 {
 #if defined(MOZ_CRASHREPORTER) && defined(MOZ_ENABLE_LIBXUL)
   nsCAutoString deviceIDString, vendorIDString;
@@ -490,27 +492,27 @@ static const GfxDriverInfo driverInfo[] 
    * Intel entries
    */
 
   /*
    * Implement special Direct2D blocklist from bug 595364
    */
   { allWindowsVersions,
     vendorIntel, deviceFamilyIntelBlockDirect2D,
-    nsIGfxInfo::FEATURE_DIRECT2D, nsIGfxInfo::FEATURE_BLOCKED,
+    nsIGfxInfo::FEATURE_DIRECT2D, nsIGfxInfo::FEATURE_BLOCKED_DEVICE,
     DRIVER_LESS_THAN, allDriverVersions },
 
   /* implement the blocklist from bug 594877
    * Block all features on any drivers before this, as there's a crash when a MS Hotfix is installed.
    * The crash itself is Direct2D-related, but for safety we block all features.
    */
 #define IMPLEMENT_INTEL_DRIVER_BLOCKLIST(winVer, devFamily, driverVer) \
   { winVer,                                                            \
     vendorIntel, devFamily,                                            \
-    allFeatures, nsIGfxInfo::FEATURE_BLOCKED,                          \
+    allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,           \
     DRIVER_LESS_THAN, driverVer },
 
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA500,   V(6,14,11,1018))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA900,   V(6,14,10,4764))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA950,   V(6,14,10,4926))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA3150,  V(6,14,10,5260))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMAX3000, V(6,14,10,5218))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMAX4500HD, V(6,14,10,5284))
@@ -524,24 +526,24 @@ static const GfxDriverInfo driverInfo[] 
 
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA500,   V(5,0,0,2026))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA900,   allDriverVersions)
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA950,   V(8,15,10,1930))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA3150,  V(8,14,10,2117))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMAX3000, V(8,15,10,1930))
   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMAX4500HD, V(8,15,10,2202))
 
-  /* OpenGL on any Intel hardware is not suggested */
+  /* OpenGL on any Intel hardware is discouraged */
   { allWindowsVersions,
     vendorIntel, allDevices,
-    nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_NOT_SUGGESTED,
+    nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_DISCOURAGED,
     DRIVER_LESS_THAN, allDriverVersions },
   { allWindowsVersions,
     vendorIntel, allDevices,
-    nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_NOT_SUGGESTED,
+    nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_DISCOURAGED,
     DRIVER_LESS_THAN, allDriverVersions },
 
   /*
    * NVIDIA entries
    */
 
   /*
    * AMD entries
@@ -562,36 +564,41 @@ ParseDriverVersion(nsAString& aVersion, 
   if (b < 0 || b > 0xffff) return false;
   if (c < 0 || c > 0xffff) return false;
   if (d < 0 || d > 0xffff) return false;
 
   *aNumericVersion = V(a, b, c, d);
   return true;
 }
 
-NS_IMETHODIMP
-GfxInfo::GetFeatureStatus(PRInt32 aFeature, PRInt32 *aStatus)
+nsresult
+GfxInfo::GetFeatureStatusImpl(PRInt32 aFeature, PRInt32 *aStatus, nsAString & aSuggestedDriverVersion)
 {
-  PRInt32 status = nsIGfxInfo::FEATURE_STATUS_UNKNOWN;
+  *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
+  aSuggestedDriverVersion.SetIsVoid(PR_TRUE);
+
+  PRInt32 status = nsIGfxInfo::FEATURE_NO_INFO;
 
   PRUint32 adapterVendor = 0;
   PRUint32 adapterDeviceID = 0;
   nsAutoString adapterDriverVersionString;
   if (NS_FAILED(GetAdapterVendorID(&adapterVendor)) ||
       NS_FAILED(GetAdapterDeviceID(&adapterDeviceID)) ||
       NS_FAILED(GetAdapterDriverVersion(adapterDriverVersionString)))
   {
     return NS_ERROR_FAILURE;
   }
 
   PRUint64 driverVersion;
   if (!ParseDriverVersion(adapterDriverVersionString, &driverVersion)) {
     return NS_ERROR_FAILURE;
   }
 
+  PRUint64 suggestedDriverVersion = 0;
+
   const GfxDriverInfo *info = &driverInfo[0];
   while (info->windowsVersion) {
 
     if (info->windowsVersion != allWindowsVersions &&
         info->windowsVersion != gfxWindowsPlatform::WindowsOSVersion())
     {
       info++;
       continue;
@@ -617,16 +624,17 @@ GfxInfo::GetFeatureStatus(PRInt32 aFeatu
         }
     }
 
     bool match = false;
 
     switch (info->op) {
     case DRIVER_LESS_THAN:
       match = driverVersion < info->version;
+      suggestedDriverVersion = info->version;
       break;
     case DRIVER_LESS_THAN_OR_EQUAL:
       match = driverVersion <= info->version;
       break;
     case DRIVER_GREATER_THAN:
       match = driverVersion > info->version;
       break;
     case DRIVER_GREATER_THAN_OR_EQUAL:
@@ -660,11 +668,33 @@ GfxInfo::GetFeatureStatus(PRInt32 aFeatu
         break;
       }
     }
 
     info++;
   }
 
   *aStatus = status;
+
+  if (status == FEATURE_BLOCKED_DRIVER_VERSION && suggestedDriverVersion) {
+      aSuggestedDriverVersion.AppendPrintf("%lld.%lld.%lld.%lld",
+                                           (suggestedDriverVersion & 0xffff000000000000) >> 48,
+                                           (suggestedDriverVersion & 0x0000ffff00000000) >> 32,
+                                           (suggestedDriverVersion & 0x00000000ffff0000) >> 16,
+                                           (suggestedDriverVersion & 0x000000000000ffff));
+  }
+  
   return NS_OK;
 }
 
+NS_IMETHODIMP
+GfxInfo::GetFeatureStatus(PRInt32 aFeature, PRInt32 *aStatus)
+{
+  nsString s;
+  return GetFeatureStatusImpl(aFeature, aStatus, s);
+}
+
+NS_IMETHODIMP
+GfxInfo::GetFeatureSuggestedDriverVersion(PRInt32 aFeature, nsAString& aSuggestedDriverVersion)
+{
+  PRInt32 i;
+  return GetFeatureStatusImpl(aFeature, &i, aSuggestedDriverVersion);
+}
diff --git a/widget/src/windows/GfxInfo.h b/widget/src/windows/GfxInfo.h
--- a/widget/src/windows/GfxInfo.h
+++ b/widget/src/windows/GfxInfo.h
@@ -57,14 +57,16 @@ private:
 
   void Init();
   void AddCrashReportAnnotations();
   nsString mDeviceString;
   nsString mDeviceID;
   nsString mDriverVersion;
   nsString mDriverDate;
   nsString mDeviceKey;
+
+  nsresult GetFeatureStatusImpl(PRInt32 aFeature, PRInt32 *aStatus, nsAString & aSuggestedDriverVersion);
 };
 
 } // namespace widget
 } // namespace mozilla
 
 #endif /* __mozilla_widget_GfxInfo_h__ */
