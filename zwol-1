From: Zack Weinberg <zweinberg@mozilla.com>

Bug 576044 (1/12): Move all the CSS 'storage types' (rect, value pair, etc) to nsCSSValue.h and their code to nsCSSValue.cpp.  r=dbaron  a2.0=dbaron

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -4879,24 +4879,17 @@ CSSParserImpl::ParseGradient(nsCSSValue&
   }
 
   if (haveGradientLine) {
     PRBool haveAngle =
       ParseVariant(cssGradient->mAngle, VARIANT_ANGLE, nsnull);
 
     // if we got an angle, we might now have a comma, ending the gradient-line
     if (!haveAngle || !ExpectSymbol(',', PR_TRUE)) {
-      // This intermediate is necessary because nsCSSValueGradient cannot
-      // contain a nsCSSValuePair (because the latter type is defined in
-      // nsCSSStruct.h rather than nsCSSValue.h).
-      nsCSSValuePair bgPos;
-      if (ParseBoxPositionValues(bgPos, PR_FALSE)) {
-        cssGradient->mBgPosX = bgPos.mXValue;
-        cssGradient->mBgPosY = bgPos.mYValue;
-      } else {
+      if (!ParseBoxPositionValues(cssGradient->mBgPos, PR_FALSE)) {
         SkipUntil(')');
         return PR_FALSE;
       }
 
       if (!ExpectSymbol(',', PR_TRUE) &&
           // if we didn't already get an angle, we might have one now,
           // otherwise it's an error
           (haveAngle ||
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -38,96 +38,31 @@
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * temporary (expanded) representation of the property-value pairs
  * within a CSS declaration using during parsing and mutation, and
  * representation of complex values for CSS properties
  */
 
-#include "nscore.h"
 #include "nsCSSStruct.h"
 #include "nsString.h"
-#include "nsIAtom.h"
-#include "nsUnicharUtils.h"
-#include "nsCRT.h"
-#include "nsCSSProps.h"
-#include "nsFont.h"
-
-#include "nsStyleConsts.h"
-
-#include "nsCOMPtr.h"
-#include "nsReadableUtils.h"
-#include "nsPrintfCString.h"
-#include "prlog.h"
 
 // --- nsCSSFont -----------------
 
 nsCSSFont::nsCSSFont(void)
 {
   MOZ_COUNT_CTOR(nsCSSFont);
 }
 
 nsCSSFont::~nsCSSFont(void)
 {
   MOZ_COUNT_DTOR(nsCSSFont);
 }
 
-// --- nsCSSValueList -----------------
-
-nsCSSValueList::~nsCSSValueList()
-{
-  MOZ_COUNT_DTOR(nsCSSValueList);
-  NS_CSS_DELETE_LIST_MEMBER(nsCSSValueList, this, mNext);
-}
-
-nsCSSValueList*
-nsCSSValueList::Clone() const
-{
-  nsCSSValueList* result = new nsCSSValueList(*this);
-  nsCSSValueList* dest = result;
-  const nsCSSValueList* src = this->mNext;
-  while (src) {
-    dest->mNext = new nsCSSValueList(*src);
-    dest = dest->mNext;
-    src = src->mNext;
-  }
-  return result;
-}
-
-void
-nsCSSValueList::AppendToString(nsCSSProperty aProperty, nsAString& aResult) const
-{
-  const nsCSSValueList* val = this;
-  for (;;) {
-    val->mValue.AppendToString(aProperty, aResult);
-    val = val->mNext;
-    if (!val)
-      break;
-
-    if (nsCSSProps::PropHasFlags(aProperty, CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
-      aResult.Append(PRUnichar(','));
-    aResult.Append(PRUnichar(' '));
-  }
-}
-
-bool
-nsCSSValueList::operator==(const nsCSSValueList& aOther) const
-{
-  if (this == &aOther)
-    return true;
-
-  const nsCSSValueList *p1 = this, *p2 = &aOther;
-  for ( ; p1 && p2; p1 = p1->mNext, p2 = p2->mNext) {
-    if (p1->mValue != p2->mValue)
-      return false;
-  }
-  return !p1 && !p2; // true if same length, false otherwise
-}
-
 // --- nsCSSColor -----------------
 
 nsCSSColor::nsCSSColor(void)
   : mBackImage(nsnull)
   , mBackRepeat(nsnull)
   , mBackAttachment(nsnull)
   , mBackPosition(nsnull)
   , mBackSize(nsnull)
@@ -159,83 +94,16 @@ nsCSSText::nsCSSText(void)
 }
 
 nsCSSText::~nsCSSText(void)
 {
   MOZ_COUNT_DTOR(nsCSSText);
   delete mTextShadow;
 }
 
-// --- nsCSSRect -----------------
-
-nsCSSRect::nsCSSRect(void)
-{
-  MOZ_COUNT_CTOR(nsCSSRect);
-}
-
-nsCSSRect::nsCSSRect(const nsCSSRect& aCopy)
-  : mTop(aCopy.mTop),
-    mRight(aCopy.mRight),
-    mBottom(aCopy.mBottom),
-    mLeft(aCopy.mLeft)
-{
-  MOZ_COUNT_CTOR(nsCSSRect);
-}
-
-nsCSSRect::~nsCSSRect()
-{
-  MOZ_COUNT_DTOR(nsCSSRect);
-}
-
-void
-nsCSSRect::AppendToString(nsCSSProperty aProperty, nsAString& aResult) const
-{
-  const nsCSSUnit topUnit = mTop.GetUnit();
-  if (topUnit == eCSSUnit_Inherit ||
-      topUnit == eCSSUnit_Initial ||
-      topUnit == eCSSUnit_RectIsAuto) {
-    NS_ASSERTION(mRight.GetUnit() == topUnit &&
-                 mBottom.GetUnit() == topUnit &&
-                 mLeft.GetUnit() == topUnit,
-                 "parser should make all sides have the same unit");
-    if (topUnit == eCSSUnit_RectIsAuto)
-      aResult.AppendLiteral("auto");
-    else
-      mTop.AppendToString(aProperty, aResult);
-  } else {
-    aResult.AppendLiteral("rect(");
-    mTop.AppendToString(aProperty, aResult);
-    NS_NAMED_LITERAL_STRING(comma, ", ");
-    aResult.Append(comma);
-    mRight.AppendToString(aProperty, aResult);
-    aResult.Append(comma);
-    mBottom.AppendToString(aProperty, aResult);
-    aResult.Append(comma);
-    mLeft.AppendToString(aProperty, aResult);
-    aResult.Append(PRUnichar(')'));
-  }
-}
-
-void nsCSSRect::SetAllSidesTo(const nsCSSValue& aValue)
-{
-  mTop = aValue;
-  mRight = aValue;
-  mBottom = aValue;
-  mLeft = aValue;
-}
-
-PR_STATIC_ASSERT((NS_SIDE_TOP == 0) && (NS_SIDE_RIGHT == 1) && (NS_SIDE_BOTTOM == 2) && (NS_SIDE_LEFT == 3));
-
-/* static */ const nsCSSRect::side_type nsCSSRect::sides[4] = {
-  &nsCSSRect::mTop,
-  &nsCSSRect::mRight,
-  &nsCSSRect::mBottom,
-  &nsCSSRect::mLeft,
-};
-
 // --- nsCSSCornerSizes -----------------
 
 nsCSSCornerSizes::nsCSSCornerSizes(void)
 {
   MOZ_COUNT_CTOR(nsCSSCornerSizes);
 }
 
 nsCSSCornerSizes::nsCSSCornerSizes(const nsCSSCornerSizes& aCopy)
@@ -390,103 +258,16 @@ nsCSSPage::nsCSSPage(void)
   MOZ_COUNT_CTOR(nsCSSPage);
 }
 
 nsCSSPage::~nsCSSPage(void)
 {
   MOZ_COUNT_DTOR(nsCSSPage);
 }
 
-// --- nsCSSValuePair -----------------
-
-void
-nsCSSValuePair::AppendToString(nsCSSProperty aProperty, nsAString& aResult) const
-{
-  mXValue.AppendToString(aProperty, aResult);
-  if (mYValue != mXValue ||
-      ((aProperty == eCSSProperty_background_position ||
-        aProperty == eCSSProperty__moz_transform_origin) &&
-       mXValue.GetUnit() != eCSSUnit_Inherit &&
-       mXValue.GetUnit() != eCSSUnit_Initial) ||
-      (aProperty == eCSSProperty_background_size &&
-       mXValue.GetUnit() != eCSSUnit_Inherit &&
-       mXValue.GetUnit() != eCSSUnit_Initial &&
-       mXValue.GetUnit() != eCSSUnit_Enumerated)) {
-    // Only output a Y value if it's different from the X value,
-    // or if it's a background-position value other than 'initial'
-    // or 'inherit', or if it's a -moz-transform-origin value other
-    // than 'initial' or 'inherit', or if it's a background-size
-    // value other than 'initial' or 'inherit' or 'contain' or 'cover'.
-    aResult.Append(PRUnichar(' '));
-    mYValue.AppendToString(aProperty, aResult);
-  }
-}
-
-// --- nsCSSValuePairList -----------------
-
-nsCSSValuePairList::~nsCSSValuePairList()
-{
-  MOZ_COUNT_DTOR(nsCSSValuePairList);
-  NS_CSS_DELETE_LIST_MEMBER(nsCSSValuePairList, this, mNext);
-}
-
-nsCSSValuePairList*
-nsCSSValuePairList::Clone() const
-{
-  nsCSSValuePairList* result = new nsCSSValuePairList(*this);
-  nsCSSValuePairList* dest = result;
-  const nsCSSValuePairList* src = this->mNext;
-  while (src) {
-    dest->mNext = new nsCSSValuePairList(*src);
-    dest = dest->mNext;
-    src = src->mNext;
-  }
-  return result;
-}
-
-void
-nsCSSValuePairList::AppendToString(nsCSSProperty aProperty,
-                                   nsAString& aResult) const
-{
-  const nsCSSValuePairList* val = this;
-  for (;;) {
-    NS_ABORT_IF_FALSE(val->mXValue.GetUnit() != eCSSUnit_Null,
-                      "unexpected null unit");
-    val->mXValue.AppendToString(aProperty, aResult);
-    if (val->mXValue.GetUnit() != eCSSUnit_Inherit &&
-        val->mXValue.GetUnit() != eCSSUnit_Initial &&
-        val->mYValue.GetUnit() != eCSSUnit_Null) {
-      aResult.Append(PRUnichar(' '));
-      val->mYValue.AppendToString(aProperty, aResult);
-    }
-    val = val->mNext;
-    if (!val)
-      break;
-
-    if (nsCSSProps::PropHasFlags(aProperty, CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
-      aResult.Append(PRUnichar(','));
-    aResult.Append(PRUnichar(' '));
-  }
-}
-
-bool
-nsCSSValuePairList::operator==(const nsCSSValuePairList& aOther) const
-{
-  if (this == &aOther)
-    return true;
-
-  const nsCSSValuePairList *p1 = this, *p2 = &aOther;
-  for ( ; p1 && p2; p1 = p1->mNext, p2 = p2->mNext) {
-    if (p1->mXValue != p2->mXValue ||
-        p1->mYValue != p2->mYValue)
-      return false;
-  }
-  return !p1 && !p2; // true if same length, false otherwise
-}
-
 // --- nsCSSContent -----------------
 
 nsCSSContent::nsCSSContent(void)
   : mContent(nsnull),
     mCounterIncrement(nsnull),
     mCounterReset(nsnull),
     mQuotes(nsnull)
 {
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -43,137 +43,16 @@
  */
 
 #ifndef nsCSSStruct_h___
 #define nsCSSStruct_h___
 
 #include "nsCSSValue.h"
 #include "nsStyleConsts.h"
 
-// Prefer nsCSSValue::Array for lists of fixed size.
-struct nsCSSValueList {
-  nsCSSValueList() : mNext(nsnull) { MOZ_COUNT_CTOR(nsCSSValueList); }
-  ~nsCSSValueList();
-
-  nsCSSValueList* Clone() const;  // makes a deep copy
-  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
-
-  bool operator==(nsCSSValueList const& aOther) const; // deep comparison
-  bool operator!=(const nsCSSValueList& aOther) const
-  { return !(*this == aOther); }
-
-  nsCSSValue      mValue;
-  nsCSSValueList* mNext;
-
-private:
-  nsCSSValueList(const nsCSSValueList& aCopy) // makes a shallow copy
-    : mValue(aCopy.mValue), mNext(nsnull)
-  {
-    MOZ_COUNT_CTOR(nsCSSValueList);
-  }
-};
-
-struct nsCSSRect {
-  nsCSSRect(void);
-  nsCSSRect(const nsCSSRect& aCopy);
-  ~nsCSSRect();
-
-  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
-
-  PRBool operator==(const nsCSSRect& aOther) const {
-    return mTop == aOther.mTop &&
-           mRight == aOther.mRight &&
-           mBottom == aOther.mBottom &&
-           mLeft == aOther.mLeft;
-  }
-
-  PRBool operator!=(const nsCSSRect& aOther) const {
-    return mTop != aOther.mTop ||
-           mRight != aOther.mRight ||
-           mBottom != aOther.mBottom ||
-           mLeft != aOther.mLeft;
-  }
-
-  void SetAllSidesTo(const nsCSSValue& aValue);
-
-  void Reset() {
-    mTop.Reset();
-    mRight.Reset();
-    mBottom.Reset();
-    mLeft.Reset();
-  }
-
-  PRBool HasValue() const {
-    return
-      mTop.GetUnit() != eCSSUnit_Null ||
-      mRight.GetUnit() != eCSSUnit_Null ||
-      mBottom.GetUnit() != eCSSUnit_Null ||
-      mLeft.GetUnit() != eCSSUnit_Null;
-  }
-
-  nsCSSValue mTop;
-  nsCSSValue mRight;
-  nsCSSValue mBottom;
-  nsCSSValue mLeft;
-
-  typedef nsCSSValue nsCSSRect::*side_type;
-  static const side_type sides[4];
-};
-
-struct nsCSSValuePair {
-  nsCSSValuePair()
-  {
-    MOZ_COUNT_CTOR(nsCSSValuePair);
-  }
-  nsCSSValuePair(const nsCSSValue& aXValue, const nsCSSValue& aYValue)
-    : mXValue(aXValue), mYValue(aYValue)
-  {
-    MOZ_COUNT_CTOR(nsCSSValuePair);
-  }
-  nsCSSValuePair(const nsCSSValuePair& aCopy)
-    : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue)
-  {
-    MOZ_COUNT_CTOR(nsCSSValuePair);
-  }
-  ~nsCSSValuePair()
-  {
-    MOZ_COUNT_DTOR(nsCSSValuePair);
-  }
-
-  PRBool operator==(const nsCSSValuePair& aOther) const {
-    return mXValue == aOther.mXValue &&
-           mYValue == aOther.mYValue;
-  }
-
-  PRBool operator!=(const nsCSSValuePair& aOther) const {
-    return mXValue != aOther.mXValue ||
-           mYValue != aOther.mYValue;
-  }
-
-  void SetBothValuesTo(const nsCSSValue& aValue) {
-    mXValue = aValue;
-    mYValue = aValue;
-  }
-
-  void Reset() {
-    mXValue.Reset();
-    mYValue.Reset();
-  }
-
-  PRBool HasValue() const {
-    return mXValue.GetUnit() != eCSSUnit_Null ||
-           mYValue.GetUnit() != eCSSUnit_Null;
-  }
-
-  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
-
-  nsCSSValue mXValue;
-  nsCSSValue mYValue;
-};
-
 struct nsCSSCornerSizes {
   nsCSSCornerSizes(void);
   nsCSSCornerSizes(const nsCSSCornerSizes& aCopy);
   ~nsCSSCornerSizes();
 
   // argument is a "full corner" constant from nsStyleConsts.h
   nsCSSValuePair const & GetFullCorner(PRUint32 aCorner) const {
     return (this->*corners[aCorner]);
@@ -237,40 +116,16 @@ struct nsCSSValueListRect {
   nsCSSValueList* mRight;
   nsCSSValueList* mBottom;
   nsCSSValueList* mLeft;
 
   typedef nsCSSValueList* nsCSSValueListRect::*side_type;
   static const side_type sides[4];
 };
 
-// Maybe should be replaced with nsCSSValueList and nsCSSValue::Array?
-struct nsCSSValuePairList {
-  nsCSSValuePairList() : mNext(nsnull) { MOZ_COUNT_CTOR(nsCSSValuePairList); }
-  ~nsCSSValuePairList();
-
-  nsCSSValuePairList* Clone() const; // makes a deep copy
-  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
-
-  bool operator==(const nsCSSValuePairList& aOther) const; // deep comparison
-  bool operator!=(const nsCSSValuePairList& aOther) const
-  { return !(*this == aOther); }
-
-  nsCSSValue          mXValue;
-  nsCSSValue          mYValue;
-  nsCSSValuePairList* mNext;
-
-private:
-  nsCSSValuePairList(const nsCSSValuePairList& aCopy) // makes a shallow copy
-    : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue), mNext(nsnull)
-  {
-    MOZ_COUNT_CTOR(nsCSSValuePairList);
-  }
-};
-
 /****************************************************************************/
 
 struct nsCSSStruct {
   // EMPTY on purpose.  ABSTRACT with no virtuals (typedef void nsCSSStruct?)
 };
 
 // We use the nsCSS* structures for storing css::Declaration's
 // *temporary* data during parsing and modification.  (They are too big
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -33,27 +33,23 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* representation of simple property values within CSS declarations */
 
 #include "nsCSSValue.h"
-#include "nsString.h"
+
+#include "imgIRequest.h"
+#include "nsIPrincipal.h"
 #include "nsCSSProps.h"
-#include "nsReadableUtils.h"
-#include "imgIRequest.h"
-#include "nsIDocument.h"
 #include "nsContentUtils.h"
-#include "nsIPrincipal.h"
-#include "nsMathUtils.h"
 #include "nsStyleUtil.h"
 #include "CSSCalc.h"
-#include "prenv.h"  // for paint forcing
 
 namespace css = mozilla::css;
 
 nsCSSValue::nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit)
   : mUnit(aUnit)
 {
   NS_ASSERTION(aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
                aUnit == eCSSUnit_EnumColor, "not an int value");
@@ -769,27 +765,27 @@ nsCSSValue::AppendToString(nsCSSProperty
         aResult.AppendLiteral("-moz-repeating-linear-gradient(");
     } else {
       if (gradient->mIsRadial)
         aResult.AppendLiteral("-moz-radial-gradient(");
       else
         aResult.AppendLiteral("-moz-linear-gradient(");
     }
 
-    if (gradient->mBgPosX.GetUnit() != eCSSUnit_None ||
-        gradient->mBgPosY.GetUnit() != eCSSUnit_None ||
+    if (gradient->mBgPos.mXValue.GetUnit() != eCSSUnit_None ||
+        gradient->mBgPos.mYValue.GetUnit() != eCSSUnit_None ||
         gradient->mAngle.GetUnit() != eCSSUnit_None) {
-      if (gradient->mBgPosX.GetUnit() != eCSSUnit_None) {
-        gradient->mBgPosX.AppendToString(eCSSProperty_background_position,
-                                         aResult);
+      if (gradient->mBgPos.mXValue.GetUnit() != eCSSUnit_None) {
+        gradient->mBgPos.mXValue.AppendToString(eCSSProperty_background_position,
+                                                aResult);
         aResult.AppendLiteral(" ");
       }
-      if (gradient->mBgPosY.GetUnit() != eCSSUnit_None) {
-        gradient->mBgPosY.AppendToString(eCSSProperty_background_position,
-                                         aResult);
+      if (gradient->mBgPos.mXValue.GetUnit() != eCSSUnit_None) {
+        gradient->mBgPos.mYValue.AppendToString(eCSSProperty_background_position,
+                                                aResult);
         aResult.AppendLiteral(" ");
       }
       if (gradient->mAngle.GetUnit() != eCSSUnit_None) {
         gradient->mAngle.AppendToString(aProperty, aResult);
       }
       aResult.AppendLiteral(", ");
     }
 
@@ -900,16 +896,224 @@ nsCSSValue::AppendToString(nsCSSProperty
     case eCSSUnit_Hertz:        aResult.AppendLiteral("Hz");   break;
     case eCSSUnit_Kilohertz:    aResult.AppendLiteral("kHz");  break;
 
     case eCSSUnit_Seconds:      aResult.Append(PRUnichar('s'));    break;
     case eCSSUnit_Milliseconds: aResult.AppendLiteral("ms");   break;
   }
 }
 
+// --- nsCSSValueList -----------------
+
+nsCSSValueList::~nsCSSValueList()
+{
+  MOZ_COUNT_DTOR(nsCSSValueList);
+  NS_CSS_DELETE_LIST_MEMBER(nsCSSValueList, this, mNext);
+}
+
+nsCSSValueList*
+nsCSSValueList::Clone() const
+{
+  nsCSSValueList* result = new nsCSSValueList(*this);
+  nsCSSValueList* dest = result;
+  const nsCSSValueList* src = this->mNext;
+  while (src) {
+    dest->mNext = new nsCSSValueList(*src);
+    dest = dest->mNext;
+    src = src->mNext;
+  }
+  return result;
+}
+
+void
+nsCSSValueList::AppendToString(nsCSSProperty aProperty, nsAString& aResult) const
+{
+  const nsCSSValueList* val = this;
+  for (;;) {
+    val->mValue.AppendToString(aProperty, aResult);
+    val = val->mNext;
+    if (!val)
+      break;
+
+    if (nsCSSProps::PropHasFlags(aProperty,
+                                 CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
+      aResult.Append(PRUnichar(','));
+    aResult.Append(PRUnichar(' '));
+  }
+}
+
+bool
+nsCSSValueList::operator==(const nsCSSValueList& aOther) const
+{
+  if (this == &aOther)
+    return true;
+
+  const nsCSSValueList *p1 = this, *p2 = &aOther;
+  for ( ; p1 && p2; p1 = p1->mNext, p2 = p2->mNext) {
+    if (p1->mValue != p2->mValue)
+      return false;
+  }
+  return !p1 && !p2; // true if same length, false otherwise
+}
+
+// --- nsCSSRect -----------------
+
+nsCSSRect::nsCSSRect(void)
+{
+  MOZ_COUNT_CTOR(nsCSSRect);
+}
+
+nsCSSRect::nsCSSRect(const nsCSSRect& aCopy)
+  : mTop(aCopy.mTop),
+    mRight(aCopy.mRight),
+    mBottom(aCopy.mBottom),
+    mLeft(aCopy.mLeft)
+{
+  MOZ_COUNT_CTOR(nsCSSRect);
+}
+
+nsCSSRect::~nsCSSRect()
+{
+  MOZ_COUNT_DTOR(nsCSSRect);
+}
+
+void
+nsCSSRect::AppendToString(nsCSSProperty aProperty, nsAString& aResult) const
+{
+  const nsCSSUnit topUnit = mTop.GetUnit();
+  if (topUnit == eCSSUnit_Inherit ||
+      topUnit == eCSSUnit_Initial ||
+      topUnit == eCSSUnit_RectIsAuto) {
+    NS_ABORT_IF_FALSE(mRight.GetUnit() == topUnit &&
+                      mBottom.GetUnit() == topUnit &&
+                      mLeft.GetUnit() == topUnit,
+                      "parser should make all sides have the same unit");
+    if (topUnit == eCSSUnit_RectIsAuto)
+      aResult.AppendLiteral("auto");
+    else
+      mTop.AppendToString(aProperty, aResult);
+  } else {
+    aResult.AppendLiteral("rect(");
+    mTop.AppendToString(aProperty, aResult);
+    NS_NAMED_LITERAL_STRING(comma, ", ");
+    aResult.Append(comma);
+    mRight.AppendToString(aProperty, aResult);
+    aResult.Append(comma);
+    mBottom.AppendToString(aProperty, aResult);
+    aResult.Append(comma);
+    mLeft.AppendToString(aProperty, aResult);
+    aResult.Append(PRUnichar(')'));
+  }
+}
+
+void nsCSSRect::SetAllSidesTo(const nsCSSValue& aValue)
+{
+  mTop = aValue;
+  mRight = aValue;
+  mBottom = aValue;
+  mLeft = aValue;
+}
+
+PR_STATIC_ASSERT((NS_SIDE_TOP == 0) && (NS_SIDE_RIGHT == 1) && (NS_SIDE_BOTTOM == 2) && (NS_SIDE_LEFT == 3));
+
+/* static */ const nsCSSRect::side_type nsCSSRect::sides[4] = {
+  &nsCSSRect::mTop,
+  &nsCSSRect::mRight,
+  &nsCSSRect::mBottom,
+  &nsCSSRect::mLeft,
+};
+
+// --- nsCSSValuePair -----------------
+
+void
+nsCSSValuePair::AppendToString(nsCSSProperty aProperty, nsAString& aResult) const
+{
+  mXValue.AppendToString(aProperty, aResult);
+  // Only output a Y value if it's different from the X value,
+  // or if it's a background-position value other than 'initial'
+  // or 'inherit', or if it's a -moz-transform-origin value other
+  // than 'initial' or 'inherit', or if it's a background-size
+  // value other than 'initial' or 'inherit' or 'contain' or 'cover'.
+  if (mYValue != mXValue ||
+      ((aProperty == eCSSProperty_background_position ||
+        aProperty == eCSSProperty__moz_transform_origin) &&
+       mXValue.GetUnit() != eCSSUnit_Inherit &&
+       mXValue.GetUnit() != eCSSUnit_Initial) ||
+      (aProperty == eCSSProperty_background_size &&
+       mXValue.GetUnit() != eCSSUnit_Inherit &&
+       mXValue.GetUnit() != eCSSUnit_Initial &&
+       mXValue.GetUnit() != eCSSUnit_Enumerated)) {
+    aResult.Append(PRUnichar(' '));
+    mYValue.AppendToString(aProperty, aResult);
+  }
+}
+
+// --- nsCSSValuePairList -----------------
+
+nsCSSValuePairList::~nsCSSValuePairList()
+{
+  MOZ_COUNT_DTOR(nsCSSValuePairList);
+  NS_CSS_DELETE_LIST_MEMBER(nsCSSValuePairList, this, mNext);
+}
+
+nsCSSValuePairList*
+nsCSSValuePairList::Clone() const
+{
+  nsCSSValuePairList* result = new nsCSSValuePairList(*this);
+  nsCSSValuePairList* dest = result;
+  const nsCSSValuePairList* src = this->mNext;
+  while (src) {
+    dest->mNext = new nsCSSValuePairList(*src);
+    dest = dest->mNext;
+    src = src->mNext;
+  }
+  return result;
+}
+
+void
+nsCSSValuePairList::AppendToString(nsCSSProperty aProperty,
+                                   nsAString& aResult) const
+{
+  const nsCSSValuePairList* item = this;
+  for (;;) {
+    NS_ABORT_IF_FALSE(item->mXValue.GetUnit() != eCSSUnit_Null,
+                      "unexpected null unit");
+    item->mXValue.AppendToString(aProperty, aResult);
+    if (item->mXValue.GetUnit() != eCSSUnit_Inherit &&
+        item->mXValue.GetUnit() != eCSSUnit_Initial &&
+        item->mYValue.GetUnit() != eCSSUnit_Null) {
+      aResult.Append(PRUnichar(' '));
+      item->mYValue.AppendToString(aProperty, aResult);
+    }
+    item = item->mNext;
+    if (!item)
+      break;
+
+    if (nsCSSProps::PropHasFlags(aProperty,
+                                 CSS_PROPERTY_VALUE_LIST_USES_COMMAS))
+      aResult.Append(PRUnichar(','));
+    aResult.Append(PRUnichar(' '));
+  }
+}
+
+bool
+nsCSSValuePairList::operator==(const nsCSSValuePairList& aOther) const
+{
+  if (this == &aOther)
+    return true;
+
+  const nsCSSValuePairList *p1 = this, *p2 = &aOther;
+  for ( ; p1 && p2; p1 = p1->mNext, p2 = p2->mNext) {
+    if (p1->mXValue != p2->mXValue ||
+        p1->mYValue != p2->mYValue)
+      return false;
+  }
+  return !p1 && !p2; // true if same length, false otherwise
+}
+
 nsCSSValue::URL::URL(nsIURI* aURI, nsStringBuffer* aString, nsIURI* aReferrer,
                      nsIPrincipal* aOriginPrincipal)
   : mURI(aURI),
     mString(aString),
     mReferrer(aReferrer),
     mOriginPrincipal(aOriginPrincipal)
 {
   NS_PRECONDITION(aOriginPrincipal, "Must have an origin principal");
@@ -987,15 +1191,14 @@ nsCSSValueGradientStop::~nsCSSValueGradi
 {
   MOZ_COUNT_DTOR(nsCSSValueGradientStop);
 }
 
 nsCSSValueGradient::nsCSSValueGradient(PRBool aIsRadial,
                                        PRBool aIsRepeating)
   : mIsRadial(aIsRadial),
     mIsRepeating(aIsRepeating),
-    mBgPosX(eCSSUnit_None),
-    mBgPosY(eCSSUnit_None),
+    mBgPos(eCSSUnit_None),
     mAngle(eCSSUnit_None),
     mRadialShape(eCSSUnit_None),
     mRadialSize(eCSSUnit_None)
 {
 }
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -35,33 +35,31 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* representation of simple property values within CSS declarations */
 
 #ifndef nsCSSValue_h___
 #define nsCSSValue_h___
 
+#include "nsCOMPtr.h"
+#include "nsCRTGlue.h"
+#include "nsCSSKeywords.h"
+#include "nsCSSProperty.h"
 #include "nsColor.h"
+#include "nsCoord.h"
 #include "nsString.h"
-#include "nsCoord.h"
-#include "nsCSSProperty.h"
-#include "nsCSSKeywords.h"
-#include "nsIURI.h"
-#include "nsCOMPtr.h"
-#include "nsAutoPtr.h"
-#include "nsCRTGlue.h"
 #include "nsStringBuffer.h"
 #include "nsTArray.h"
-#include "nsISupportsImpl.h"
 
 class imgIRequest;
 class nsIDocument;
 class nsIPrincipal;
 class nsPresContext;
+class nsIURI;
 
 // Deletes a linked list iteratively to avoid blowing up the stack (bug 456196).
 #define NS_CSS_DELETE_LIST_MEMBER(type_, ptr_, member_)                        \
   {                                                                            \
     type_ *cur = (ptr_)->member_;                                              \
     (ptr_)->member_ = nsnull;                                                  \
     while (cur) {                                                              \
       type_ *next = cur->member_;                                              \
@@ -187,17 +185,17 @@ public:
   struct Array;
   friend struct Array;
 
   struct URL;
   friend struct URL;
 
   struct Image;
   friend struct Image;
-  
+
   // for valueless units only (null, auto, inherit, none, all, normal)
   explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
     : mUnit(aUnit)
   {
     NS_ASSERTION(aUnit <= eCSSUnit_RectIsAuto, "not a valueless unit");
   }
 
   nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit);
@@ -394,21 +392,21 @@ public:
   // Initializes as a function value with the specified function id.
   Array* InitFunction(nsCSSKeyword aFunctionId, PRUint32 aNumArgs);
   // Checks if this is a function value with the specified function id.
   PRBool EqualsFunction(nsCSSKeyword aFunctionId) const;
 
   // Returns an already addrefed buffer.  Can return null on allocation
   // failure.
   static nsStringBuffer* BufferFromString(const nsString& aValue);
-  
+
   struct URL {
     // Methods are not inline because using an nsIPrincipal means requiring
     // caps, which leads to REQUIRES hell, since this header is included all
-    // over.    
+    // over.
 
     // aString must not be null.
     // aOriginPrincipal must not be null.
     URL(nsIURI* aURI, nsStringBuffer* aString, nsIURI* aReferrer,
         nsIPrincipal* aOriginPrincipal);
 
     ~URL();
 
@@ -469,90 +467,16 @@ protected:
     nscolor    mColor;
     Array*     mArray;
     URL*       mURL;
     Image*     mImage;
     nsCSSValueGradient* mGradient;
   }         mValue;
 };
 
-struct nsCSSValueGradientStop {
-public:
-  nsCSSValueGradientStop();
-  // needed to keep bloat logs happy when we use the nsTArray in nsCSSValueGradient
-  nsCSSValueGradientStop(const nsCSSValueGradientStop& aOther);
-  ~nsCSSValueGradientStop();
-
-  nsCSSValue mLocation;
-  nsCSSValue mColor;
-
-  PRBool operator==(const nsCSSValueGradientStop& aOther) const
-  {
-    return (mLocation == aOther.mLocation &&
-            mColor == aOther.mColor);
-  }
-
-  PRBool operator!=(const nsCSSValueGradientStop& aOther) const
-  {
-    return !(*this == aOther);
-  }
-};
-
-struct nsCSSValueGradient {
-  nsCSSValueGradient(PRBool aIsRadial, PRBool aIsRepeating);
-
-  // true if gradient is radial, false if it is linear
-  PRPackedBool mIsRadial;
-  PRPackedBool mIsRepeating;
-  // line position and angle
-  nsCSSValue mBgPosX;
-  nsCSSValue mBgPosY;
-  nsCSSValue mAngle;
-
-  // Only meaningful if mIsRadial is true
-  nsCSSValue mRadialShape;
-  nsCSSValue mRadialSize;
-
-  nsTArray<nsCSSValueGradientStop> mStops;
-
-  PRBool operator==(const nsCSSValueGradient& aOther) const
-  {
-    if (mIsRadial != aOther.mIsRadial ||
-        mIsRepeating != aOther.mIsRepeating ||
-        mBgPosX != aOther.mBgPosX ||
-        mBgPosY != aOther.mBgPosY ||
-        mAngle != aOther.mAngle ||
-        mRadialShape != aOther.mRadialShape ||
-        mRadialSize != aOther.mRadialSize)
-      return PR_FALSE;
-
-    if (mStops.Length() != aOther.mStops.Length())
-      return PR_FALSE;
-
-    for (PRUint32 i = 0; i < mStops.Length(); i++) {
-      if (mStops[i] != aOther.mStops[i])
-        return PR_FALSE;
-    }
-
-    return PR_TRUE;
-  }
-
-  PRBool operator!=(const nsCSSValueGradient& aOther) const
-  {
-    return !(*this == aOther);
-  }
-
-  NS_INLINE_DECL_REFCOUNTING(nsCSSValueGradient)
-
-private:
-  // not to be implemented
-  nsCSSValueGradient(const nsCSSValueGradient& aOther);
-  nsCSSValueGradient& operator=(const nsCSSValueGradient& aOther);
-};
-
 struct nsCSSValue::Array {
 
   // return |Array| with reference count of zero
   static Array* Create(size_t aItemCount) {
     return new (aItemCount) Array(aItemCount);
   }
 
   nsCSSValue& operator[](size_t aIndex) {
@@ -646,10 +570,232 @@ private:
 #undef CSSVALUE_LIST_FOR_EXTRA_VALUES
 
 private:
   // not to be implemented
   Array(const Array& aOther);
   Array& operator=(const Array& aOther);
 };
 
+// Prefer nsCSSValue::Array for lists of fixed size.
+struct nsCSSValueList {
+  nsCSSValueList() : mNext(nsnull) { MOZ_COUNT_CTOR(nsCSSValueList); }
+  ~nsCSSValueList();
+
+  nsCSSValueList* Clone() const;  // makes a deep copy
+  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
+
+  bool operator==(nsCSSValueList const& aOther) const;
+  bool operator!=(const nsCSSValueList& aOther) const
+  { return !(*this == aOther); }
+
+  nsCSSValue      mValue;
+  nsCSSValueList* mNext;
+
+private:
+  nsCSSValueList(const nsCSSValueList& aCopy) // makes a shallow copy
+    : mValue(aCopy.mValue), mNext(nsnull)
+  {
+    MOZ_COUNT_CTOR(nsCSSValueList);
+  }
+};
+
+struct nsCSSRect {
+  nsCSSRect(void);
+  nsCSSRect(const nsCSSRect& aCopy);
+  ~nsCSSRect();
+
+  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
+
+  PRBool operator==(const nsCSSRect& aOther) const {
+    return mTop == aOther.mTop &&
+           mRight == aOther.mRight &&
+           mBottom == aOther.mBottom &&
+           mLeft == aOther.mLeft;
+  }
+
+  PRBool operator!=(const nsCSSRect& aOther) const {
+    return mTop != aOther.mTop ||
+           mRight != aOther.mRight ||
+           mBottom != aOther.mBottom ||
+           mLeft != aOther.mLeft;
+  }
+
+  void SetAllSidesTo(const nsCSSValue& aValue);
+
+  void Reset() {
+    mTop.Reset();
+    mRight.Reset();
+    mBottom.Reset();
+    mLeft.Reset();
+  }
+
+  PRBool HasValue() const {
+    return
+      mTop.GetUnit() != eCSSUnit_Null ||
+      mRight.GetUnit() != eCSSUnit_Null ||
+      mBottom.GetUnit() != eCSSUnit_Null ||
+      mLeft.GetUnit() != eCSSUnit_Null;
+  }
+
+  nsCSSValue mTop;
+  nsCSSValue mRight;
+  nsCSSValue mBottom;
+  nsCSSValue mLeft;
+
+  typedef nsCSSValue nsCSSRect::*side_type;
+  static const side_type sides[4];
+};
+
+struct nsCSSValuePair {
+  nsCSSValuePair()
+  {
+    MOZ_COUNT_CTOR(nsCSSValuePair);
+  }
+  nsCSSValuePair(nsCSSUnit aUnit)
+    : mXValue(aUnit), mYValue(aUnit)
+  {
+    MOZ_COUNT_CTOR(nsCSSValuePair);
+  }
+  nsCSSValuePair(const nsCSSValue& aXValue, const nsCSSValue& aYValue)
+    : mXValue(aXValue), mYValue(aYValue)
+  {
+    MOZ_COUNT_CTOR(nsCSSValuePair);
+  }
+  nsCSSValuePair(const nsCSSValuePair& aCopy)
+    : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue)
+  {
+    MOZ_COUNT_CTOR(nsCSSValuePair);
+  }
+  ~nsCSSValuePair()
+  {
+    MOZ_COUNT_DTOR(nsCSSValuePair);
+  }
+
+  PRBool operator==(const nsCSSValuePair& aOther) const {
+    return mXValue == aOther.mXValue &&
+           mYValue == aOther.mYValue;
+  }
+
+  PRBool operator!=(const nsCSSValuePair& aOther) const {
+    return mXValue != aOther.mXValue ||
+           mYValue != aOther.mYValue;
+  }
+
+  void SetBothValuesTo(const nsCSSValue& aValue) {
+    mXValue = aValue;
+    mYValue = aValue;
+  }
+
+  void Reset() {
+    mXValue.Reset();
+    mYValue.Reset();
+  }
+
+  PRBool HasValue() const {
+    return mXValue.GetUnit() != eCSSUnit_Null ||
+           mYValue.GetUnit() != eCSSUnit_Null;
+  }
+
+  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
+
+  nsCSSValue mXValue;
+  nsCSSValue mYValue;
+};
+
+// Maybe should be replaced with nsCSSValueList and nsCSSValue::Array?
+struct nsCSSValuePairList {
+  nsCSSValuePairList() : mNext(nsnull) { MOZ_COUNT_CTOR(nsCSSValuePairList); }
+  ~nsCSSValuePairList();
+
+  nsCSSValuePairList* Clone() const; // makes a deep copy
+  void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
+
+  bool operator==(const nsCSSValuePairList& aOther) const;
+  bool operator!=(const nsCSSValuePairList& aOther) const
+  { return !(*this == aOther); }
+
+  nsCSSValue          mXValue;
+  nsCSSValue          mYValue;
+  nsCSSValuePairList* mNext;
+
+private:
+  nsCSSValuePairList(const nsCSSValuePairList& aCopy) // makes a shallow copy
+    : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue), mNext(nsnull)
+  {
+    MOZ_COUNT_CTOR(nsCSSValuePairList);
+  }
+};
+
+struct nsCSSValueGradientStop {
+public:
+  nsCSSValueGradientStop();
+  // needed to keep bloat logs happy when we use the nsTArray in nsCSSValueGradient
+  nsCSSValueGradientStop(const nsCSSValueGradientStop& aOther);
+  ~nsCSSValueGradientStop();
+
+  nsCSSValue mLocation;
+  nsCSSValue mColor;
+
+  PRBool operator==(const nsCSSValueGradientStop& aOther) const
+  {
+    return (mLocation == aOther.mLocation &&
+            mColor == aOther.mColor);
+  }
+
+  PRBool operator!=(const nsCSSValueGradientStop& aOther) const
+  {
+    return !(*this == aOther);
+  }
+};
+
+struct nsCSSValueGradient {
+  nsCSSValueGradient(PRBool aIsRadial, PRBool aIsRepeating);
+
+  // true if gradient is radial, false if it is linear
+  PRPackedBool mIsRadial;
+  PRPackedBool mIsRepeating;
+  // line position and angle
+  nsCSSValuePair mBgPos;
+  nsCSSValue mAngle;
+
+  // Only meaningful if mIsRadial is true
+  nsCSSValue mRadialShape;
+  nsCSSValue mRadialSize;
+
+  nsTArray<nsCSSValueGradientStop> mStops;
+
+  PRBool operator==(const nsCSSValueGradient& aOther) const
+  {
+    if (mIsRadial != aOther.mIsRadial ||
+        mIsRepeating != aOther.mIsRepeating ||
+        mBgPos != aOther.mBgPos ||
+        mAngle != aOther.mAngle ||
+        mRadialShape != aOther.mRadialShape ||
+        mRadialSize != aOther.mRadialSize)
+      return PR_FALSE;
+
+    if (mStops.Length() != aOther.mStops.Length())
+      return PR_FALSE;
+
+    for (PRUint32 i = 0; i < mStops.Length(); i++) {
+      if (mStops[i] != aOther.mStops[i])
+        return PR_FALSE;
+    }
+
+    return PR_TRUE;
+  }
+
+  PRBool operator!=(const nsCSSValueGradient& aOther) const
+  {
+    return !(*this == aOther);
+  }
+
+  NS_INLINE_DECL_REFCOUNTING(nsCSSValueGradient)
+
+private:
+  // not to be implemented
+  nsCSSValueGradient(const nsCSSValueGradient& aOther);
+  nsCSSValueGradient& operator=(const nsCSSValueGradient& aOther);
+};
+
 #endif /* nsCSSValue_h___ */
 
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -840,20 +840,20 @@ static void SetGradient(const nsCSSValue
                  "bad unit for linear shape");
     NS_ASSERTION(gradient->mRadialSize.GetUnit() == eCSSUnit_None,
                  "bad unit for linear size");
     aResult.mShape = NS_STYLE_GRADIENT_SHAPE_LINEAR;
     aResult.mSize = NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER;
   }
 
   // bg-position
-  SetGradientCoord(gradient->mBgPosX, aPresContext, aContext,
+  SetGradientCoord(gradient->mBgPos.mXValue, aPresContext, aContext,
                    aResult.mBgPosX, aCanStoreInRuleTree);
 
-  SetGradientCoord(gradient->mBgPosY, aPresContext, aContext,
+  SetGradientCoord(gradient->mBgPos.mYValue, aPresContext, aContext,
                    aResult.mBgPosY, aCanStoreInRuleTree);
 
   aResult.mRepeating = gradient->mIsRepeating;
 
   // angle
   if (gradient->mAngle.IsAngularUnit()) {
     nsStyleUnit unit;
     switch (gradient->mAngle.GetUnit()) {
