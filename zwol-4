From: Zack Weinberg <zweinberg@mozilla.com>

Bug 576044 (4/12): eliminate ValuePairList as a storage type.  r=dbaron  a2.0=dbaron

diff --git a/layout/style/Declaration.cpp b/layout/style/Declaration.cpp
--- a/layout/style/Declaration.cpp
+++ b/layout/style/Declaration.cpp
@@ -137,20 +137,16 @@ PRBool Declaration::AppendValueToString(
     case eCSSType_Value:
       static_cast<const nsCSSValue*>(storage)->
         AppendToString(aProperty, aResult);
       break;
     case eCSSType_ValueList:
       (*static_cast<nsCSSValueList*const*>(storage))->
         AppendToString(aProperty, aResult);
       break;
-    case eCSSType_ValuePairList:
-      (*static_cast<nsCSSValuePairList*const*>(storage))->
-        AppendToString(aProperty, aResult);
-      break;
   }
   return PR_TRUE;
 }
 
 void
 Declaration::GetValue(nsCSSProperty aProperty, nsAString& aValue) const
 {
   aValue.Truncate(0);
@@ -209,22 +205,16 @@ Declaration::GetValue(nsCSSProperty aPro
         unit = val->GetUnit();
       } break;
       case eCSSType_ValueList: {
         const nsCSSValueList* item =
             *static_cast<nsCSSValueList*const*>(storage);
         NS_ABORT_IF_FALSE(item, "null not allowed in compressed block");
         unit = item->mValue.GetUnit();
       } break;
-      case eCSSType_ValuePairList: {
-        const nsCSSValuePairList* item =
-            *static_cast<nsCSSValuePairList*const*>(storage);
-        NS_ABORT_IF_FALSE(item, "null not allowed in compressed block");
-        unit = item->mXValue.GetUnit();
-      } break;
     }
     if (unit == eCSSUnit_Inherit) {
       ++inheritCount;
     } else if (unit == eCSSUnit_Initial) {
       ++initialCount;
     }
   }
   if (importantCount != 0 && importantCount != totalCount) {
@@ -430,23 +420,25 @@ Declaration::GetValue(nsCSSProperty aPro
       // values.  (We omit them if they're both default.)
       const nsCSSValueList *image =
         * data->ValueListStorageFor(eCSSProperty_background_image);
       const nsCSSValueList *repeat =
         * data->ValueListStorageFor(eCSSProperty_background_repeat);
       const nsCSSValueList *attachment =
         * data->ValueListStorageFor(eCSSProperty_background_attachment);
       const nsCSSValuePairList *position =
-        * data->ValuePairListStorageFor(eCSSProperty_background_position);
+        data->ValueStorageFor(eCSSProperty_background_position)->
+        GetPairListValue();
       const nsCSSValueList *clip =
         * data->ValueListStorageFor(eCSSProperty_background_clip);
       const nsCSSValueList *origin =
         * data->ValueListStorageFor(eCSSProperty_background_origin);
       const nsCSSValuePairList *size =
-        * data->ValuePairListStorageFor(eCSSProperty_background_size);
+        data->ValueStorageFor(eCSSProperty_background_size)->
+        GetPairListValue();
       for (;;) {
         if (size->mXValue.GetUnit() != eCSSUnit_Auto ||
             size->mYValue.GetUnit() != eCSSUnit_Auto) {
           // Non-default background-size, so can't be serialized as shorthand.
           aValue.Truncate();
           return;
         }
         image->mValue.AppendToString(eCSSProperty_background_image, aValue);
diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -242,18 +242,17 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                                 // Ignore 'color', 'border-*-color', etc.
                                 *target = nsCSSValue();
                             }
                         }
                     }
                     cursor += CDBValueStorage_advance;
                 } break;
 
-                case eCSSType_ValueList:
-                case eCSSType_ValuePairList: {
+                case eCSSType_ValueList: {
                     void** target = static_cast<void**>(prop);
                     if (!*target) {
                         if (ShouldStartImageLoads(aRuleData, iProp)) {
                             for (nsCSSValueList* l = ValueListAtCursor(cursor);
                                  l; l = l->mNext) {
                                 TryToStartImageLoad(l->mValue, doc, iProp);
                             }
                         }
@@ -273,18 +272,17 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                 } break;
             }
         } else {
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
                     cursor += CDBValueStorage_advance;
                 } break;
 
-                case eCSSType_ValueList:
-                case eCSSType_ValuePairList: {
+                case eCSSType_ValueList: {
                     cursor += CDBPointerStorage_advance;
                 } break;
             }
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 }
 
@@ -308,29 +306,27 @@ nsCSSCompressedDataBlock::StorageFor(nsC
         nsCSSProperty iProp = PropertyAtCursor(cursor);
         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
                      "out of range");
         if (iProp == aProperty) {
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
                     return ValueAtCursor(cursor);
                 }
-                case eCSSType_ValueList:
-                case eCSSType_ValuePairList: {
+                case eCSSType_ValueList: {
                     return &PointerAtCursor(const_cast<char*>(cursor));
                 }
             }
         }
         switch (nsCSSProps::kTypeTable[iProp]) {
             case eCSSType_Value: {
                 cursor += CDBValueStorage_advance;
             } break;
 
-            case eCSSType_ValueList:
-            case eCSSType_ValuePairList: {
+            case eCSSType_ValueList: {
                 cursor += CDBPointerStorage_advance;
             } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 
     return nsnull;
 }
@@ -358,32 +354,18 @@ nsCSSCompressedDataBlock::Clone() const
                 const nsCSSValue* val = ValueAtCursor(cursor);
                 NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
                 nsCSSValue *result_val = ValueAtCursor(result_cursor);
                 new (result_val) nsCSSValue(*val);
                 cursor += CDBValueStorage_advance;
                 result_cursor +=  CDBValueStorage_advance;
             } break;
 
-            case eCSSType_ValueList:
-            case eCSSType_ValuePairList: {
-                void *copy;
-                NS_ASSERTION(PointerAtCursor(cursor), "oops");
-                switch (nsCSSProps::kTypeTable[iProp]) {
-                    default:
-                        NS_NOTREACHED("unreachable");
-                        // fall through to keep gcc's uninitialized
-                        // variable warning quiet
-                    case eCSSType_ValueList:
-                        copy = ValueListAtCursor(cursor)->Clone();
-                        break;
-                    case eCSSType_ValuePairList:
-                        copy = ValuePairListAtCursor(cursor)->Clone();
-                        break;
-                }
+            case eCSSType_ValueList: {
+                void *copy = ValueListAtCursor(cursor)->Clone();
                 if (!copy) {
                     // so the destructor knows where to stop clearing
                     result->mBlockEnd = result_cursor;
                     return nsnull;
                 }
                 PointerAtCursor(result_cursor) = copy;
                 cursor += CDBPointerStorage_advance;
                 result_cursor += CDBPointerStorage_advance;
@@ -417,23 +399,16 @@ nsCSSCompressedDataBlock::~nsCSSCompress
             } break;
 
             case eCSSType_ValueList: {
                 nsCSSValueList* val = ValueListAtCursor(cursor);
                 NS_ASSERTION(val, "oops");
                 delete val;
                 cursor += CDBPointerStorage_advance;
             } break;
-
-            case eCSSType_ValuePairList: {
-                nsCSSValuePairList* val = ValuePairListAtCursor(cursor);
-                NS_ASSERTION(val, "oops");
-                delete val;
-                cursor += CDBPointerStorage_advance;
-            } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 }
 
 /* static */ nsCSSCompressedDataBlock*
 nsCSSCompressedDataBlock::CreateEmptyBlock()
 {
@@ -462,28 +437,16 @@ nsCSSCompressedDataBlock::MoveValue(void
       nsCSSValueList **source = static_cast<nsCSSValueList**>(aSource);
       nsCSSValueList **dest = static_cast<nsCSSValueList**>(aDest);
       if (**source != **dest)
         *aChanged = PR_TRUE;
       delete *dest;
       *dest = *source;
       *source = nsnull;
     } break;
-
-    case eCSSType_ValuePairList: {
-      nsCSSValuePairList **source =
-        static_cast<nsCSSValuePairList**>(aSource);
-      nsCSSValuePairList **dest =
-        static_cast<nsCSSValuePairList**>(aDest);
-      if (**source != **dest)
-        *aChanged = PR_TRUE;
-      delete *dest;
-      *dest = *source;
-      *source = nsnull;
-    } break;
   }
 }
 
 /*****************************************************************************/
 
 nsCSSExpandedDataBlock::nsCSSExpandedDataBlock()
 {
     AssertInitialState();
@@ -533,18 +496,17 @@ nsCSSExpandedDataBlock::DoExpand(nsCSSCo
                              "expanding into non-empty block");
 #ifdef NS_BUILD_REFCNT_LOGGING
                 dest->~nsCSSValue();
 #endif
                 memcpy(dest, val, sizeof(nsCSSValue));
                 cursor += CDBValueStorage_advance;
             } break;
 
-            case eCSSType_ValueList:
-            case eCSSType_ValuePairList: {
+            case eCSSType_ValueList: {
                 void* val = PointerAtCursor(cursor);
                 void** dest = static_cast<void**>(prop);
                 NS_ASSERTION(val, "oops");
                 NS_ASSERTION(!*dest, "expanding into non-empty block");
                 *dest = val;
                 cursor += CDBPointerStorage_advance;
             } break;
         }
@@ -591,18 +553,17 @@ nsCSSExpandedDataBlock::ComputeSize()
 #ifdef DEBUG
                     nsCSSValue* val = static_cast<nsCSSValue*>(prop);
                     NS_ASSERTION(val->GetUnit() != eCSSUnit_Null,
                                  "null value while computing size");
 #endif
                     increment = CDBValueStorage_advance;
                 } break;
 
-                case eCSSType_ValueList:
-                case eCSSType_ValuePairList: {
+                case eCSSType_ValueList: {
 #ifdef DEBUG
                     void* val = *static_cast<void**>(prop);
                     NS_ASSERTION(val, "Null pointer while computing size");
 #endif
                     increment = CDBPointerStorage_advance;
                 } break;
             }
             if (mPropertiesImportant.HasPropertyAt(iHigh, iLow))
@@ -671,18 +632,17 @@ nsCSSExpandedDataBlock::Compress(nsCSSCo
                     CDBValueStorage *storage =
                         reinterpret_cast<CDBValueStorage*>(cursor);
                     storage->property = iProp;
                     memcpy(&storage->value, val, sizeof(nsCSSValue));
                     new (val) nsCSSValue();
                     cursor += CDBValueStorage_advance;
                 } break;
 
-                case eCSSType_ValueList:
-                case eCSSType_ValuePairList: {
+                case eCSSType_ValueList: {
                     void*& val = *static_cast<void**>(prop);
                     NS_ASSERTION(val, "Null pointer while compressing");
                     CDBPointerStorage *storage =
                         reinterpret_cast<CDBPointerStorage*>(cursor);
                     storage->property = iProp;
                     storage->value = val;
                     val = nsnull;
                     cursor += CDBPointerStorage_advance;
@@ -756,25 +716,16 @@ nsCSSExpandedDataBlock::ClearLonghandPro
 
         case eCSSType_ValueList: {
             nsCSSValueList*& val = *static_cast<nsCSSValueList**>(prop);
             if (val) {
                 delete val;
                 val = nsnull;
             }
         } break;
-
-        case eCSSType_ValuePairList: {
-            nsCSSValuePairList*& val =
-              *static_cast<nsCSSValuePairList**>(prop);
-            if (val) {
-                delete val;
-                val = nsnull;
-            }
-        } break;
     }
 }
 
 void
 nsCSSExpandedDataBlock::TransferFromBlock(nsCSSExpandedDataBlock& aFromBlock,
                                           nsCSSProperty aPropID,
                                           PRBool aIsImportant,
                                           PRBool aOverrideImportant,
@@ -855,18 +806,12 @@ nsCSSExpandedDataBlock::DoAssertInitialS
                 NS_ASSERTION(val->GetUnit() == eCSSUnit_Null,
                              "not initial state");
             } break;
 
             case eCSSType_ValueList: {
                 nsCSSValueList* val = *static_cast<nsCSSValueList**>(prop);
                 NS_ASSERTION(val == nsnull, "not initial state");
             } break;
-
-            case eCSSType_ValuePairList: {
-                nsCSSValuePairList* val =
-                  *static_cast<nsCSSValuePairList**>(prop);
-                NS_ASSERTION(val == nsnull, "not initial state");
-            } break;
         }
     }
 }
 #endif
diff --git a/layout/style/nsCSSDataBlock.h b/layout/style/nsCSSDataBlock.h
--- a/layout/style/nsCSSDataBlock.h
+++ b/layout/style/nsCSSDataBlock.h
@@ -109,24 +109,16 @@ public:
     }
     const nsCSSValueList*const*
     ValueListStorageFor(nsCSSProperty aProperty) const {
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValueList,
                         "type mismatch");
       return static_cast<const nsCSSValueList*const*>(StorageFor(aProperty));
     }
-    const nsCSSValuePairList*const*
-    ValuePairListStorageFor(nsCSSProperty aProperty) const {
-      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                          eCSSType_ValuePairList,
-                        "type mismatch");
-      return static_cast<const nsCSSValuePairList*const*>(
-               StorageFor(aProperty));
-    }
 
     /**
      * Clone this block, or return null on out-of-memory.
      */
     nsCSSCompressedDataBlock* Clone() const;
 
     /**
      * Create a new nsCSSCompressedDataBlock holding no declarations.
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -477,18 +477,17 @@ protected:
   PRBool ParseCalcTerm(nsCSSValue& aValue, PRInt32& aVariantMask);
   PRBool ParseCalcMinMax(nsCSSValue& aValue, nsCSSUnit aUnit,
                          PRInt32& aVariantMask);
   PRBool RequireWhitespace();
 
   // for 'clip' and '-moz-image-region'
   PRBool ParseRect(nsCSSProperty aPropID);
   PRBool ParseContent();
-  PRBool ParseCounterData(nsCSSValuePairList** aResult,
-                          nsCSSProperty aPropID);
+  PRBool ParseCounterData(nsCSSProperty aPropID);
   PRBool ParseCue();
   PRBool ParseCursor();
   PRBool ParseFont();
   PRBool ParseFontWeight(nsCSSValue& aValue);
   PRBool ParseOneFamily(nsAString& aValue);
   PRBool ParseFamily(nsCSSValue& aValue);
   PRBool ParseFontSrc(nsCSSValue& aValue);
   PRBool ParseFontSrcFormat(nsTArray<nsCSSValue>& values);
@@ -5331,21 +5330,18 @@ CSSParserImpl::ParseProperty(nsCSSProper
     return ParseBoxShadow();
   case eCSSProperty_clip:
     return ParseRect(eCSSProperty_clip);
   case eCSSProperty__moz_column_rule:
     return ParseBorderSide(kColumnRuleIDs, PR_FALSE);
   case eCSSProperty_content:
     return ParseContent();
   case eCSSProperty_counter_increment:
-    return ParseCounterData(&mTempData.mContent.mCounterIncrement,
-                            aPropID);
   case eCSSProperty_counter_reset:
-    return ParseCounterData(&mTempData.mContent.mCounterReset,
-                            aPropID);
+    return ParseCounterData(aPropID);
   case eCSSProperty_cue:
     return ParseCue();
   case eCSSProperty_cursor:
     return ParseCursor();
   case eCSSProperty_font:
     return ParseFont();
   case eCSSProperty_image_region:
     return ParseRect(eCSSProperty_image_region);
@@ -6245,18 +6241,49 @@ CSSParserImpl::ParseBackground()
 
     if (!bgitem.mLastItem && ExpectSymbol(',', PR_TRUE)) {
       continue;
     }
     if (!ExpectEndProperty()) {
       break;
     }
 
-    mTempData.mColor.mBackPosition = positionHead;
-    mTempData.mColor.mBackSize = sizeHead;
+    // pairlists are not allowed to be initial/inherit anymore
+    if (positionHead->mXValue.GetUnit() == eCSSUnit_Inherit ||
+        positionHead->mXValue.GetUnit() == eCSSUnit_Initial) {
+      NS_ABORT_IF_FALSE(positionHead->mYValue == positionHead->mXValue,
+                        "half-inherit/initial");
+      mTempData.mColor.mBackPosition = positionHead->mXValue;
+      delete positionHead;
+    } else {
+      // this kludge will go away in the next patch
+      nsCSSValuePairList* list =
+        mTempData.mColor.mBackPosition.SetPairListValue();
+      list->mXValue = positionHead->mXValue;
+      list->mYValue = positionHead->mYValue;
+      list->mNext = positionHead->mNext;
+      positionHead->mNext = nsnull;
+      delete positionHead;
+    }
+    if (sizeHead->mXValue.GetUnit() == eCSSUnit_Inherit ||
+        sizeHead->mXValue.GetUnit() == eCSSUnit_Initial) {
+      NS_ABORT_IF_FALSE(sizeHead->mYValue == sizeHead->mXValue,
+                        "half-inherit/initial");
+      mTempData.mColor.mBackSize = sizeHead->mXValue;
+      delete sizeHead;
+    } else {
+      // this kludge will go away in the next patch
+      nsCSSValuePairList* list =
+        mTempData.mColor.mBackSize.SetPairListValue();
+      list->mXValue = sizeHead->mXValue;
+      list->mYValue = sizeHead->mYValue;
+      list->mNext = sizeHead->mNext;
+      sizeHead->mNext = nsnull;
+      delete sizeHead;
+    }
     for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
       nsCSSValueList **source = static_cast<nsCSSValueList**>(
         mTempData.PropertyAt(simpleValues[i].propID));
       *source = simpleHeads[i];
     }
 
     mTempData.SetPropertyBit(eCSSProperty_background_image);
     mTempData.SetPropertyBit(eCSSProperty_background_repeat);
@@ -6484,46 +6511,46 @@ CSSParserImpl::ParseBackgroundList(nsCSS
   delete head;
   return PR_FALSE;
 }
 
 // This function is very similar to ParseBackgroundList and ParseBackgroundSize.
 PRBool
 CSSParserImpl::ParseBackgroundPosition()
 {
-  // aPropID is a single value prop-id
-  nsCSSValuePair valuePair;
-  nsCSSValuePairList *head = nsnull, **tail = &head;
-  for (;;) {
-    if (!ParseBoxPositionValues(valuePair, !head)) {
-      break;
-    }
-    PRBool inheritOrInitial = valuePair.mXValue.GetUnit() == eCSSUnit_Inherit ||
-                              valuePair.mXValue.GetUnit() == eCSSUnit_Initial;
-    nsCSSValuePairList *item = new nsCSSValuePairList;
-    if (!item) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    item->mXValue = valuePair.mXValue;
-    item->mYValue = valuePair.mYValue;
-    *tail = item;
-    tail = &item->mNext;
-    if (!inheritOrInitial && ExpectSymbol(',', PR_TRUE)) {
-      continue;
-    }
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
+    // 'initial' and 'inherit' stand alone, no list permitted.
     if (!ExpectEndProperty()) {
-      break;
-    }
-    mTempData.mColor.mBackPosition = head;
-    mTempData.SetPropertyBit(eCSSProperty_background_position);
-    return PR_TRUE;
-  }
-  delete head;
-  return PR_FALSE;
+      return PR_FALSE;
+    }
+  } else {
+    nsCSSValuePair valuePair;
+    if (!ParseBoxPositionValues(valuePair, PR_FALSE)) {
+      return PR_FALSE;
+    }
+    nsCSSValuePairList* item = value.SetPairListValue();
+    for (;;) {
+      item->mXValue = valuePair.mXValue;
+      item->mYValue = valuePair.mYValue;
+      if (CheckEndProperty()) {
+        break;
+      }
+      if (!ExpectSymbol(',', PR_TRUE)) {
+        return PR_FALSE;
+      }
+      if (!ParseBoxPositionValues(valuePair, PR_FALSE)) {
+        return PR_FALSE;
+      }
+      item->mNext = new nsCSSValuePairList();
+      item = item->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_background_position, value);
+  return PR_TRUE;
 }
 
 /**
  * Parses two values that correspond to positions in a box.  These can be
  * values corresponding to percentages of the box, raw offsets, or keywords
  * like "top," "left center," etc.
  *
  * @param aOut The nsCSSValuePair in which to place the result.
@@ -6611,57 +6638,46 @@ PRBool CSSParserImpl::ParseBoxPositionVa
   return PR_TRUE;
 }
 
 // This function is very similar to ParseBackgroundList and
 // ParseBackgroundPosition.
 PRBool
 CSSParserImpl::ParseBackgroundSize()
 {
-  nsCSSValuePair valuePair;
-  nsCSSValuePairList *head = nsnull, **tail = &head;
-  if (ParseVariant(valuePair.mXValue, VARIANT_INHERIT, nsnull)) {
-    // 'initial' and 'inherit' stand alone, no second value.
-    head = new nsCSSValuePairList;
-    if (!head) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
+    // 'initial' and 'inherit' stand alone, no list permitted.
+    if (!ExpectEndProperty()) {
       return PR_FALSE;
     }
-    head->mXValue = valuePair.mXValue;
-    head->mYValue.Reset();
-    mTempData.mColor.mBackSize = head;
-    mTempData.SetPropertyBit(eCSSProperty_background_size);
-    return ExpectEndProperty();
-  }
-
-  for (;;) {
+  } else {
+    nsCSSValuePair valuePair;
     if (!ParseBackgroundSizeValues(valuePair)) {
-      break;
-    }
-    nsCSSValuePairList *item = new nsCSSValuePairList;
-    if (!item) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    item->mXValue = valuePair.mXValue;
-    item->mYValue = valuePair.mYValue;
-    *tail = item;
-    tail = &item->mNext;
-    if (ExpectSymbol(',', PR_TRUE)) {
-      continue;
-    }
-    if (!ExpectEndProperty()) {
-      break;
-    }
-    mTempData.mColor.mBackSize = head;
-    mTempData.SetPropertyBit(eCSSProperty_background_size);
-    return PR_TRUE;
-  }
-  delete head;
-  return PR_FALSE;
+      return PR_FALSE;
+    }
+    nsCSSValuePairList* item = value.SetPairListValue();
+    for (;;) {
+      item->mXValue = valuePair.mXValue;
+      item->mYValue = valuePair.mYValue;
+      if (CheckEndProperty()) {
+        break;
+      }
+      if (!ExpectSymbol(',', PR_TRUE)) {
+        return PR_FALSE;
+      }
+      if (!ParseBackgroundSizeValues(valuePair)) {
+        return PR_FALSE;
+      }
+      item->mNext = new nsCSSValuePairList();
+      item = item->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_background_size, value);
+  return PR_TRUE;
 }
 
 /**
  * Parses two values that correspond to lengths for the background-size
  * property.  These can be one or two lengths (or the 'auto' keyword) or
  * percentages corresponding to the element's dimensions or the single keywords
  * 'contain' or 'cover'.  'initial' and 'inherit' must be handled by the caller
  * if desired.
@@ -7504,82 +7520,48 @@ CSSParserImpl::ParseContent()
         break;
       }
     }
     delete listHead;
   }
   return PR_FALSE;
 }
 
-struct SingleCounterPropValue {
-  char str[13];
-  nsCSSUnit unit;
-};
-
-PRBool
-CSSParserImpl::ParseCounterData(nsCSSValuePairList** aResult,
-                                nsCSSProperty aPropID)
-{
-  nsSubstring* ident = NextIdent();
-  if (nsnull == ident) {
-    return PR_FALSE;
-  }
-  static const SingleCounterPropValue singleValues[] = {
-    { "none", eCSSUnit_None },
-    { "inherit", eCSSUnit_Inherit },
-    { "-moz-initial", eCSSUnit_Initial }
-  };
-  for (const SingleCounterPropValue *sv = singleValues,
-           *sv_end = singleValues + NS_ARRAY_LENGTH(singleValues);
-       sv != sv_end; ++sv) {
-    if (ident->LowerCaseEqualsASCII(sv->str)) {
-      if (CheckEndProperty()) {
-        nsCSSValuePairList* dataHead = new nsCSSValuePairList();
-        if (!dataHead) {
-          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-          return PR_FALSE;
-        }
-        dataHead->mXValue = nsCSSValue(sv->unit);
-        *aResult = dataHead;
-        mTempData.SetPropertyBit(aPropID);
-        return PR_TRUE;
-      }
+PRBool
+CSSParserImpl::ParseCounterData(nsCSSProperty aPropID)
+{
+  nsCSSValue value;
+  if (!ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
+    if (!GetToken(PR_TRUE) || mToken.mType != eCSSToken_Ident) {
       return PR_FALSE;
     }
-  }
-  UngetToken(); // undo NextIdent
-
-  nsCSSValuePairList* dataHead = nsnull;
-  nsCSSValuePairList **next = &dataHead;
-  for (;;) {
-    if (!GetToken(PR_TRUE) || mToken.mType != eCSSToken_Ident) {
-      break;
-    }
-    nsCSSValuePairList *data = *next = new nsCSSValuePairList();
-    if (!data) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    next = &data->mNext;
-    data->mXValue.SetStringValue(mToken.mIdent, eCSSUnit_Ident);
-    if (GetToken(PR_TRUE)) {
-      if (eCSSToken_Number == mToken.mType && mToken.mIntegerValid) {
-        data->mYValue.SetIntValue(mToken.mInteger, eCSSUnit_Integer);
+
+    nsCSSValuePairList *cur = value.SetPairListValue();
+    for (;;) {
+      cur->mXValue.SetStringValue(mToken.mIdent, eCSSUnit_Ident);
+      if (!GetToken(PR_TRUE)) {
+        break;
+      }
+      if (mToken.mType == eCSSToken_Number && mToken.mIntegerValid) {
+        cur->mYValue.SetIntValue(mToken.mInteger, eCSSUnit_Integer);
       } else {
         UngetToken();
       }
-    }
-    if (ExpectEndProperty()) {
-      mTempData.SetPropertyBit(aPropID);
-      *aResult = dataHead;
-      return PR_TRUE;
-    }
-  }
-  delete dataHead;
-  return PR_FALSE;
+      if (ExpectEndProperty()) {
+        break;
+      }
+      if (!GetToken(PR_TRUE) || mToken.mType != eCSSToken_Ident) {
+        return PR_FALSE;
+      }
+      cur->mNext = new nsCSSValuePairList();
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(aPropID, value);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseCue()
 {
   nsCSSValue before;
   if (ParseSingleValueProperty(before, eCSSProperty_cue_before)) {
     if (eCSSUnit_Inherit != before.GetUnit() &&
@@ -8622,60 +8604,46 @@ CSSParserImpl::ParsePause()
     }
   }
   return PR_FALSE;
 }
 
 PRBool
 CSSParserImpl::ParseQuotes()
 {
-  nsCSSValue  open;
-  if (ParseVariant(open, VARIANT_HOS, nsnull)) {
-    if (eCSSUnit_String == open.GetUnit()) {
-      nsCSSValuePairList* quotesHead = new nsCSSValuePairList();
-      nsCSSValuePairList* quotes = quotesHead;
-      if (nsnull == quotes) {
-        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  nsCSSValue value;
+  if (!ParseVariant(value, VARIANT_HOS, nsnull)) {
+    return PR_FALSE;
+  }
+  if (value.GetUnit() != eCSSUnit_String) {
+    if (!ExpectEndProperty()) {
+      return PR_FALSE;
+    }
+  } else {
+    nsCSSValue open = value;
+    nsCSSValuePairList* quotes = value.SetPairListValue();
+    for (;;) {
+      quotes->mXValue = open;
+      // get mandatory close
+      if (!ParseVariant(quotes->mYValue, VARIANT_STRING, nsnull)) {
         return PR_FALSE;
       }
-      quotes->mXValue = open;
-      while (nsnull != quotes) {
-        // get mandatory close
-        if (ParseVariant(quotes->mYValue, VARIANT_STRING,
-                         nsnull)) {
-          if (CheckEndProperty()) {
-            mTempData.SetPropertyBit(eCSSProperty_quotes);
-            mTempData.mContent.mQuotes = quotesHead;
-            return PR_TRUE;
-          }
-          // look for another open
-          if (ParseVariant(open, VARIANT_STRING, nsnull)) {
-            quotes->mNext = new nsCSSValuePairList();
-            quotes = quotes->mNext;
-            if (nsnull != quotes) {
-              quotes->mXValue = open;
-              continue;
-            }
-            mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-          }
-        }
+      if (CheckEndProperty()) {
         break;
       }
-      delete quotesHead;
-      return PR_FALSE;
-    }
-    if (ExpectEndProperty()) {
-      nsCSSValuePairList* quotesHead = new nsCSSValuePairList();
-      quotesHead->mXValue = open;
-      mTempData.mContent.mQuotes = quotesHead;
-      mTempData.SetPropertyBit(eCSSProperty_quotes);
-      return PR_TRUE;
-    }
-  }
-  return PR_FALSE;
+      // look for another open
+      if (!ParseVariant(open, VARIANT_STRING, nsnull)) {
+        return PR_FALSE;
+      }
+      quotes->mNext = new nsCSSValuePairList();
+      quotes = quotes->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_quotes, value);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseSize()
 {
   nsCSSValue width, height;
   if (!ParseVariant(width, VARIANT_AHKL, nsCSSProps::kPageSizeKTable)) {
     return PR_FALSE;
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -513,17 +513,17 @@ CSS_PROP_BACKGROUND(
 CSS_PROP_BACKGROUND(
     background-position,
     background_position,
     BackgroundPosition,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackPosition,
-    eCSSType_ValuePairList,
+    eCSSType_Value,
     kBackgroundPositionKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_Custom)
 CSS_PROP_BACKGROUND(
     background-repeat,
     background_repeat,
     BackgroundRepeat,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
@@ -537,17 +537,17 @@ CSS_PROP_BACKGROUND(
 CSS_PROP_BACKGROUND(
     background-size,
     background_size,
     BackgroundSize,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackSize,
-    eCSSType_ValuePairList,
+    eCSSType_Value,
     kBackgroundSizeKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_Custom)
 CSS_PROP_DISPLAY(
     -moz-binding,
     binding,
     MozBinding,
     0,
@@ -1294,28 +1294,28 @@ CSS_PROP_CONTENT(
     eStyleAnimType_None)
 CSS_PROP_CONTENT(
     counter-increment,
     counter_increment,
     CounterIncrement,
     0,
     Content,
     mCounterIncrement,
-    eCSSType_ValuePairList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None) // XXX bug 137285
 CSS_PROP_CONTENT(
     counter-reset,
     counter_reset,
     CounterReset,
     0,
     Content,
     mCounterReset,
-    eCSSType_ValuePairList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None) // XXX bug 137285
 CSS_PROP_SHORTHAND(
     cue,
     cue,
     Cue,
     0)
@@ -2198,17 +2198,17 @@ CSS_PROP_DISPLAY(
     eStyleAnimType_None)
 CSS_PROP_QUOTES(
     quotes,
     quotes,
     Quotes,
     0,
     Content,
     mQuotes,
-    eCSSType_ValuePairList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_DISPLAY(
     resize,
     resize,
     Resize,
     0,
diff --git a/layout/style/nsCSSProperty.h b/layout/style/nsCSSProperty.h
--- a/layout/style/nsCSSProperty.h
+++ b/layout/style/nsCSSProperty.h
@@ -78,18 +78,17 @@ enum nsCSSProperty {
   // Extra dummy values for nsCSSParser internal use.
   eCSSPropertyExtra_x_none_value
 };
 
 // The types of values that can be in the nsCSS*/nsRuleData* structs.
 // See nsCSSPropList.h for uses.
 enum nsCSSType {
   eCSSType_Value,
-  eCSSType_ValueList,
-  eCSSType_ValuePairList
+  eCSSType_ValueList
 };
 
 // The "descriptors" that can appear in a @font-face rule.
 // They have the syntax of properties but different value rules.
 // Keep in sync with kCSSRawFontDescs in nsCSSProps.cpp and
 // nsCSSFontFaceStyleDecl::Fields in nsCSSRules.cpp.
 enum nsCSSFontDesc {
   eCSSFontDesc_UNKNOWN = -1,
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -59,33 +59,29 @@ nsCSSFont::~nsCSSFont(void)
 }
 
 // --- nsCSSColor -----------------
 
 nsCSSColor::nsCSSColor(void)
   : mBackImage(nsnull)
   , mBackRepeat(nsnull)
   , mBackAttachment(nsnull)
-  , mBackPosition(nsnull)
-  , mBackSize(nsnull)
   , mBackClip(nsnull)
   , mBackOrigin(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSColor);
 }
 
 nsCSSColor::~nsCSSColor(void)
 {
   MOZ_COUNT_DTOR(nsCSSColor);
 
   delete mBackImage;
   delete mBackRepeat;
   delete mBackAttachment;
-  delete mBackPosition;
-  delete mBackSize;
   delete mBackClip;
   delete mBackOrigin;
 }
 
 // --- nsCSSText -----------------
 
 nsCSSText::nsCSSText(void)
   : mTextShadow(nsnull)
@@ -261,31 +257,25 @@ nsCSSPage::nsCSSPage(void)
 nsCSSPage::~nsCSSPage(void)
 {
   MOZ_COUNT_DTOR(nsCSSPage);
 }
 
 // --- nsCSSContent -----------------
 
 nsCSSContent::nsCSSContent(void)
-  : mContent(nsnull),
-    mCounterIncrement(nsnull),
-    mCounterReset(nsnull),
-    mQuotes(nsnull)
+  : mContent(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSContent);
 }
 
 nsCSSContent::~nsCSSContent(void)
 {
   MOZ_COUNT_DTOR(nsCSSContent);
   delete mContent;
-  delete mCounterIncrement;
-  delete mCounterReset;
-  delete mQuotes;
 }
 
 // --- nsCSSUserInterface -----------------
 
 nsCSSUserInterface::nsCSSUserInterface(void)
   : mCursor(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSUserInterface);
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -164,18 +164,18 @@ struct nsCSSColor : public nsCSSStruct  
   nsCSSColor(void);
   ~nsCSSColor(void);
 
   nsCSSValue      mColor;
   nsCSSValue      mBackColor;
   nsCSSValueList* mBackImage;
   nsCSSValueList* mBackRepeat;
   nsCSSValueList* mBackAttachment;
-  nsCSSValuePairList* mBackPosition;
-  nsCSSValuePairList* mBackSize;
+  nsCSSValue      mBackPosition;
+  nsCSSValue      mBackSize;
   nsCSSValueList* mBackClip;
   nsCSSValueList* mBackOrigin;
   nsCSSValue      mBackInlinePolicy;
 private:
   nsCSSColor(const nsCSSColor& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataColor : public nsCSSColor {
@@ -415,20 +415,20 @@ private:
   nsRuleDataPage(const nsRuleDataPage& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSContent : public nsCSSStruct  {
   nsCSSContent(void);
   ~nsCSSContent(void);
 
   nsCSSValueList*     mContent;
-  nsCSSValuePairList* mCounterIncrement;
-  nsCSSValuePairList* mCounterReset;
+  nsCSSValue          mCounterIncrement;
+  nsCSSValue          mCounterReset;
   nsCSSValue          mMarkerOffset;
-  nsCSSValuePairList* mQuotes;
+  nsCSSValue          mQuotes;
 private:
   nsCSSContent(const nsCSSContent& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataContent : public nsCSSContent {
   nsRuleDataContent() {}
 private:
   nsRuleDataContent(const nsRuleDataContent& aOther); // NOT IMPLEMENTED
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -161,32 +161,43 @@ nsCSSValue::nsCSSValue(const nsCSSValue&
   else if (eCSSUnit_Pair == mUnit) {
     mValue.mPair = aCopy.mValue.mPair;
     mValue.mPair->AddRef();
   }
   else if (eCSSUnit_Rect == mUnit) {
     mValue.mRect = aCopy.mValue.mRect;
     mValue.mRect->AddRef();
   }
+  else if (eCSSUnit_PairList == mUnit) {
+    mValue.mPairList = aCopy.mValue.mPairList;
+    mValue.mPairList->AddRef();
+  }
+  else if (eCSSUnit_PairListDep == mUnit) {
+    mValue.mPairListDependent = aCopy.mValue.mPairListDependent;
+  }
   else {
     NS_NOTREACHED("unknown unit");
   }
 }
 
 nsCSSValue& nsCSSValue::operator=(const nsCSSValue& aCopy)
 {
   if (this != &aCopy) {
     Reset();
     new (this) nsCSSValue(aCopy);
   }
   return *this;
 }
 
 PRBool nsCSSValue::operator==(const nsCSSValue& aOther) const
 {
+  NS_ABORT_IF_FALSE(mUnit != eCSSUnit_PairListDep &&
+                    aOther.mUnit != eCSSUnit_PairListDep,
+                    "don't use operator== with dependent lists");
+
   if (mUnit == aOther.mUnit) {
     if (mUnit <= eCSSUnit_DummyInherit) {
       return PR_TRUE;
     }
     else if (UnitHasStringValue()) {
       return (NS_strcmp(GetBufferValue(mValue.mString),
                         GetBufferValue(aOther.mValue.mString)) == 0);
     }
@@ -209,16 +220,19 @@ PRBool nsCSSValue::operator==(const nsCS
       return *mValue.mGradient == *aOther.mValue.mGradient;
     }
     else if (eCSSUnit_Pair == mUnit) {
       return *mValue.mPair == *aOther.mValue.mPair;
     }
     else if (eCSSUnit_Rect == mUnit) {
       return *mValue.mRect == *aOther.mValue.mRect;
     }
+    else if (eCSSUnit_PairList == mUnit) {
+      return *mValue.mPairList == *aOther.mValue.mPairList;
+    }
     else {
       return mValue.mFloat == aOther.mValue.mFloat;
     }
   }
   return PR_FALSE;
 }
 
 double nsCSSValue::GetAngleValueInRadians() const
@@ -280,16 +294,18 @@ void nsCSSValue::DoReset()
   } else if (eCSSUnit_Image == mUnit) {
     mValue.mImage->Release();
   } else if (eCSSUnit_Gradient == mUnit) {
     mValue.mGradient->Release();
   } else if (eCSSUnit_Pair == mUnit) {
     mValue.mPair->Release();
   } else if (eCSSUnit_Rect == mUnit) {
     mValue.mRect->Release();
+  } else if (eCSSUnit_PairList == mUnit) {
+    mValue.mPairList->Release();
   }
   mUnit = eCSSUnit_Null;
 }
 
 void nsCSSValue::SetIntValue(PRInt32 aValue, nsCSSUnit aUnit)
 {
   NS_ASSERTION(aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
                aUnit == eCSSUnit_EnumColor, "not an int value");
@@ -412,16 +428,32 @@ nsCSSRect& nsCSSValue::SetRectValue()
 {
   Reset();
   mUnit = eCSSUnit_Rect;
   mValue.mRect = new nsCSSRect_heap;
   mValue.mRect->AddRef();
   return *mValue.mRect;
 }
 
+nsCSSValuePairList* nsCSSValue::SetPairListValue()
+{
+  Reset();
+  mUnit = eCSSUnit_PairList;
+  mValue.mPairList = new nsCSSValuePairList_heap;
+  mValue.mPairList->AddRef();
+  return mValue.mPairList;
+}
+
+void nsCSSValue::SetDependentPairListValue(nsCSSValuePairList* aList)
+{
+  Reset();
+  mUnit = eCSSUnit_PairListDep;
+  mValue.mPairListDependent = aList;
+}
+
 void nsCSSValue::SetAutoValue()
 {
   Reset();
   mUnit = eCSSUnit_Auto;
 }
 
 void nsCSSValue::SetInheritValue()
 {
@@ -887,16 +919,18 @@ nsCSSValue::AppendToString(nsCSSProperty
       aResult.AppendLiteral(", ");
     }
 
     aResult.AppendLiteral(")");
   } else if (eCSSUnit_Pair == unit) {
     GetPairValue().AppendToString(aProperty, aResult);
   } else if (eCSSUnit_Rect == unit) {
     GetRectValue().AppendToString(aProperty, aResult);
+  } else if (eCSSUnit_PairList == unit || eCSSUnit_PairListDep == unit) {
+    GetPairListValue()->AppendToString(aProperty, aResult);
   }
 
   switch (unit) {
     case eCSSUnit_Null:         break;
     case eCSSUnit_Auto:         aResult.AppendLiteral("auto");     break;
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
     case eCSSUnit_Initial:      aResult.AppendLiteral("-moz-initial"); break;
     case eCSSUnit_None:         aResult.AppendLiteral("none");     break;
@@ -934,16 +968,18 @@ nsCSSValue::AppendToString(nsCSSProperty
     case eCSSUnit_Enumerated:   break;
     case eCSSUnit_EnumColor:    break;
     case eCSSUnit_Color:        break;
     case eCSSUnit_Percent:      aResult.Append(PRUnichar('%'));    break;
     case eCSSUnit_Number:       break;
     case eCSSUnit_Gradient:     break;
     case eCSSUnit_Pair:         break;
     case eCSSUnit_Rect:         break;
+    case eCSSUnit_PairList:     break;
+    case eCSSUnit_PairListDep:  break;
 
     case eCSSUnit_Inch:         aResult.AppendLiteral("in");   break;
     case eCSSUnit_Millimeter:   aResult.AppendLiteral("mm");   break;
     case eCSSUnit_PhysicalMillimeter: aResult.AppendLiteral("mozmm");   break;
     case eCSSUnit_Centimeter:   aResult.AppendLiteral("cm");   break;
     case eCSSUnit_Point:        aResult.AppendLiteral("pt");   break;
     case eCSSUnit_Pica:         aResult.AppendLiteral("pc");   break;
 
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -139,16 +139,19 @@ enum nsCSSUnit {
   eCSSUnit_Calc_Maximum = 32,     // (nsCSSValue::Array*) max() within calc
 
   eCSSUnit_URL          = 40,     // (nsCSSValue::URL*) value
   eCSSUnit_Image        = 41,     // (nsCSSValue::Image*) value
   eCSSUnit_Gradient     = 42,     // (nsCSSValueGradient*) value
 
   eCSSUnit_Pair         = 50,     // (nsCSSValuePair*) pair of values
   eCSSUnit_Rect         = 51,     // (nsCSSRect*) rectangle (four values)
+  eCSSUnit_PairList     = 54,     // (nsCSSValuePairList*) list of value pairs
+  eCSSUnit_PairListDep  = 55,     // (nsCSSValuePairList*) same as PairList
+                                  //   but does not own the list
 
   eCSSUnit_Integer      = 70,     // (int) simple value
   eCSSUnit_Enumerated   = 71,     // (int) value has enumerated meaning
 
   eCSSUnit_EnumColor    = 80,     // (int) enumerated color (kColorKTable)
   eCSSUnit_Color        = 81,     // (nscolor) an RGBA value
 
   eCSSUnit_Percent      = 90,     // (float) 1.0 == 100%) value is percentage of something
@@ -186,16 +189,18 @@ enum nsCSSUnit {
   eCSSUnit_Milliseconds = 3001     // (float) 1/1000 second
 };
 
 struct nsCSSValueGradient;
 struct nsCSSValuePair;
 struct nsCSSValuePair_heap;
 struct nsCSSRect;
 struct nsCSSRect_heap;
+struct nsCSSValuePairList;
+struct nsCSSValuePairList_heap;
 
 class nsCSSValue {
 public:
   struct Array;
   friend struct Array;
 
   struct URL;
   friend struct URL;
@@ -342,21 +347,25 @@ public:
   }
 
   nsCSSValueGradient* GetGradientValue() const
   {
     NS_ASSERTION(mUnit == eCSSUnit_Gradient, "not a gradient value");
     return mValue.mGradient;
   }
 
-  inline nsCSSValuePair& GetPairValue(); // body below
-  inline const nsCSSValuePair& GetPairValue() const; // body below
+  // bodies of these are below
+  inline nsCSSValuePair& GetPairValue();
+  inline const nsCSSValuePair& GetPairValue() const;
 
-  inline nsCSSRect& GetRectValue(); // body below
-  inline const nsCSSRect& GetRectValue() const; // body below
+  inline nsCSSRect& GetRectValue();
+  inline const nsCSSRect& GetRectValue() const;
+
+  inline nsCSSValuePairList* GetPairListValue();
+  inline const nsCSSValuePairList* GetPairListValue() const;
 
   URL* GetURLStructValue() const
   {
     // Not allowing this for Image values, because if the caller takes
     // a ref to them they won't be able to delete them properly.
     NS_ASSERTION(mUnit == eCSSUnit_URL, "not a URL value");
     return mValue.mURL;
   }
@@ -393,29 +402,31 @@ public:
   void SetStringValue(const nsString& aValue, nsCSSUnit aUnit);
   void SetColorValue(nscolor aValue);
   void SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
   void SetURLValue(nsCSSValue::URL* aURI);
   void SetImageValue(nsCSSValue::Image* aImage);
   void SetGradientValue(nsCSSValueGradient* aGradient);
   void SetPairValue(const nsCSSValuePair* aPair);
   void SetPairValue(const nsCSSValue& xValue, const nsCSSValue& yValue);
+  void SetDependentPairListValue(nsCSSValuePairList* aList);
   void SetAutoValue();
   void SetInheritValue();
   void SetInitialValue();
   void SetNoneValue();
   void SetAllValue();
   void SetNormalValue();
   void SetSystemFontValue();
   void SetDummyValue();
   void SetDummyInheritValue();
 
   // These are a little different - they allocate storage for you and
   // return a handle.
   nsCSSRect& SetRectValue();
+  nsCSSValuePairList* SetPairListValue();
 
   void StartImageLoad(nsIDocument* aDocument) const;  // Only pretend const
 
   // Initializes as a function value with the specified function id.
   Array* InitFunction(nsCSSKeyword aFunctionId, PRUint32 aNumArgs);
   // Checks if this is a function value with the specified function id.
   PRBool EqualsFunction(nsCSSKeyword aFunctionId) const;
 
@@ -491,16 +502,18 @@ protected:
     nsStringBuffer* mString;
     nscolor    mColor;
     Array*     mArray;
     URL*       mURL;
     Image*     mImage;
     nsCSSValueGradient* mGradient;
     nsCSSValuePair_heap* mPair;
     nsCSSRect_heap* mRect;
+    nsCSSValuePairList_heap* mPairList;
+    nsCSSValuePairList* mPairListDependent;
   }         mValue;
 };
 
 struct nsCSSValue::Array {
 
   // return |Array| with reference count of zero
   static Array* Create(size_t aItemCount) {
     return new (aItemCount) Array(aItemCount);
@@ -798,16 +811,47 @@ struct nsCSSValuePairList {
 private:
   nsCSSValuePairList(const nsCSSValuePairList& aCopy) // makes a shallow copy
     : mXValue(aCopy.mXValue), mYValue(aCopy.mYValue), mNext(nsnull)
   {
     MOZ_COUNT_CTOR(nsCSSValuePairList);
   }
 };
 
+// nsCSSValuePairList_heap differs from nsCSSValuePairList only in being
+// refcounted.  It should not be necessary to use this class directly;
+// it's an implementation detail of nsCSSValue.
+struct nsCSSValuePairList_heap : public nsCSSValuePairList {
+  NS_INLINE_DECL_REFCOUNTING(nsCSSValuePairList_heap)
+};
+
+// This has to be here so that the relationship between nsCSSValuePairList
+// and nsCSSValuePairList_heap is visible.
+inline nsCSSValuePairList*
+nsCSSValue::GetPairListValue()
+{
+  if (mUnit == eCSSUnit_PairList)
+    return mValue.mPairList;
+  else {
+    NS_ABORT_IF_FALSE (mUnit == eCSSUnit_PairListDep, "not a pairlist value");
+    return mValue.mPairListDependent;
+  }
+}
+
+inline const nsCSSValuePairList*
+nsCSSValue::GetPairListValue() const
+{
+  if (mUnit == eCSSUnit_PairList)
+    return mValue.mPairList;
+  else {
+    NS_ABORT_IF_FALSE (mUnit == eCSSUnit_PairListDep, "not a pairlist value");
+    return mValue.mPairListDependent;
+  }
+}
+
 struct nsCSSValueGradientStop {
 public:
   nsCSSValueGradientStop();
   // needed to keep bloat logs happy when we use the nsTArray in nsCSSValueGradient
   nsCSSValueGradientStop(const nsCSSValueGradientStop& aOther);
   ~nsCSSValueGradientStop();
 
   nsCSSValue mLocation;
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1752,30 +1752,16 @@ nsRuleNode::CheckSpecifiedProperties(con
             ++specified;
             if (eCSSUnit_Inherit == valueList->mValue.GetUnit()) {
               ++inherited;
             }
           }
         }
         break;
 
-      case eCSSType_ValuePairList:
-        {
-          ++total;
-          const nsCSSValuePairList* valuePairList =
-              ValuePairListAtOffset(aRuleDataStruct, prop->offset);
-          if (valuePairList) {
-            ++specified;
-            if (eCSSUnit_Inherit == valuePairList->mXValue.GetUnit()) {
-              ++inherited;
-            }
-          }
-        }
-        break;
-
       default:
         NS_NOTREACHED("unknown type");
         break;
 
     }
 
 #if 0
   printf("CheckSpecifiedProperties: SID=%d total=%d spec=%d inh=%d.\n",
@@ -1925,18 +1911,16 @@ nsRuleNode::GetBackgroundData(nsStyleCon
   // and HasAuthorSpecifiedRules).
 
   const void *res = WalkRuleTree(eStyleStruct_Background, aContext, &ruleData, &colorData);
 
   // We are sharing with some style rule.  It really owns the data.
   colorData.mBackImage = nsnull;
   colorData.mBackRepeat = nsnull;
   colorData.mBackAttachment = nsnull;
-  colorData.mBackPosition = nsnull;
-  colorData.mBackSize = nsnull;
   colorData.mBackClip = nsnull;
   colorData.mBackOrigin = nsnull;
 
   return res;
 }
 
 const void*
 nsRuleNode::GetMarginData(nsStyleContext* aContext)
@@ -2029,31 +2013,28 @@ nsRuleNode::GetTableBorderData(nsStyleCo
 const void*
 nsRuleNode::GetContentData(nsStyleContext* aContext)
 {
   nsRuleDataContent contentData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Content), mPresContext, aContext);
   ruleData.mContentData = &contentData;
 
   const void* res = WalkRuleTree(eStyleStruct_Content, aContext, &ruleData, &contentData);
-  contentData.mCounterIncrement = contentData.mCounterReset = nsnull;
   contentData.mContent = nsnull; // We are sharing with some style rule.  It really owns the data.
   return res;
 }
 
 const void*
 nsRuleNode::GetQuotesData(nsStyleContext* aContext)
 {
   nsRuleDataContent contentData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Quotes), mPresContext, aContext);
   ruleData.mContentData = &contentData;
 
-  const void* res = WalkRuleTree(eStyleStruct_Quotes, aContext, &ruleData, &contentData);
-  contentData.mQuotes = nsnull; // We are sharing with some style rule.  It really owns the data.
-  return res;
+  return WalkRuleTree(eStyleStruct_Quotes, aContext, &ruleData, &contentData);
 }
 
 const void*
 nsRuleNode::GetXULData(nsStyleContext* aContext)
 {
   nsRuleDataXUL xulData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(XUL), mPresContext, aContext);
   ruleData.mXULData = &xulData;
@@ -2130,19 +2111,16 @@ UnsetPropertiesWithoutFlags(const nsStyl
 
     switch (prop->type) {
       case eCSSType_Value:
         ValueAtOffset(aRuleDataStruct, prop->offset).Reset();
         break;
       case eCSSType_ValueList:
         ValueListAtOffset(aRuleDataStruct, prop->offset) = nsnull;
         break;
-      case eCSSType_ValuePairList:
-        ValuePairListAtOffset(aRuleDataStruct, prop->offset) = nsnull;
-        break;
       default:
         NS_NOTREACHED("unknown type");
         break;
     }
   }
 }
 
 const void*
@@ -4784,16 +4762,88 @@ SetBackgroundList(nsStyleContext* aStyle
   }
 
   if (aItemCount > aMaxItemCount)
     aMaxItemCount = aItemCount;
 }
 
 template <class ComputedValueItem>
 static void
+SetBackgroundPairList(nsStyleContext* aStyleContext,
+                      const nsCSSValue& aValue,
+                      nsAutoTArray< nsStyleBackground::Layer, 1> &aLayers,
+                      const nsAutoTArray<nsStyleBackground::Layer, 1>
+                                                                 &aParentLayers,
+                      ComputedValueItem nsStyleBackground::Layer::*
+                                                                aResultLocation,
+                      ComputedValueItem aInitialValue,
+                      PRUint32 aParentItemCount,
+                      PRUint32& aItemCount,
+                      PRUint32& aMaxItemCount,
+                      PRBool& aRebuild,
+                      PRBool& aCanStoreInRuleTree)
+{
+  switch (aValue.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_Inherit:
+    aRebuild = PR_TRUE;
+    aCanStoreInRuleTree = PR_FALSE;
+    if (!aLayers.EnsureLengthAtLeast(aParentItemCount)) {
+      NS_WARNING("out of memory");
+      aParentItemCount = aLayers.Length();
+    }
+    aItemCount = aParentItemCount;
+    for (PRUint32 i = 0; i < aParentItemCount; ++i) {
+      aLayers[i].*aResultLocation = aParentLayers[i].*aResultLocation;
+    }
+    break;
+
+  case eCSSUnit_Initial:
+    aRebuild = PR_TRUE;
+    aItemCount = 1;
+    aLayers[0].*aResultLocation = aInitialValue;
+    break;
+
+  case eCSSUnit_PairList:
+  case eCSSUnit_PairListDep: {
+    aRebuild = PR_TRUE;
+    aItemCount = 0;
+    const nsCSSValuePairList* item = aValue.GetPairListValue();
+    do {
+      NS_ASSERTION(item->mXValue.GetUnit() != eCSSUnit_Inherit &&
+                   item->mXValue.GetUnit() != eCSSUnit_Initial &&
+                   item->mYValue.GetUnit() != eCSSUnit_Inherit &&
+                   item->mYValue.GetUnit() != eCSSUnit_Initial,
+                   "unexpected unit");
+      ++aItemCount;
+      if (!aLayers.EnsureLengthAtLeast(aItemCount)) {
+        NS_WARNING("out of memory");
+        --aItemCount;
+        break;
+      }
+      BackgroundItemComputer<nsCSSValuePairList, ComputedValueItem>
+        ::ComputeValue(aStyleContext, item,
+                       aLayers[aItemCount-1].*aResultLocation,
+                       aCanStoreInRuleTree);
+      item = item->mNext;
+    } while (item);
+  } break;
+
+  default:
+    NS_ABORT_IF_FALSE(false, "unexpected unit");
+  }
+
+  if (aItemCount > aMaxItemCount)
+    aMaxItemCount = aItemCount;
+}
+
+template <class ComputedValueItem>
+static void
 FillBackgroundList(nsAutoTArray< nsStyleBackground::Layer, 1> &aLayers,
     ComputedValueItem nsStyleBackground::Layer::* aResultLocation,
     PRUint32 aItemCount, PRUint32 aFillCount)
 {
   NS_PRECONDITION(aFillCount <= aLayers.Length(), "unexpected array length");
   for (PRUint32 sourceLayer = 0, destLayer = aItemCount;
        destLayer < aFillCount;
        ++sourceLayer, ++destLayer) {
@@ -4864,30 +4914,30 @@ nsRuleNode::ComputeBackgroundData(void* 
                     parentBG->mLayers, &nsStyleBackground::Layer::mOrigin,
                     PRUint8(NS_STYLE_BG_ORIGIN_PADDING), parentBG->mOriginCount,
                     bg->mOriginCount, maxItemCount, rebuild,
                     canStoreInRuleTree);
 
   // background-position: enum, length, percent (flags), inherit [pair list]
   nsStyleBackground::Position initialPosition;
   initialPosition.SetInitialValues();
-  SetBackgroundList(aContext, colorData.mBackPosition, bg->mLayers,
-                    parentBG->mLayers, &nsStyleBackground::Layer::mPosition,
-                    initialPosition, parentBG->mPositionCount,
-                    bg->mPositionCount, maxItemCount, rebuild,
-                    canStoreInRuleTree);
+  SetBackgroundPairList(aContext, colorData.mBackPosition, bg->mLayers,
+                        parentBG->mLayers, &nsStyleBackground::Layer::mPosition,
+                        initialPosition, parentBG->mPositionCount,
+                        bg->mPositionCount, maxItemCount, rebuild,
+                        canStoreInRuleTree);
 
   // background-size: enum, length, auto, inherit, initial [pair list]
   nsStyleBackground::Size initialSize;
   initialSize.SetInitialValues();
-  SetBackgroundList(aContext, colorData.mBackSize, bg->mLayers,
-                    parentBG->mLayers, &nsStyleBackground::Layer::mSize,
-                    initialSize, parentBG->mSizeCount,
-                    bg->mSizeCount, maxItemCount, rebuild,
-                    canStoreInRuleTree);
+  SetBackgroundPairList(aContext, colorData.mBackSize, bg->mLayers,
+                        parentBG->mLayers, &nsStyleBackground::Layer::mSize,
+                        initialSize, parentBG->mSizeCount,
+                        bg->mSizeCount, maxItemCount, rebuild,
+                        canStoreInRuleTree);
 
   if (rebuild) {
     // Delete any extra items.  We need to keep layers in which any
     // property was specified.
     bg->mLayers.TruncateLength(maxItemCount);
 
     PRUint32 fillCount = bg->mImageCount;
     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mImage,
@@ -5727,99 +5777,117 @@ nsRuleNode::ComputeContentData(void* aSt
           }
           contentValue = contentValue->mNext;
         }
       }
     }
   }
 
   // counter-increment: [string [int]]+, none, inherit
-  nsCSSValuePairList* ourIncrement = contentData.mCounterIncrement;
-  if (ourIncrement) {
-    if (eCSSUnit_None == ourIncrement->mXValue.GetUnit() ||
-        eCSSUnit_Initial == ourIncrement->mXValue.GetUnit()) {
-      content->AllocateCounterIncrements(0);
-    }
-    else if (eCSSUnit_Inherit == ourIncrement->mXValue.GetUnit()) {
-      canStoreInRuleTree = PR_FALSE;
-      count = parentContent->CounterIncrementCount();
-      if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
-        while (0 < count--) {
-          const nsStyleCounterData *data =
-            parentContent->GetCounterIncrementAt(count);
-          content->SetCounterIncrementAt(count, data->mCounter, data->mValue);
-        }
+  switch (contentData.mCounterIncrement.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_None:
+  case eCSSUnit_Initial:
+    content->AllocateCounterIncrements(0);
+    break;
+
+  case eCSSUnit_Inherit:
+    canStoreInRuleTree = PR_FALSE;
+    count = parentContent->CounterIncrementCount();
+    if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
+      while (0 < count--) {
+        const nsStyleCounterData *data =
+          parentContent->GetCounterIncrementAt(count);
+        content->SetCounterIncrementAt(count, data->mCounter, data->mValue);
       }
     }
-    else if (eCSSUnit_Ident == ourIncrement->mXValue.GetUnit()) {
-      count = 0;
-      while (ourIncrement) {
-        count++;
-        ourIncrement = ourIncrement->mNext;
+    break;
+
+  case eCSSUnit_PairList:
+  case eCSSUnit_PairListDep: {
+    const nsCSSValuePairList* ourIncrement =
+      contentData.mCounterIncrement.GetPairListValue();
+    NS_ABORT_IF_FALSE(ourIncrement->mXValue.GetUnit() == eCSSUnit_Ident,
+                      "unexpected value unit");
+    count = 0;
+    for (const nsCSSValuePairList* p = ourIncrement; p; p = p->mNext)
+      count++;
+    if (NS_FAILED(content->AllocateCounterIncrements(count))) {
+      break;
+    }
+
+    count = 0;
+    for (const nsCSSValuePairList* p = ourIncrement; p; p = p->mNext, count++) {
+      PRInt32 increment;
+      if (p->mYValue.GetUnit() == eCSSUnit_Integer) {
+        increment = p->mYValue.GetIntValue();
+      } else {
+        increment = 1;
       }
-      if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
-        count = 0;
-        ourIncrement = contentData.mCounterIncrement;
-        while (ourIncrement) {
-          PRInt32 increment;
-          if (eCSSUnit_Integer == ourIncrement->mYValue.GetUnit()) {
-            increment = ourIncrement->mYValue.GetIntValue();
-          }
-          else {
-            increment = 1;
-          }
-          ourIncrement->mXValue.GetStringValue(buffer);
-          content->SetCounterIncrementAt(count++, buffer, increment);
-          ourIncrement = ourIncrement->mNext;
-        }
+      p->mXValue.GetStringValue(buffer);
+      content->SetCounterIncrementAt(count, buffer, increment);
+    }
+  } break;
+
+  default:
+    NS_ABORT_IF_FALSE(false, "unexpected value unit");
+  }
+
+  // counter-reset: [string [int]]+, none, inherit
+  switch (contentData.mCounterReset.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_None:
+  case eCSSUnit_Initial:
+    content->AllocateCounterResets(0);
+    break;
+
+  case eCSSUnit_Inherit:
+    canStoreInRuleTree = PR_FALSE;
+    count = parentContent->CounterResetCount();
+    if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
+      while (0 < count--) {
+        const nsStyleCounterData *data =
+          parentContent->GetCounterResetAt(count);
+        content->SetCounterResetAt(count, data->mCounter, data->mValue);
       }
     }
-  }
-
-  // counter-reset: [string [int]]+, none, inherit
-  nsCSSValuePairList* ourReset = contentData.mCounterReset;
-  if (ourReset) {
-    if (eCSSUnit_None == ourReset->mXValue.GetUnit() ||
-        eCSSUnit_Initial == ourReset->mXValue.GetUnit()) {
-      content->AllocateCounterResets(0);
-    }
-    else if (eCSSUnit_Inherit == ourReset->mXValue.GetUnit()) {
-      canStoreInRuleTree = PR_FALSE;
-      count = parentContent->CounterResetCount();
-      if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
-        while (0 < count--) {
-          const nsStyleCounterData *data =
-            parentContent->GetCounterResetAt(count);
-          content->SetCounterResetAt(count, data->mCounter, data->mValue);
-        }
+    break;
+
+  case eCSSUnit_PairList:
+  case eCSSUnit_PairListDep: {
+    const nsCSSValuePairList* ourReset =
+      contentData.mCounterReset.GetPairListValue();
+    NS_ABORT_IF_FALSE(ourReset->mXValue.GetUnit() == eCSSUnit_Ident,
+                      "unexpected value unit");
+    count = 0;
+    for (const nsCSSValuePairList* p = ourReset; p; p = p->mNext)
+      count++;
+    if (NS_FAILED(content->AllocateCounterResets(count))) {
+      break;
+    }
+
+    count = 0;
+    for (const nsCSSValuePairList* p = ourReset; p; p = p->mNext, count++) {
+      PRInt32 reset;
+      if (p->mYValue.GetUnit() == eCSSUnit_Integer) {
+        reset = p->mYValue.GetIntValue();
+      } else {
+        reset = 0;
       }
-    }
-    else if (eCSSUnit_Ident == ourReset->mXValue.GetUnit()) {
-      count = 0;
-      while (ourReset) {
-        count++;
-        ourReset = ourReset->mNext;
-      }
-      if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
-        count = 0;
-        ourReset = contentData.mCounterReset;
-        while (ourReset) {
-          PRInt32 reset;
-          if (eCSSUnit_Integer == ourReset->mYValue.GetUnit()) {
-            reset = ourReset->mYValue.GetIntValue();
-          }
-          else {
-            reset = 0;
-          }
-          ourReset->mXValue.GetStringValue(buffer);
-          content->SetCounterResetAt(count++, buffer, reset);
-          ourReset = ourReset->mNext;
-        }
-      }
-    }
+      p->mXValue.GetStringValue(buffer);
+      content->SetCounterResetAt(count, buffer, reset);
+    }
+  } break;
+
+  default:
+    NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   // marker-offset: length, auto, inherit
   SetCoord(contentData.mMarkerOffset, content->mMarkerOffset, parentContent->mMarkerOffset,
            SETCOORD_LH | SETCOORD_AUTO | SETCOORD_INITIAL_AUTO |
              SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
 
@@ -5841,48 +5909,55 @@ nsRuleNode::ComputeQuotesData(void* aSta
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes,
                           Content, contentData)
 
   // quotes: inherit, initial, none, [string string]+
-  nsCSSValuePairList* ourQuotes = contentData.mQuotes;
-  if (ourQuotes) {
-    if (eCSSUnit_Inherit == ourQuotes->mXValue.GetUnit()) {
-      canStoreInRuleTree = PR_FALSE;
-      quotes->CopyFrom(*parentQuotes);
-    }
-    else if (eCSSUnit_Initial == ourQuotes->mXValue.GetUnit()) {
-      quotes->SetInitial();
-    }
-    else if (eCSSUnit_None == ourQuotes->mXValue.GetUnit()) {
-      quotes->AllocateQuotes(0);
-    }
-    else if (eCSSUnit_String == ourQuotes->mXValue.GetUnit()) {
-      nsAutoString  buffer;
-      nsAutoString  closeBuffer;
-      PRUint32 count = 0;
-
-      while (ourQuotes) {
-        count++;
-        ourQuotes = ourQuotes->mNext;
-      }
-      if (NS_SUCCEEDED(quotes->AllocateQuotes(count))) {
-        count = 0;
-        ourQuotes = contentData.mQuotes;
-        while (ourQuotes) {
-          ourQuotes->mXValue.GetStringValue(buffer);
-          ourQuotes->mYValue.GetStringValue(closeBuffer);
-          quotes->SetQuotesAt(count++, buffer, closeBuffer);
-          ourQuotes = ourQuotes->mNext;
-        }
-      }
-    }
+  switch (contentData.mQuotes.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+  case eCSSUnit_Inherit:
+    canStoreInRuleTree = PR_FALSE;
+    quotes->CopyFrom(*parentQuotes);
+    break;
+  case eCSSUnit_Initial:
+    quotes->SetInitial();
+    break;
+  case eCSSUnit_None:
+    quotes->AllocateQuotes(0);
+    break;
+  case eCSSUnit_PairList:
+  case eCSSUnit_PairListDep: {
+    const nsCSSValuePairList* ourQuotes = contentData.mQuotes.GetPairListValue();
+    nsAutoString buffer;
+    nsAutoString closeBuffer;
+    PRUint32 count = 0;
+
+    for (const nsCSSValuePairList* p = ourQuotes; p; p = p->mNext) {
+      count++;
+    }
+    if (NS_FAILED(quotes->AllocateQuotes(count))) {
+      break;
+    }
+    count = 0;
+    while (ourQuotes) {
+      NS_ABORT_IF_FALSE(ourQuotes->mXValue.GetUnit() == eCSSUnit_String &&
+                        ourQuotes->mYValue.GetUnit() == eCSSUnit_String,
+                        "improper list contents for quotes");
+      ourQuotes->mXValue.GetStringValue(buffer);
+      ourQuotes->mYValue.GetStringValue(closeBuffer);
+      quotes->SetQuotesAt(count++, buffer, closeBuffer);
+      ourQuotes = ourQuotes->mNext;
+    }
+  } break;
+  default:
+    NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   COMPUTE_END_INHERITED(Quotes, quotes)
 }
 
 const void*
 nsRuleNode::ComputeXULData(void* aStartStruct,
                            const nsRuleDataStruct& aData,
@@ -6653,20 +6728,18 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
         }
         // Do the same nulling out as in GetBorderData, GetBackgroundData
         // or GetPaddingData.
         // We are sharing with some style rule.  It really owns the data.
         marginData.mBoxShadow = nsnull;
         colorData.mBackImage = nsnull;
         colorData.mBackRepeat = nsnull;
         colorData.mBackAttachment = nsnull;
-        colorData.mBackPosition = nsnull;
         colorData.mBackClip = nsnull;
         colorData.mBackOrigin = nsnull;
-        colorData.mBackSize = nsnull;
 
         if (ruleData.mLevel == nsStyleSet::eAgentSheet ||
             ruleData.mLevel == nsStyleSet::eUserSheet) {
           // This is a rule whose effect we want to ignore, so if any of
           // the properties we care about were set, set them to the dummy
           // value that they'll never otherwise get.
           for (PRUint32 i = 0; i < nValues; ++i) {
             nsCSSUnit unit = values[i]->GetUnit();
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -1821,20 +1821,18 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
     case eUnit_Shadow:
     case eUnit_Transform:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValueList, "type mismatch");
       *static_cast<nsCSSValueList**>(aSpecifiedValue) =
         aComputedValue.GetCSSValueListValue();
       break;
     case eUnit_CSSValuePairList:
-      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                          eCSSType_ValuePairList, "type mismatch");
-      *static_cast<nsCSSValuePairList**>(aSpecifiedValue) =
-        aComputedValue.GetCSSValuePairListValue();
+      static_cast<nsCSSValue*>(aSpecifiedValue)->
+        SetDependentPairListValue(aComputedValue.GetCSSValuePairListValue());
       break;
     default:
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 PRBool
@@ -1847,28 +1845,24 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
   aSpecifiedValue.Truncate(); // Clear outparam, if it's not already empty
 
   if (aComputedValue.GetUnit() == eUnit_UnparsedString) {
     aComputedValue.GetStringValue(aSpecifiedValue);
     return PR_TRUE;
   }
   nsCSSValue val;
   nsCSSValueList* vl = nsnull;
-  nsCSSValuePairList* vpl = nsnull;
   void *storage;
   switch (nsCSSProps::kTypeTable[aProperty]) {
     case eCSSType_Value:
       storage = &val;
       break;
     case eCSSType_ValueList:
       storage = &vl;
       break;
-    case eCSSType_ValuePairList:
-      storage = &vpl;
-      break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected case");
       storage = nsnull;
       break;
   }
 
   if (!nsStyleAnimation::UncomputeValue(aProperty, aPresContext,
                                         aComputedValue, storage)) {
@@ -1877,19 +1871,16 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
 
   switch (nsCSSProps::kTypeTable[aProperty]) {
     case eCSSType_Value:
       val.AppendToString(aProperty, aSpecifiedValue);
       break;
     case eCSSType_ValueList:
       vl->AppendToString(aProperty, aSpecifiedValue);
       break;
-    case eCSSType_ValuePairList:
-      vpl->AppendToString(aProperty, aSpecifiedValue);
-      break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected case");
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 inline const void*
