# HG changeset patch
# User Kerem KAT <keremkat@gmail.com>
# Date 1488994723 -10800
#      Wed Mar 08 20:38:43 2017 +0300
# Node ID e149e4a275453b97b8daec3b9bc8566a95659ab7
# Parent  2baef2ffbaedb7354286726660ebd36e84b432f0
Bug 37468 - Implement CSSStyleRule.selectorText setter.

diff --git a/layout/style/CSSStyleSheet.h b/layout/style/CSSStyleSheet.h
--- a/layout/style/CSSStyleSheet.h
+++ b/layout/style/CSSStyleSheet.h
@@ -174,16 +174,22 @@ public:
   }
 
   // WebIDL CSSStyleSheet API
   // Can't be inline because we can't include ImportRule here.  And can't be
   // called GetOwnerRule because that would be ambiguous with the ImportRule
   // version.
   css::Rule* GetDOMOwnerRule() const final;
 
+  inline void AssertHasUniqueInner() const
+  {
+    MOZ_ASSERT(mInner->mSheets.Length() == 1,
+               "expected unique inner");
+  }
+
   void WillDirty();
   void DidDirty();
 
 private:
   CSSStyleSheet(const CSSStyleSheet& aCopy,
                 CSSStyleSheet* aParentToUse,
                 css::ImportRule* aOwnerRuleToUse,
                 nsIDocument* aDocumentToUse,
diff --git a/layout/style/StyleRule.cpp b/layout/style/StyleRule.cpp
--- a/layout/style/StyleRule.cpp
+++ b/layout/style/StyleRule.cpp
@@ -12,16 +12,17 @@
 #include "mozilla/css/StyleRule.h"
 
 #include "mozilla/DeclarationBlockInlines.h"
 #include "mozilla/StyleSheetInlines.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/css/GroupRule.h"
 #include "mozilla/css/Declaration.h"
 #include "mozilla/dom/CSSStyleRuleBinding.h"
+#include "nsCSSParser.h"
 #include "nsIDocument.h"
 #include "nsIAtom.h"
 #include "nsString.h"
 #include "nsStyleUtil.h"
 #include "nsDOMCSSDeclaration.h"
 #include "nsNameSpaceManager.h"
 #include "nsXMLNameSpaceMap.h"
 #include "nsCSSPseudoClasses.h"
@@ -1374,20 +1375,55 @@ StyleRule::GetSelectorText(nsAString& aS
     mSelector->ToString(aSelectorText, GetStyleSheet());
   else
     aSelectorText.Truncate();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 StyleRule::SetSelectorText(const nsAString& aSelectorText)
-{
-  // XXX TBI - get a parser and re-parse the selectors,
-  // XXX then need to re-compute the cascade
-  // XXX and dirty sheet
+{  
+  CSSStyleSheet *sheet = GetStyleSheet();
+
+  nsIDocument *doc = GetDocument();
+  RefPtr<css::Loader> loader;
+
+  if (doc) {
+    loader = doc->CSSLoader();
+  }
+
+  // NOTE:  Passing a null loader means that the parser is always in
+  // standards mode and never in quirks mode.
+  nsCSSParser css(loader, sheet);
+
+  // StyleRule lives inside of the Inner, it is unsafe to call WillDirty 
+  // if sheet does not already have a unique Inner.
+  sheet->AssertHasUniqueInner();
+  sheet->WillDirty();
+  
+  nsCSSSelectorList *selectorList = nullptr;
+  
+  nsresult result = css.ParseSelectorString(aSelectorText, sheet->GetSheetURI(), 0, &selectorList);
+  if (NS_FAILED(result)) {
+    // Ignore parsing errors and continue to use the previous value.
+    return NS_OK;
+  }
+
+  // Replace selector.
+  delete mSelector;
+  mSelector = selectorList;
+
+  sheet->DidDirty();
+
+  if (doc) {
+    mozAutoDocUpdate updateBatch(doc, UPDATE_STYLE, true);
+
+    doc->StyleRuleChanged(sheet, this);
+  }
+
   return NS_OK;
 }
 
 /* virtual */ size_t
 StyleRule::SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
 {
   size_t n = aMallocSizeOf(this);
   n += mSelector ? mSelector->SizeOfIncludingThis(aMallocSizeOf) : 0;
