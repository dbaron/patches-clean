From: Robert O'Callahan <roc@ocallahan.org>

Bug 531461. Avoid creating an nsDisplayTableBorderBackground if every part of the table is hidden. r=dbaron

diff --git a/layout/base/tests/scrolling_helper.html b/layout/base/tests/scrolling_helper.html
--- a/layout/base/tests/scrolling_helper.html
+++ b/layout/base/tests/scrolling_helper.html
@@ -109,16 +109,23 @@ iframe {
 <iframe class="testcase" id="testClipIFRAME"
         src="data:text/html,<body class='testcase' style='margin:0; height:300px; background:-moz-linear-gradient(top, red, black);'>">
 </iframe>
 
 <iframe class="testcase" id="testClipIFRAME2" style="top:-50px"
         src="data:text/html,<body class='testcase' style='margin:0; height:300px; background:-moz-linear-gradient(top, red, black);'>">
 </iframe>
 
+<div id="testHiddenTable" class="testcase">
+  <table style="position:fixed; visibility:hidden; width:200px; height:200px; background:blue;">
+    <tr><td>Hidden stuff</td></tr>
+  </table>
+  <div style="height:300px; background:-moz-linear-gradient(top, red, black);"></div>
+</div>
+
 <script>
 var testcases = document.querySelectorAll("div.testcase");
 var tests = [];
 var iframes = document.querySelectorAll("iframe.testcase");
 
 var currentTest = -1;
 
 function ok(a, msg) {
@@ -276,16 +283,23 @@ function testClipIFRAME(blitRegion, pain
 
 function testClipIFRAME2(blitRegion, paintRegion) {
   ok(blitRegion.equalsRegion(new Region([[0,50,200,180]])),
      "Should blit everything that was already visible: " + blitRegion.toString());
 //  ok(paintRegion.equalsRegion(new Region([[0,180,200,200]])),
 //     "Should repaint area that was scrolled into view: " + paintRegion.toString());
 }
 
+function testHiddenTable(blitRegion, paintRegion) {
+  ok(blitRegion.equalsRegion(new Region([[0,0,200,180]])),
+     "Should blit everything that was already visible: " + blitRegion.toString());
+  ok(paintRegion.equalsRegion(new Region([[0,180,200,200]])),
+     "Should repaint area that was scrolled into view: " + paintRegion.toString());
+}
+
 function clientRectToRect(cr)
 {
   return [cr.left, cr.top, cr.right, cr.bottom];
 }
 
 function regionForReason(requests, reason)
 {
   var rects = [];
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -497,16 +497,21 @@ nsTableCellFrame::BuildDisplayList(nsDis
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
   // the 'empty-cells' property has no effect on 'outline'
   nsresult rv = DisplayOutline(aBuilder, aLists);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  // Push a null 'current table item' so that descendant tables can't
+  // accidentally mess with our table
+  nsAutoPushCurrentTableItem pushTableItem;
+  pushTableItem.Push(aBuilder, nsnull);
+
   nsIFrame* kid = mFrames.FirstChild();
   NS_ASSERTION(kid && !kid->GetNextSibling(), "Table cells should have just one child");
   // The child's background will go in our BorderBackground() list.
   // This isn't a problem since it won't have a real background except for
   // event handling. We do not call BuildDisplayListForNonBlockChildren
   // because that/ would put the child's background in the Content() list
   // which isn't right (e.g., would end up on top of our child floats for
   // event handling).
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -1263,60 +1263,92 @@ nsTableFrame::DisplayGenericTablePart(ns
   PRBool sortEventBackgrounds = aDisplayItem && aBuilder->IsForEventDelivery();
   nsDisplayListCollection separatedCollection;
   const nsDisplayListSet* lists = sortEventBackgrounds ? &separatedCollection : &aLists;
   
   nsAutoPushCurrentTableItem pushTableItem;
   if (aDisplayItem) {
     pushTableItem.Push(aBuilder, aDisplayItem);
   }
-  nsDisplayTableItem* currentItem = aBuilder->GetCurrentTableItem();
-  NS_ASSERTION(currentItem, "No current table item!");
-  currentItem->UpdateForFrameBackground(aFrame);
-  
-  // Paint the outset box-shadows for the table frames
-  PRBool hasBoxShadow = aFrame->IsVisibleForPainting(aBuilder) &&
-                        aFrame->GetStyleBorder()->mBoxShadow;
-  if (hasBoxShadow) {
-    nsDisplayItem* item = new (aBuilder) nsDisplayBoxShadowOuter(aFrame);
-    nsresult rv = lists->BorderBackground()->AppendNewToTop(item);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  // Create dedicated background display items per-frame when we're
-  // handling events.
-  // XXX how to handle collapsed borders?
-  if (aBuilder->IsForEventDelivery() &&
-      aFrame->IsVisibleForPainting(aBuilder)) {
-    nsresult rv = lists->BorderBackground()->AppendNewToTop(new (aBuilder)
-        nsDisplayBackground(aFrame));
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  // Paint the inset box-shadows for the table frames
-  if (hasBoxShadow) {
-    nsDisplayItem* item = new (aBuilder) nsDisplayBoxShadowInner(aFrame);
-    nsresult rv = lists->BorderBackground()->AppendNewToTop(item);
-    NS_ENSURE_SUCCESS(rv, rv);
+
+  if (aFrame->IsVisibleForPainting(aBuilder)) {
+    nsDisplayTableItem* currentItem = aBuilder->GetCurrentTableItem();
+    NS_ASSERTION(currentItem, "No current table item!");
+    currentItem->UpdateForFrameBackground(aFrame);
+  
+    // Paint the outset box-shadows for the table frames
+    PRBool hasBoxShadow = aFrame->GetStyleBorder()->mBoxShadow != nsnull;
+    if (hasBoxShadow) {
+      nsDisplayItem* item = new (aBuilder) nsDisplayBoxShadowOuter(aFrame);
+      nsresult rv = lists->BorderBackground()->AppendNewToTop(item);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    // Create dedicated background display items per-frame when we're
+    // handling events.
+    // XXX how to handle collapsed borders?
+    if (aBuilder->IsForEventDelivery()) {
+      nsresult rv = lists->BorderBackground()->AppendNewToTop(new (aBuilder)
+          nsDisplayBackground(aFrame));
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    // Paint the inset box-shadows for the table frames
+    if (hasBoxShadow) {
+      nsDisplayItem* item = new (aBuilder) nsDisplayBoxShadowInner(aFrame);
+      nsresult rv = lists->BorderBackground()->AppendNewToTop(item);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
   }
 
   nsresult rv = aTraversal(aBuilder, aFrame, aDirtyRect, *lists);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (sortEventBackgrounds) {
     // Ensure that the table frame event background goes before the
     // table rowgroups event backgrounds, before the table row event backgrounds,
     // before everything else (cells and their blocks)
     separatedCollection.BorderBackground()->Sort(aBuilder, CompareByTablePartRank, nsnull);
     separatedCollection.MoveTo(aLists);
   }
   
   return aFrame->DisplayOutline(aBuilder, aLists);
 }
 
+#ifdef DEBUG
+static PRBool
+IsFrameAllowedInTable(nsIAtom* aType)
+{
+  return IS_TABLE_CELL(aType) ||
+         nsGkAtoms::tableRowFrame == aType ||
+         nsGkAtoms::tableRowGroupFrame == aType ||
+         nsGkAtoms::scrollFrame == aType ||
+         nsGkAtoms::tableFrame == aType ||
+         nsGkAtoms::tableColFrame == aType ||
+         nsGkAtoms::tableColGroupFrame == aType;
+}
+#endif
+
+static PRBool
+AnyTablePartVisible(nsIFrame* aFrame)
+{
+  NS_ASSERTION(IsFrameAllowedInTable(aFrame->GetType()), "unexpected frame type");
+  if (aFrame->GetStyleVisibility()->IsVisible())
+    return PR_TRUE;
+  nsTableCellFrame *cellFrame = do_QueryFrame(aFrame);
+  if (cellFrame)
+    return PR_FALSE;
+  nsFrameList children = aFrame->GetChildList(nsnull);
+  for (nsIFrame* f = children.FirstChild(); f; f = f->GetNextSibling()) {
+    if (AnyTablePartVisible(f))
+      return PR_TRUE;
+  }
+  return PR_FALSE;
+}
+
 // table paint code is concerned primarily with borders and bg color
 // SEC: TODO: adjust the rect for captions 
 NS_IMETHODIMP
 nsTableFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                const nsRect&           aDirtyRect,
                                const nsDisplayListSet& aLists)
 {
   if (!IsVisibleInSelection(aBuilder))
@@ -1330,24 +1362,26 @@ nsTableFrame::BuildDisplayList(nsDisplay
     // in its own display item, so do that to take advantage of
     // opacity and visibility optimizations
     if (deflate.IsZero()) {
       nsresult rv = DisplayBackgroundUnconditional(aBuilder, aLists, PR_FALSE);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
-  // This background is created regardless of whether this frame is
-  // visible or not. Visibility decisions are delegated to the
-  // table background painter. This handles borders and backgrounds
-  // for the table.
-  nsDisplayTableItem* item = new (aBuilder) nsDisplayTableBorderBackground(this);
-  nsresult rv = aLists.BorderBackground()->AppendNewToTop(item);
-  NS_ENSURE_SUCCESS(rv, rv);
-  
+  nsDisplayTableItem* item = nsnull;
+  // This background is created if any of the table parts are visible.
+  // Specific visibility decisions are delegated to the table background
+  // painter, which handles borders and backgrounds for the table.
+  if (AnyTablePartVisible(this)) {
+    item = new (aBuilder) nsDisplayTableBorderBackground(this);
+    nsresult rv = aLists.BorderBackground()->AppendNewToTop(item);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
   return DisplayGenericTablePart(aBuilder, this, aDirtyRect, aLists, item);
 }
 
 nsMargin
 nsTableFrame::GetDeflationForBackground(nsPresContext* aPresContext) const
 {
   if (eCompatibility_NavQuirks != aPresContext->CompatibilityMode() ||
       !IsBorderCollapse())
@@ -1641,22 +1675,17 @@ nsTableFrame::CheckRequestSpecialHeightR
 // change the height of row groups, rows, cells in DistributeHeightToRows after. 
 // And the row group can change the height of rows, cells in CalculateRowHeights.
 void
 nsTableFrame::RequestSpecialHeightReflow(const nsHTMLReflowState& aReflowState)
 {
   // notify the frame and its ancestors of the special reflow, stopping at the containing table
   for (const nsHTMLReflowState* rs = &aReflowState; rs && rs->frame; rs = rs->parentReflowState) {
     nsIAtom* frameType = rs->frame->GetType();
-    NS_ASSERTION(IS_TABLE_CELL(frameType) ||
-                 nsGkAtoms::tableRowFrame == frameType ||
-                 nsGkAtoms::tableRowGroupFrame == frameType ||
-                 nsGkAtoms::scrollFrame == frameType ||
-                 nsGkAtoms::tableFrame == frameType,
-                 "unexpected frame type");
+    NS_ASSERTION(IsFrameAllowedInTable(frameType), "unexpected frame type");
                  
     rs->frame->AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
     if (nsGkAtoms::tableFrame == frameType) {
       NS_ASSERTION(rs != &aReflowState,
                    "should not request special height reflow for table");
       // always stop when we reach a table
       break;
     }
