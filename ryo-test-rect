From: Ryo Kawaguchi <rkawaguchi@mozilla.com>

Add tests to TestRect and fix TestColorNames.  (Bug 113577)  r=roc

diff --git a/gfx/tests/Makefile.in b/gfx/tests/Makefile.in
--- a/gfx/tests/Makefile.in
+++ b/gfx/tests/Makefile.in
@@ -46,29 +46,26 @@ MODULE		= gfx
 
 MOZILLA_INTERNAL_API = 1
 
 REQUIRES	= xpcom \
 		  string \
 		  gfx \
 		  $(NULL)
 
-CPPSRCS		= \
+CPP_UNIT_TESTS	= \
 		TestColorNames.cpp \
 		TestRect.cpp \
 		$(NULL)
 
-SIMPLE_PROGRAMS	= $(CPPSRCS:.cpp=$(BIN_SUFFIX))
-
 LIBS		= \
 		$(call EXPAND_LIBNAME_PATH,gkgfx,../src) \
 		$(XPCOM_LIBS) \
 		$(MOZ_JS_LIBS) \
 		$(TK_LIBS) \
-		$(NSPR_LIBS) \
 		$(NULL)
 
 XPCSHELL_TESTS = unit
 
 include $(topsrcdir)/config/rules.mk
 
 INCLUDES	+= -I$(srcdir)/../src
 
diff --git a/gfx/tests/TestColorNames.cpp b/gfx/tests/TestColorNames.cpp
--- a/gfx/tests/TestColorNames.cpp
+++ b/gfx/tests/TestColorNames.cpp
@@ -30,19 +30,18 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-// No output means test passed.
+#include "TestHarness.h"
 
-#include <stdio.h>
 #include <string.h>
 #include "nsColor.h"
 #include "nsColorNames.h"
 #include "prprf.h"
 #include "nsString.h"
 
 // define an array of all color names
 #define GFX_COLOR(_name, _value) #_name,
@@ -64,75 +63,86 @@ static const char* kJunkNames[] = {
   "123",
   "backgroundz",
   "zzzzzz",
   "#@$&@#*@*$@$#"
 };
 
 int main(int argc, char** argv)
 {
+  ScopedXPCOM xpcom("TestColorNames");
+  if (xpcom.failed())
+    return -1;
+
   nscolor rgb;
   int rv = 0;
 
   // Everything appears to assert if we don't do this first...
   nsColorNames::AddRefTable();
 
   // First make sure we can find all of the tags that are supposed to
   // be in the table. Futz with the case to make sure any case will
   // work
     
-  for (int index = 0 ; index < NS_ARRAY_LENGTH(kColorNames); index++) {
+  for (PRUint32 index = 0 ; index < NS_ARRAY_LENGTH(kColorNames); index++) {
     // Lookup color by name and make sure it has the right id
     nsCString tagName(kColorNames[index]);
 
     // Check that color lookup by name gets the right rgb value
     if (!NS_ColorNameToRGB(NS_ConvertASCIItoUTF16(tagName), &rgb)) {
-      printf("bug: can't find '%s'\n", tagName.get());
+      fail("can't find '%s'", tagName.get());
       rv = -1;
     }
     if (rgb != kColors[index]) {
-      printf("bug: name='%s' ColorNameToRGB=%x kColors[%d]=%08x\n",
-             tagName.get(), rgb, index, kColors[index]);
+      fail("name='%s' ColorNameToRGB=%x kColors[%d]=%08x",
+           tagName.get(), rgb, index, kColors[index]);
       rv = -1;
     }
 
     // fiddle with the case to make sure we can still find it
     tagName.SetCharAt(tagName.CharAt(0) - 32, 0);
     if (!NS_ColorNameToRGB(NS_ConvertASCIItoUTF16(tagName), &rgb)) {
-      printf("bug: can't find '%s'\n", tagName.get());
+      fail("can't find '%s'", tagName.get());
       rv = -1;
     }
     if (rgb != kColors[index]) {
-      printf("bug: name='%s' ColorNameToRGB=%x kColors[%d]=%08x\n",
-             tagName.get(), rgb, index, kColors[index]);
+      fail("name='%s' ColorNameToRGB=%x kColors[%d]=%08x",
+           tagName.get(), rgb, index, kColors[index]);
       rv = -1;
     }
 
     // Check that parsing an RGB value in hex gets the right values
     PRUint8 r = NS_GET_R(rgb);
     PRUint8 g = NS_GET_G(rgb);
     PRUint8 b = NS_GET_B(rgb);
+    PRUint8 a = NS_GET_A(rgb);
+    if (a != PR_UINT8_MAX) {
+      // NS_HexToRGB() can not handle a color with alpha channel
+      rgb = NS_RGB(r, g, b);
+    }
     char cbuf[50];
     PR_snprintf(cbuf, sizeof(cbuf), "%02x%02x%02x", r, g, b);
     nscolor hexrgb;
     if (!NS_HexToRGB(NS_ConvertASCIItoUTF16(cbuf), &hexrgb)) {
-      printf("bug: hex conversion to color of '%s' failed\n", cbuf);
+      fail("hex conversion to color of '%s'", cbuf);
       rv = -1;
     }
     if (hexrgb != rgb) {
-      printf("bug: rgb=%x hexrgb=%x\n", rgb, hexrgb);
+      fail("rgb=%x hexrgb=%x", rgb, hexrgb);
       rv = -1;
     }
   }
 
   // Now make sure we don't find some garbage
-  for (int i = 0; i < NS_ARRAY_LENGTH(kJunkNames); i++) {
+  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(kJunkNames); i++) {
     nsCString tag(kJunkNames[i]);
     if (NS_ColorNameToRGB(NS_ConvertASCIItoUTF16(tag), &rgb)) {
-      printf("bug: found '%s'\n", kJunkNames[i] ? kJunkNames[i] : "(null)");
+      fail("found '%s'", kJunkNames[i] ? kJunkNames[i] : "(null)");
       rv = -1;
     }
   }
 
   nsColorNames::ReleaseTable();
 
+  if (rv == 0)
+    passed("TestColorNames");
   return rv;
 }
diff --git a/gfx/tests/TestRect.cpp b/gfx/tests/TestRect.cpp
--- a/gfx/tests/TestRect.cpp
+++ b/gfx/tests/TestRect.cpp
@@ -30,421 +30,504 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+#include "TestHarness.h"
+
 #include "nsRect.h"
-#include <stdio.h>
 #ifdef XP_WIN
 #include <windows.h>
 #endif
 
+template <class RectType>
 static PRBool
 TestConstructors()
 {
   // Create a rectangle
-  nsRect  rect1(10, 20, 30, 40);
+  RectType  rect1(10, 20, 30, 40);
 
   // Make sure the rectangle was properly initialized
   if ((rect1.x != 10) || (rect1.y != 20) ||
       (rect1.width != 30) || (rect1.height != 40)) {
-    printf("rect initialization failed!\n");
+    fail("[1] Make sure the rectangle was properly initialized with constructor");
     return PR_FALSE;
   }
 
   // Create a second rect using the copy constructor
-  nsRect  rect2(rect1);
+  RectType  rect2(rect1);
 
   // Make sure the rectangle was properly initialized
   if ((rect2.x != rect1.x) || (rect2.y != rect1.y) ||
       (rect2.width != rect1.width) || (rect2.height != rect1.height)) {
-    printf("rect copy constructor failed!\n");
+    fail("[2] Make sure the rectangle was properly initialized with copy constructor");
     return PR_FALSE;
   }
 
+  passed("TestConstructors");
   return PR_TRUE;
 }
 
+template <class RectType>
 static PRBool
 TestEqualityOperator()
 {
-  nsRect  rect1(10, 20, 30, 40);
-  nsRect  rect2(rect1);
+  RectType  rect1(10, 20, 30, 40);
+  RectType  rect2(rect1);
 
   // Test the equality operator
   if (!(rect1 == rect2)) {
-    printf("rect equality operator failed!\n");
+    fail("[1] Test the equality operator");
     return PR_FALSE;
   }
 
   // Test the inequality operator
   if (rect1 != rect2) {
-    printf("rect inequality operator failed!\n");
+    fail("[2] Test the inequality operator");
     return PR_FALSE;
   }
 
   // Make sure that two empty rects are equal
   rect1.Empty();
   rect2.Empty();
   if (!(rect1 == rect2)) {
-    printf("rect equality operator failed for empty rects!\n");
+    fail("[3] Make sure that two empty rects are equal");
     return PR_FALSE;
   }
 
+  passed("TestEqualityOperator");
   return PR_TRUE;
 }
 
+template <class RectType>
 static PRBool
 TestContainment()
 {
-  nsRect  rect1(10, 10, 50, 50);
+  RectType  rect1(10, 10, 50, 50);
 
   // Test the point containment methods
   //
 
   // Basic test of a point in the middle of the rect
   if (!rect1.Contains(rect1.x + rect1.width/2, rect1.y + rect1.height/2)) {
-    printf("point containment test #1 failed!\n");
+    fail("[1] Basic test of a point in the middle of the rect");
     return PR_FALSE;
   }
 
   // Test against a point at the left/top edges
   if (!rect1.Contains(rect1.x, rect1.y)) {
-    printf("point containment test #2 failed!\n");
+    fail("[2] Test against a point at the left/top edges");
     return PR_FALSE;
   }
 
   // Test against a point at the right/bottom extents
   if (rect1.Contains(rect1.XMost(), rect1.YMost())) {
-    printf("point containment test #3 failed!\n");
+    fail("[3] Test against a point at the right/bottom extents");
     return PR_FALSE;
   }
 
   // Test the rect containment methods
   //
-  nsRect  rect2(rect1);
+  RectType  rect2(rect1);
 
   // Test against a rect that's the same as rect1
   if (!rect1.Contains(rect2)) {
-    printf("rect containment test #1 failed!\n");
+    fail("[4] Test against a rect that's the same as rect1");
     return PR_FALSE;
   }
 
   // Test against a rect whose left edge (only) is outside of rect1
   rect2.x--;
   if (rect1.Contains(rect2)) {
-    printf("rect containment test #2 failed!\n");
+    fail("[5] Test against a rect whose left edge (only) is outside of rect1");
     return PR_FALSE;
   }
   rect2.x++;
 
   // Test against a rect whose top edge (only) is outside of rect1
   rect2.y--;
   if (rect1.Contains(rect2)) {
-    printf("rect containment test #3 failed!\n");
+    fail("[6] Test against a rect whose top edge (only) is outside of rect1");
     return PR_FALSE;
   }
   rect2.y++;
 
   // Test against a rect whose right edge (only) is outside of rect1
   rect2.x++;
   if (rect1.Contains(rect2)) {
-    printf("rect containment test #2 failed!\n");
+    fail("[7] Test against a rect whose right edge (only) is outside of rect1");
     return PR_FALSE;
   }
   rect2.x--;
 
   // Test against a rect whose bottom edge (only) is outside of rect1
   rect2.y++;
   if (rect1.Contains(rect2)) {
-    printf("rect containment test #3 failed!\n");
+    fail("[8] Test against a rect whose bottom edge (only) is outside of rect1");
     return PR_FALSE;
   }
   rect2.y--;
 
+  passed("TestContainment");
   return PR_TRUE;
 }
 
 // Test the method that returns a boolean result but doesn't return a
 // a rectangle
+template <class RectType>
 static PRBool
 TestIntersects()
 {
-  nsRect  rect1(10, 10, 50, 50);
-  nsRect  rect2(rect1);
+  RectType  rect1(10, 10, 50, 50);
+  RectType  rect2(rect1);
 
   // Test against a rect that's the same as rect1
   if (!rect1.Intersects(rect2)) {
-    printf("rect intersects test #1 failed!\n");
+    fail("[1] Test against a rect that's the same as rect1");
     return PR_FALSE;
   }
 
   // Test against a rect that's enclosed by rect1
-  rect2.Deflate(1, 1);
+  rect2.Inflate(-1, -1);
   if (!rect1.Contains(rect2) || !rect1.Intersects(rect2)) {
-    printf("rect intersects test #2 failed!\n");
+    fail("[2] Test against a rect that's enclosed by rect1");
     return PR_FALSE;
   }
   rect2.Inflate(1, 1);
 
   // Make sure inflate and deflate worked correctly
   if (rect1 != rect2) {
-    printf("rect inflate or deflate failed!\n");
+    fail("[3] Make sure inflate and deflate worked correctly");
     return PR_FALSE;
   }
 
   // Test against a rect that overlaps the left edge of rect1
   rect2.x--;
   if (!rect1.Intersects(rect2)) {
-    printf("rect containment test #3 failed!\n");
+    fail("[4] Test against a rect that overlaps the left edge of rect1");
     return PR_FALSE;
   }
   rect2.x++;
 
   // Test against a rect that's outside of rect1 on the left
   rect2.x -= rect2.width;
   if (rect1.Intersects(rect2)) {
-    printf("rect containment test #4 failed!\n");
+    fail("[5] Test against a rect that's outside of rect1 on the left");
     return PR_FALSE;
   }
   rect2.x += rect2.width;
 
   // Test against a rect that overlaps the top edge of rect1
   rect2.y--;
   if (!rect1.Intersects(rect2)) {
-    printf("rect containment test #5 failed!\n");
+    fail("[6] Test against a rect that overlaps the top edge of rect1");
     return PR_FALSE;
   }
   rect2.y++;
 
   // Test against a rect that's outside of rect1 on the top
   rect2.y -= rect2.height;
   if (rect1.Intersects(rect2)) {
-    printf("rect containment test #6 failed!\n");
+    fail("[7] Test against a rect that's outside of rect1 on the top");
     return PR_FALSE;
   }
   rect2.y += rect2.height;
 
   // Test against a rect that overlaps the right edge of rect1
   rect2.x++;
   if (!rect1.Intersects(rect2)) {
-    printf("rect containment test #7 failed!\n");
+    fail("[8] Test against a rect that overlaps the right edge of rect1");
     return PR_FALSE;
   }
   rect2.x--;
 
   // Test against a rect that's outside of rect1 on the right
   rect2.x += rect2.width;
   if (rect1.Intersects(rect2)) {
-    printf("rect containment test #8 failed!\n");
+    fail("[9] Test against a rect that's outside of rect1 on the right");
     return PR_FALSE;
   }
   rect2.x -= rect2.width;
 
   // Test against a rect that overlaps the bottom edge of rect1
   rect2.y++;
   if (!rect1.Intersects(rect2)) {
-    printf("rect containment test #9 failed!\n");
+    fail("[10] Test against a rect that overlaps the bottom edge of rect1");
     return PR_FALSE;
   }
   rect2.y--;
 
   // Test against a rect that's outside of rect1 on the bottom
   rect2.y += rect2.height;
   if (rect1.Intersects(rect2)) {
-    printf("rect containment test #10 failed!\n");
+    fail("[11] Test against a rect that's outside of rect1 on the bottom");
     return PR_FALSE;
   }
   rect2.y -= rect2.height;
 
+  passed("TestIntersects");
   return PR_TRUE;
 }
 
 // Test the method that returns a boolean result and an intersection rect
+template <class RectType>
 static PRBool
 TestIntersection()
 {
-  nsRect  rect1(10, 10, 50, 50);
-  nsRect  rect2(rect1);
-  nsRect  dest;
+  RectType  rect1(10, 10, 50, 50);
+  RectType  rect2(rect1);
+  RectType  dest;
 
   // Test against a rect that's the same as rect1
   if (!dest.IntersectRect(rect1, rect2) || (dest != rect1)) {
-    printf("rect intersection test #1 failed!\n");
+    fail("[1] Test against a rect that's the same as rect1");
     return PR_FALSE;
   }
 
   // Test against a rect that's enclosed by rect1
-  rect2.Deflate(1, 1);
+  rect2.Inflate(-1, -1);
   if (!dest.IntersectRect(rect1, rect2) || (dest != rect2)) {
-    printf("rect intersection test #2 failed!\n");
+    fail("[2] Test against a rect that's enclosed by rect1");
     return PR_FALSE;
   }
   rect2.Inflate(1, 1);
 
   // Test against a rect that overlaps the left edge of rect1
   rect2.x--;
   if (!dest.IntersectRect(rect1, rect2) ||
-     (dest != nsRect(rect1.x, rect1.y, rect1.width - 1, rect1.height))) {
-    printf("rect intersection test #3 failed!\n");
+     (dest != RectType(rect1.x, rect1.y, rect1.width - 1, rect1.height))) {
+    fail("[3] Test against a rect that overlaps the left edge of rect1");
     return PR_FALSE;
   }
   rect2.x++;
 
   // Test against a rect that's outside of rect1 on the left
   rect2.x -= rect2.width;
   if (dest.IntersectRect(rect1, rect2)) {
-    printf("rect intersection test #4 failed!\n");
+    fail("[4] Test against a rect that's outside of rect1 on the left");
     return PR_FALSE;
   }
   // Make sure an empty rect is returned
   if (!dest.IsEmpty()) {
-    printf("rect intersection test #4 no empty rect!\n");
+    fail("[4] Make sure an empty rect is returned");
     return PR_FALSE;
   }
   rect2.x += rect2.width;
 
   // Test against a rect that overlaps the top edge of rect1
   rect2.y--;
   if (!dest.IntersectRect(rect1, rect2) ||
-     (dest != nsRect(rect1.x, rect1.y, rect1.width, rect1.height - 1))) {
-    printf("rect intersection test #5 failed!\n");
+     (dest != RectType(rect1.x, rect1.y, rect1.width, rect1.height - 1))) {
+    fail("[5] Test against a rect that overlaps the top edge of rect1");
     return PR_FALSE;
   }
   rect2.y++;
 
   // Test against a rect that's outside of rect1 on the top
   rect2.y -= rect2.height;
   if (dest.IntersectRect(rect1, rect2)) {
-    printf("rect intersection test #6 failed!\n");
+    fail("[6] Test against a rect that's outside of rect1 on the top");
     return PR_FALSE;
   }
   // Make sure an empty rect is returned
   if (!dest.IsEmpty()) {
-    printf("rect intersection test #6 no empty rect!\n");
+    fail("[6] Make sure an empty rect is returned");
     return PR_FALSE;
   }
   rect2.y += rect2.height;
 
   // Test against a rect that overlaps the right edge of rect1
   rect2.x++;
   if (!dest.IntersectRect(rect1, rect2) ||
-     (dest != nsRect(rect1.x + 1, rect1.y, rect1.width - 1, rect1.height))) {
-    printf("rect intersection test #7 failed!\n");
+     (dest != RectType(rect1.x + 1, rect1.y, rect1.width - 1, rect1.height))) {
+    fail("[7] Test against a rect that overlaps the right edge of rect1");
     return PR_FALSE;
   }
   rect2.x--;
 
   // Test against a rect that's outside of rect1 on the right
   rect2.x += rect2.width;
   if (dest.IntersectRect(rect1, rect2)) {
-    printf("rect intersection test #8 failed!\n");
+    fail("[8] Test against a rect that's outside of rect1 on the right");
     return PR_FALSE;
   }
   // Make sure an empty rect is returned
   if (!dest.IsEmpty()) {
-    printf("rect intersection test #8 no empty rect!\n");
+    fail("[8] Make sure an empty rect is returned");
     return PR_FALSE;
   }
   rect2.x -= rect2.width;
 
   // Test against a rect that overlaps the bottom edge of rect1
   rect2.y++;
   if (!dest.IntersectRect(rect1, rect2) ||
-     (dest != nsRect(rect1.x, rect1.y + 1, rect1.width, rect1.height - 1))) {
-    printf("rect intersection test #9 failed!\n");
+     (dest != RectType(rect1.x, rect1.y + 1, rect1.width, rect1.height - 1))) {
+    fail("[9] Test against a rect that overlaps the bottom edge of rect1");
     return PR_FALSE;
   }
   rect2.y--;
 
   // Test against a rect that's outside of rect1 on the bottom
   rect2.y += rect2.height;
   if (dest.IntersectRect(rect1, rect2)) {
-    printf("rect intersection test #10 failed!\n");
+    fail("[10] Test against a rect that's outside of rect1 on the bottom");
     return PR_FALSE;
   }
   // Make sure an empty rect is returned
   if (!dest.IsEmpty()) {
-    printf("rect intersection test #10 no empty rect!\n");
+    fail("[10] Make sure an empty rect is returned");
     return PR_FALSE;
   }
   rect2.y -= rect2.height;
 
+  // Test against a rect with zero width or height
+  rect1.SetRect(100, 100, 100, 100);
+  rect2.SetRect(150, 100, 0, 100);
+  if (dest.IntersectRect(rect1, rect2) || !dest.IsEmpty()) {
+    fail("[11] Intersection of rects with zero width or height should be empty");
+    return PR_FALSE;
+  }
+
+  // Tests against a rect with negative width or height
+  //
+
+  // Test against a rect with negative width
+  rect1.SetRect(100, 100, 100, 100);
+  rect2.SetRect(100, 100, -100, 100);
+  if (dest.IntersectRect(rect1, rect2) || !dest.IsEmpty()) {
+    fail("[12] Intersection of rects with negative width or height should be empty");
+    return PR_FALSE;
+  }
+
+  // Those two rects exactly overlap in some way...
+  // but we still want to return an empty rect
+  rect1.SetRect(100, 100, 100, 100);
+  rect2.SetRect(200, 200, -100, -100);
+  if (dest.IntersectRect(rect1, rect2) || !dest.IsEmpty()) {
+    fail("[13] Intersection of rects with negative width or height should be empty");
+    return PR_FALSE;
+  }
+
+  // Test against two identical rects with negative height
+  rect1.SetRect(100, 100, 100, -100);
+  rect2.SetRect(100, 100, 100, -100);
+  if (dest.IntersectRect(rect1, rect2) || !dest.IsEmpty()) {
+    fail("[14] Intersection of rects with negative width or height should be empty");
+    return PR_FALSE;
+  }
+
+  passed("TestIntersection");
   return PR_TRUE;
 }
 
+template <class RectType>
 static PRBool
 TestUnion()
 {
-  nsRect  rect1;
-  nsRect  rect2(10, 10, 50, 50);
-  nsRect  dest;
+  RectType  rect1;
+  RectType  rect2(10, 10, 50, 50);
+  RectType  dest;
 
   // Check the case where the receiver is an empty rect
   rect1.Empty();
   if (!dest.UnionRect(rect1, rect2) || (dest != rect2)) {
-    printf("rect union test #1 failed!\n");
+    fail("[1] Check the case where the receiver is an empty rect");
     return PR_FALSE;
   }
 
   // Check the case where the source rect is an empty rect
   rect1 = rect2;
   rect2.Empty();
   if (!dest.UnionRect(rect1, rect2) || (dest != rect1)) {
-    printf("rect union test #2 failed!\n");
+    fail("[2] Check the case where the source rect is an empty rect");
     return PR_FALSE;
   }
 
-  // Test the case where both rects are empty. This should fail
+  // Test the case where both rects are empty
   rect1.Empty();
   rect2.Empty();
   if (dest.UnionRect(rect1, rect2)) {
-    printf("rect union test #3 failed!\n");
+    fail("[3] Test the case where both rects are empty");
     return PR_FALSE;
   }
 
   // Test union case where the two rects don't overlap at all
   rect1.SetRect(10, 10, 50, 50);
   rect2.SetRect(100, 100, 50, 50);
   if (!dest.UnionRect(rect1, rect2) ||
-     (dest != nsRect(rect1.x, rect1.y, rect2.XMost() - rect1.x, rect2.YMost() - rect1.y))) {
-    printf("rect union test #4 failed!\n");
+     (dest != RectType(rect1.x, rect1.y, rect2.XMost() - rect1.x, rect2.YMost() - rect1.y))) {
+    fail("[4] Test union case where the two rects don't overlap at all");
     return PR_FALSE;
   }
 
   // Test union case where the two rects overlap
   rect1.SetRect(30, 30, 50, 50);
   rect2.SetRect(10, 10, 50, 50);
   if (!dest.UnionRect(rect1, rect2) ||
-      (dest != nsRect(rect2.x, rect2.y, rect1.XMost() - rect2.x, rect1.YMost() - rect2.y))) {
-    printf("rect union test #5 failed!\n");
+      (dest != RectType(rect2.x, rect2.y, rect1.XMost() - rect2.x, rect1.YMost() - rect2.y))) {
+    fail("[5] Test union case where the two rects overlap");
     return PR_FALSE;
   }
 
+  passed("TestUnion");
   return PR_TRUE;
 }
 
 int main(int argc, char** argv)
 {
-  if (!TestConstructors())
+  ScopedXPCOM xpcom("TestRect");
+  if (xpcom.failed())
     return -1;
 
-  if (!TestEqualityOperator())
-    return -1;
+  int rv = 0;
 
-  if (!TestContainment())
-    return -1;
+  //-----------------------
+  // Test nsRect
+  //
+  printf("===== nsRect tests =====\n");
 
-  if (!TestIntersects())
-    return -1;
+  if (!TestConstructors<nsRect>())
+    rv = -1;
 
-  if (!TestIntersection())
-    return -1;
+  if (!TestEqualityOperator<nsRect>())
+    rv = -1;
 
-  if (!TestUnion())
-    return -1;
+  if (!TestContainment<nsRect>())
+    rv = -1;
 
-  return 0;
+  if (!TestIntersects<nsRect>())
+    rv = -1;
+
+  if (!TestIntersection<nsRect>())
+    rv = -1;
+
+  if (!TestUnion<nsRect>())
+    rv = -1;
+
+  //-----------------------
+  // Test nsIntRect
+  //
+  printf("===== nsIntRect tests =====\n");
+ 
+  if (!TestConstructors<nsIntRect>())
+    rv = -1;
+
+  if (!TestEqualityOperator<nsIntRect>())
+    rv = -1;
+
+  if (!TestContainment<nsIntRect>())
+    rv = -1;
+
+  if (!TestIntersects<nsIntRect>())
+    rv = -1;
+
+  if (!TestIntersection<nsIntRect>())
+    rv = -1;
+
+  if (!TestUnion<nsIntRect>())
+    rv = -1;
+
+  return rv;
 }
