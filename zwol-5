From: Zack Weinberg <zweinberg@mozilla.com>

Bug 576044 (5/12): eliminate ValueList as a storage type.  r=dbaron  a2.0=dbaron

diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1911,17 +1911,18 @@ nsGenericHTMLElement::MapImageBorderAttr
 void
 nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
                                         nsRuleData* aData)
 {
   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     return;
 
   nsPresContext* presContext = aData->mPresContext;
-  if (!aData->mColorData->mBackImage && presContext->UseDocumentColors()) {
+  if (aData->mColorData->mBackImage.GetUnit() == eCSSUnit_Null &&
+      presContext->UseDocumentColors()) {
     // background
     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::background);
     if (value && value->Type() == nsAttrValue::eString) {
       const nsString& spec = value->GetStringValue();
       if (!spec.IsEmpty()) {
         // Resolve url to an absolute url
         // XXX this breaks if the HTML element has an xml:base
         // attribute (the xml:base will not be taken into account)
@@ -1941,32 +1942,28 @@ nsGenericHTMLElement::MapBackgroundInto(
             // XXXbz it would be nice to assert that doc->NodePrincipal() is
             // the same as the principal of the node (which we'd need to store
             // in the mapped attrs or something?)
             nsCSSValue::Image *img =
               new nsCSSValue::Image(uri, buffer, doc->GetDocumentURI(),
                                     doc->NodePrincipal(), doc);
             buffer->Release();
             if (NS_LIKELY(img != 0)) {
-              // Use nsRuleDataColor's temporary mTempBackImage to
-              // make a value list.
-              aData->mColorData->mTempBackImage.mValue.SetImageValue(img);
-              aData->mColorData->mBackImage =
-                &aData->mColorData->mTempBackImage;
+              nsCSSValueList* list =
+                aData->mColorData->mBackImage.SetListValue();
+              list->mValue.SetImageValue(img);
             }
           }
         }
       }
       else if (presContext->CompatibilityMode() == eCompatibility_NavQuirks) {
         // in NavQuirks mode, allow the empty string to set the
         // background to empty
-        // Use nsRuleDataColor's temporary mTempBackImage to make a value list.
-        aData->mColorData->mBackImage = nsnull;
-        aData->mColorData->mTempBackImage.mValue.SetNoneValue();
-        aData->mColorData->mBackImage = &aData->mColorData->mTempBackImage;
+        nsCSSValueList* list = aData->mColorData->mBackImage.SetListValue();
+        list->mValue.SetNoneValue();
       }
     }
   }
 }
 
 void
 nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
                                      nsRuleData* aData)
diff --git a/layout/style/Declaration.cpp b/layout/style/Declaration.cpp
--- a/layout/style/Declaration.cpp
+++ b/layout/style/Declaration.cpp
@@ -53,16 +53,17 @@
 #include "nsReadableUtils.h"
 #include "nsCRT.h"
 #include "nsCSSProps.h"
 #include "nsFont.h"
 #include "nsReadableUtils.h"
 #include "nsStyleUtil.h"
 #include "nsStyleConsts.h"
 #include "nsCOMPtr.h"
+#include "nsPrintfCString.h"
 
 namespace mozilla {
 namespace css {
 
 // check that we can fit all the CSS properties into a PRUint8
 // for the mOrder array - if not, might need to use PRUint16!
 PR_STATIC_ASSERT(eCSSProperty_COUNT_no_shorthands - 1 <= PR_UINT8_MAX);
 
@@ -133,20 +134,16 @@ PRBool Declaration::AppendValueToString(
     return PR_FALSE;
   }
 
   switch (nsCSSProps::kTypeTable[aProperty]) {
     case eCSSType_Value:
       static_cast<const nsCSSValue*>(storage)->
         AppendToString(aProperty, aResult);
       break;
-    case eCSSType_ValueList:
-      (*static_cast<nsCSSValueList*const*>(storage))->
-        AppendToString(aProperty, aResult);
-      break;
   }
   return PR_TRUE;
 }
 
 void
 Declaration::GetValue(nsCSSProperty aProperty, nsAString& aValue) const
 {
   aValue.Truncate(0);
@@ -199,22 +196,16 @@ Declaration::GetValue(nsCSSProperty aPro
       return;
     }
     nsCSSUnit unit;
     switch (nsCSSProps::kTypeTable[*p]) {
       case eCSSType_Value: {
         const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
         unit = val->GetUnit();
       } break;
-      case eCSSType_ValueList: {
-        const nsCSSValueList* item =
-            *static_cast<nsCSSValueList*const*>(storage);
-        NS_ABORT_IF_FALSE(item, "null not allowed in compressed block");
-        unit = item->mValue.GetUnit();
-      } break;
     }
     if (unit == eCSSUnit_Inherit) {
       ++inheritCount;
     } else if (unit == eCSSUnit_Initial) {
       ++initialCount;
     }
   }
   if (importantCount != 0 && importantCount != totalCount) {
@@ -414,28 +405,33 @@ Declaration::GetValue(nsCSSProperty aPro
       // We know from above that all subproperties were specified.
       // However, we still can't represent that in the shorthand unless
       // they're all lists of the same length.  So if they're different
       // lengths, we need to bail out.
       // We also need to bail out if an item has background-clip and
       // background-origin that are different and not the default
       // values.  (We omit them if they're both default.)
       const nsCSSValueList *image =
-        * data->ValueListStorageFor(eCSSProperty_background_image);
+        data->ValueStorageFor(eCSSProperty_background_image)->
+        GetListValue();
       const nsCSSValueList *repeat =
-        * data->ValueListStorageFor(eCSSProperty_background_repeat);
+        data->ValueStorageFor(eCSSProperty_background_repeat)->
+        GetListValue();
       const nsCSSValueList *attachment =
-        * data->ValueListStorageFor(eCSSProperty_background_attachment);
+        data->ValueStorageFor(eCSSProperty_background_attachment)->
+        GetListValue();
       const nsCSSValuePairList *position =
         data->ValueStorageFor(eCSSProperty_background_position)->
         GetPairListValue();
       const nsCSSValueList *clip =
-        * data->ValueListStorageFor(eCSSProperty_background_clip);
+        data->ValueStorageFor(eCSSProperty_background_clip)->
+        GetListValue();
       const nsCSSValueList *origin =
-        * data->ValueListStorageFor(eCSSProperty_background_origin);
+        data->ValueStorageFor(eCSSProperty_background_origin)->
+        GetListValue();
       const nsCSSValuePairList *size =
         data->ValueStorageFor(eCSSProperty_background_size)->
         GetPairListValue();
       for (;;) {
         if (size->mXValue.GetUnit() != eCSSUnit_Auto ||
             size->mYValue.GetUnit() != eCSSUnit_Auto) {
           // Non-default background-size, so can't be serialized as shorthand.
           aValue.Truncate();
@@ -616,55 +612,90 @@ Declaration::GetValue(nsCSSProperty aPro
       if (AppendValueToString(eCSSProperty_pause_before, aValue)) {
         aValue.Append(PRUnichar(' '));
         if (!AppendValueToString(eCSSProperty_pause_after, aValue))
           aValue.Truncate();
       }
       break;
     }
     case eCSSProperty_transition: {
-#define NUM_TRANSITION_SUBPROPS 4
-      const nsCSSProperty* subprops =
-        nsCSSProps::SubpropertyEntryFor(aProperty);
-#ifdef DEBUG
-      for (int i = 0; i < NUM_TRANSITION_SUBPROPS; ++i) {
-        NS_ASSERTION(nsCSSProps::kTypeTable[subprops[i]] == eCSSType_ValueList,
-                     "type mismatch");
+      const nsCSSValue &transProp =
+        *data->ValueStorageFor(eCSSProperty_transition_property);
+      const nsCSSValue &transDuration =
+        *data->ValueStorageFor(eCSSProperty_transition_duration);
+      const nsCSSValue &transTiming =
+        *data->ValueStorageFor(eCSSProperty_transition_timing_function);
+      const nsCSSValue &transDelay =
+        *data->ValueStorageFor(eCSSProperty_transition_delay);
+
+      NS_ABORT_IF_FALSE(transDuration.GetUnit() == eCSSUnit_List ||
+                        transDuration.GetUnit() == eCSSUnit_ListDep,
+                        nsPrintfCString(32, "bad t-duration unit %d",
+                                        transDuration.GetUnit()).get());
+      NS_ABORT_IF_FALSE(transTiming.GetUnit() == eCSSUnit_List ||
+                        transTiming.GetUnit() == eCSSUnit_ListDep,
+                        nsPrintfCString(32, "bad t-timing unit %d",
+                                        transTiming.GetUnit()).get());
+      NS_ABORT_IF_FALSE(transDelay.GetUnit() == eCSSUnit_List ||
+                        transDelay.GetUnit() == eCSSUnit_ListDep,
+                        nsPrintfCString(32, "bad t-delay unit %d",
+                                        transDelay.GetUnit()).get());
+
+      const nsCSSValueList* dur = transDuration.GetListValue();
+      const nsCSSValueList* tim = transTiming.GetListValue();
+      const nsCSSValueList* del = transDelay.GetListValue();
+
+      if (transProp.GetUnit() == eCSSUnit_None ||
+          transProp.GetUnit() == eCSSUnit_All) {
+        // If any of the other three lists has more than one element,
+        // we can't use the shorthand.
+        if (!dur->mNext && !tim->mNext && !del->mNext) {
+          transProp.AppendToString(eCSSProperty_transition_property, aValue);
+          aValue.Append(PRUnichar(' '));
+          dur->mValue.AppendToString(eCSSProperty_transition_duration,aValue);
+          aValue.Append(PRUnichar(' '));
+          tim->mValue.AppendToString(eCSSProperty_transition_timing_function, aValue);
+          aValue.Append(PRUnichar(' '));
+          del->mValue.AppendToString(eCSSProperty_transition_delay, aValue);
+          aValue.Append(PRUnichar(' '));
+        } else {
+          aValue.Truncate();
+        }
+      } else {
+        NS_ABORT_IF_FALSE(transProp.GetUnit() == eCSSUnit_List ||
+                          transProp.GetUnit() == eCSSUnit_ListDep,
+                          nsPrintfCString(32, "bad t-prop unit %d",
+                                          transProp.GetUnit()).get());
+        const nsCSSValueList* pro = transProp.GetListValue();
+        for (;;) {
+          pro->mValue.AppendToString(eCSSProperty_transition_property,
+                                        aValue);
+          aValue.Append(PRUnichar(' '));
+          dur->mValue.AppendToString(eCSSProperty_transition_duration,
+                                        aValue);
+          aValue.Append(PRUnichar(' '));
+          tim->mValue.AppendToString(eCSSProperty_transition_timing_function,
+                                        aValue);
+          aValue.Append(PRUnichar(' '));
+          del->mValue.AppendToString(eCSSProperty_transition_delay,
+                                        aValue);
+          pro = pro->mNext;
+          dur = dur->mNext;
+          tim = tim->mNext;
+          del = del->mNext;
+          if (!pro || !dur || !tim || !del) {
+            break;
+          }
+          aValue.AppendLiteral(", ");
+        }
+        if (pro || dur || tim || del) {
+          // Lists not all the same length, can't use shorthand.
+          aValue.Truncate();
+        }
       }
-      NS_ASSERTION(subprops[NUM_TRANSITION_SUBPROPS] == eCSSProperty_UNKNOWN,
-                   "length mismatch");
-#endif
-      const nsCSSValueList* val[NUM_TRANSITION_SUBPROPS];
-      for (int i = 0; i < NUM_TRANSITION_SUBPROPS; ++i) {
-        val[i] = *data->ValueListStorageFor(subprops[i]);
-      }
-      // Merge the lists of the subproperties into a single list.
-      for (;;) {
-        for (int i = 0; i < NUM_TRANSITION_SUBPROPS; ++i) {
-          val[i]->mValue.AppendToString(subprops[i], aValue);
-          aValue.Append(PRUnichar(' '));
-          val[i] = val[i]->mNext;
-        }
-        // Remove the last space.
-        aValue.Truncate(aValue.Length() - 1);
-
-        PR_STATIC_ASSERT(NUM_TRANSITION_SUBPROPS == 4);
-        if (!val[0] || !val[1] || !val[2] || !val[3]) {
-          break;
-        }
-        aValue.AppendLiteral(", ");
-      }
-
-      PR_STATIC_ASSERT(NUM_TRANSITION_SUBPROPS == 4);
-      if (val[0] || val[1] || val[2] || val[3]) {
-        // The sublists are different lengths, so this can't be
-        // represented as the shorthand.
-        aValue.Truncate();
-      }
-#undef NUM_TRANSITION_SUBPROPS
       break;
     }
 
     case eCSSProperty_marker: {
       const nsCSSValue &endValue =
         *data->ValueStorageFor(eCSSProperty_marker_end);
       const nsCSSValue &midValue =
         *data->ValueStorageFor(eCSSProperty_marker_mid);
diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -66,27 +66,18 @@ namespace css = mozilla::css;
  * block.
  */
 
 struct CDBValueStorage {
     nsCSSProperty property;
     nsCSSValue value;
 };
 
-struct CDBPointerStorage {
-    nsCSSProperty property;
-    void *value;
-};
-
 enum {
-    CDBValueStorage_advance = sizeof(CDBValueStorage),
-    // round up using the closest estimate we can get of the alignment
-    // requirements of nsCSSValue:
-    CDBPointerStorage_advance = PR_ROUNDUP(sizeof(CDBPointerStorage),
-                                sizeof(CDBValueStorage) - sizeof(nsCSSValue))
+    CDBValueStorage_advance = sizeof(CDBValueStorage)
 };
 
 /*
  * Define a bunch of utility functions for getting the property or any
  * of the value types when the cursor is at the beginning of the storage
  * for the property-value pair.  The versions taking a non-const cursor
  * argument return a reference so that the caller can assign into the
  * result.
@@ -103,44 +94,16 @@ inline nsCSSProperty PropertyAtCursor(co
 inline nsCSSValue* ValueAtCursor(char *aCursor) {
     return & reinterpret_cast<CDBValueStorage*>(aCursor)->value;
 }
 
 inline const nsCSSValue* ValueAtCursor(const char *aCursor) {
     return & reinterpret_cast<const CDBValueStorage*>(aCursor)->value;
 }
 
-inline void*& PointerAtCursor(char *aCursor) {
-    return reinterpret_cast<CDBPointerStorage*>(aCursor)->value;
-}
-
-inline void* PointerAtCursor(const char *aCursor) {
-    return reinterpret_cast<const CDBPointerStorage*>(aCursor)->value;
-}
-
-inline nsCSSValueList*& ValueListAtCursor(char *aCursor) {
-    return * reinterpret_cast<nsCSSValueList**>
-                             (& reinterpret_cast<CDBPointerStorage*>(aCursor)->value);
-}
-
-inline nsCSSValueList* ValueListAtCursor(const char *aCursor) {
-    return static_cast<nsCSSValueList*>
-                      (reinterpret_cast<const CDBPointerStorage*>(aCursor)->value);
-}
-
-inline nsCSSValuePairList*& ValuePairListAtCursor(char *aCursor) {
-    return * reinterpret_cast<nsCSSValuePairList**>
-                             (& reinterpret_cast<CDBPointerStorage*>(aCursor)->value);
-}
-
-inline nsCSSValuePairList* ValuePairListAtCursor(const char *aCursor) {
-    return static_cast<nsCSSValuePairList*>
-                      (reinterpret_cast<const CDBPointerStorage*>(aCursor)->value);
-}
-
 static PRBool
 ShouldIgnoreColors(nsRuleData *aRuleData)
 {
     return aRuleData->mLevel != nsStyleSet::eAgentSheet &&
            aRuleData->mLevel != nsStyleSet::eUserSheet &&
            !aRuleData->mPresContext->UseDocumentColors();
 }
 
@@ -163,17 +126,22 @@ TryToStartImageLoadOnValue(const nsCSSVa
       image.StartImageLoad(aDocument);
   }
 }
 
 static void
 TryToStartImageLoad(const nsCSSValue& aValue, nsIDocument* aDocument,
                     nsCSSProperty aProperty)
 {
-  if (nsCSSProps::PropHasFlags(aProperty, CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0)) {
+  if (aValue.GetUnit() == eCSSUnit_List) {
+    for (const nsCSSValueList* l = aValue.GetListValue(); l; l = l->mNext) {
+      TryToStartImageLoad(l->mValue, aDocument, aProperty);
+    }
+  } else if (nsCSSProps::PropHasFlags(aProperty,
+                                      CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0)) {
     if (aValue.GetUnit() == eCSSUnit_Array) {
       TryToStartImageLoadOnValue(aValue.GetArrayValue()->Item(0), aDocument);
     }
   } else {
     TryToStartImageLoadOnValue(aValue, aDocument);
   }
 }
 
@@ -241,50 +209,22 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                             } else {
                                 // Ignore 'color', 'border-*-color', etc.
                                 *target = nsCSSValue();
                             }
                         }
                     }
                     cursor += CDBValueStorage_advance;
                 } break;
-
-                case eCSSType_ValueList: {
-                    void** target = static_cast<void**>(prop);
-                    if (!*target) {
-                        if (ShouldStartImageLoads(aRuleData, iProp)) {
-                            for (nsCSSValueList* l = ValueListAtCursor(cursor);
-                                 l; l = l->mNext) {
-                                TryToStartImageLoad(l->mValue, doc, iProp);
-                            }
-                        }
-
-                        void* val = PointerAtCursor(cursor);
-                        NS_ASSERTION(val, "oops");
-                        *target = val;
-
-                        if (nsCSSProps::PropHasFlags(iProp,
-                                CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED) &&
-                            ShouldIgnoreColors(aRuleData))
-                        {
-                            *target = nsnull;
-                        }
-                    }
-                    cursor += CDBPointerStorage_advance;
-                } break;
             }
         } else {
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
                     cursor += CDBValueStorage_advance;
                 } break;
-
-                case eCSSType_ValueList: {
-                    cursor += CDBPointerStorage_advance;
-                } break;
             }
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 }
 
 const void*
 nsCSSCompressedDataBlock::StorageFor(nsCSSProperty aProperty) const
@@ -306,29 +246,22 @@ nsCSSCompressedDataBlock::StorageFor(nsC
         nsCSSProperty iProp = PropertyAtCursor(cursor);
         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
                      "out of range");
         if (iProp == aProperty) {
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
                     return ValueAtCursor(cursor);
                 }
-                case eCSSType_ValueList: {
-                    return &PointerAtCursor(const_cast<char*>(cursor));
-                }
             }
         }
         switch (nsCSSProps::kTypeTable[iProp]) {
             case eCSSType_Value: {
                 cursor += CDBValueStorage_advance;
             } break;
-
-            case eCSSType_ValueList: {
-                cursor += CDBPointerStorage_advance;
-            } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 
     return nsnull;
 }
 
 nsCSSCompressedDataBlock*
@@ -353,28 +286,16 @@ nsCSSCompressedDataBlock::Clone() const
             case eCSSType_Value: {
                 const nsCSSValue* val = ValueAtCursor(cursor);
                 NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
                 nsCSSValue *result_val = ValueAtCursor(result_cursor);
                 new (result_val) nsCSSValue(*val);
                 cursor += CDBValueStorage_advance;
                 result_cursor +=  CDBValueStorage_advance;
             } break;
-
-            case eCSSType_ValueList: {
-                void *copy = ValueListAtCursor(cursor)->Clone();
-                if (!copy) {
-                    // so the destructor knows where to stop clearing
-                    result->mBlockEnd = result_cursor;
-                    return nsnull;
-                }
-                PointerAtCursor(result_cursor) = copy;
-                cursor += CDBPointerStorage_advance;
-                result_cursor += CDBPointerStorage_advance;
-            } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 
     result->mBlockEnd = result_cursor;
     result->mStyleBits = mStyleBits;
     NS_ASSERTION(result->DataSize() == DataSize(), "wrong size");
 
@@ -392,23 +313,16 @@ nsCSSCompressedDataBlock::~nsCSSCompress
 
         switch (nsCSSProps::kTypeTable[iProp]) {
             case eCSSType_Value: {
                 const nsCSSValue* val = ValueAtCursor(cursor);
                 NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
                 val->~nsCSSValue();
                 cursor += CDBValueStorage_advance;
             } break;
-
-            case eCSSType_ValueList: {
-                nsCSSValueList* val = ValueListAtCursor(cursor);
-                NS_ASSERTION(val, "oops");
-                delete val;
-                cursor += CDBPointerStorage_advance;
-            } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 }
 
 /* static */ nsCSSCompressedDataBlock*
 nsCSSCompressedDataBlock::CreateEmptyBlock()
 {
@@ -427,26 +341,16 @@ nsCSSCompressedDataBlock::MoveValue(void
       nsCSSValue *source = static_cast<nsCSSValue*>(aSource);
       nsCSSValue *dest = static_cast<nsCSSValue*>(aDest);
       if (*source != *dest)
         *aChanged = PR_TRUE;
       dest->~nsCSSValue();
       memcpy(dest, source, sizeof(nsCSSValue));
       new (source) nsCSSValue();
     } break;
-
-    case eCSSType_ValueList: {
-      nsCSSValueList **source = static_cast<nsCSSValueList**>(aSource);
-      nsCSSValueList **dest = static_cast<nsCSSValueList**>(aDest);
-      if (**source != **dest)
-        *aChanged = PR_TRUE;
-      delete *dest;
-      *dest = *source;
-      *source = nsnull;
-    } break;
   }
 }
 
 /*****************************************************************************/
 
 nsCSSExpandedDataBlock::nsCSSExpandedDataBlock()
 {
     AssertInitialState();
@@ -495,25 +399,16 @@ nsCSSExpandedDataBlock::DoExpand(nsCSSCo
                 NS_ASSERTION(dest->GetUnit() == eCSSUnit_Null,
                              "expanding into non-empty block");
 #ifdef NS_BUILD_REFCNT_LOGGING
                 dest->~nsCSSValue();
 #endif
                 memcpy(dest, val, sizeof(nsCSSValue));
                 cursor += CDBValueStorage_advance;
             } break;
-
-            case eCSSType_ValueList: {
-                void* val = PointerAtCursor(cursor);
-                void** dest = static_cast<void**>(prop);
-                NS_ASSERTION(val, "oops");
-                NS_ASSERTION(!*dest, "expanding into non-empty block");
-                *dest = val;
-                cursor += CDBPointerStorage_advance;
-            } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 
     // Don't destroy remnants of what we just copied
     aBlock->mBlockEnd = aBlock->Block();
     delete aBlock;
 }
@@ -552,24 +447,16 @@ nsCSSExpandedDataBlock::ComputeSize()
                 case eCSSType_Value: {
 #ifdef DEBUG
                     nsCSSValue* val = static_cast<nsCSSValue*>(prop);
                     NS_ASSERTION(val->GetUnit() != eCSSUnit_Null,
                                  "null value while computing size");
 #endif
                     increment = CDBValueStorage_advance;
                 } break;
-
-                case eCSSType_ValueList: {
-#ifdef DEBUG
-                    void* val = *static_cast<void**>(prop);
-                    NS_ASSERTION(val, "Null pointer while computing size");
-#endif
-                    increment = CDBPointerStorage_advance;
-                } break;
             }
             if (mPropertiesImportant.HasPropertyAt(iHigh, iLow))
                 result.important += increment;
             else
                 result.normal += increment;
         }
     }
     return result;
@@ -631,27 +518,16 @@ nsCSSExpandedDataBlock::Compress(nsCSSCo
                                  "Null value while compressing");
                     CDBValueStorage *storage =
                         reinterpret_cast<CDBValueStorage*>(cursor);
                     storage->property = iProp;
                     memcpy(&storage->value, val, sizeof(nsCSSValue));
                     new (val) nsCSSValue();
                     cursor += CDBValueStorage_advance;
                 } break;
-
-                case eCSSType_ValueList: {
-                    void*& val = *static_cast<void**>(prop);
-                    NS_ASSERTION(val, "Null pointer while compressing");
-                    CDBPointerStorage *storage =
-                        reinterpret_cast<CDBPointerStorage*>(cursor);
-                    storage->property = iProp;
-                    storage->value = val;
-                    val = nsnull;
-                    cursor += CDBPointerStorage_advance;
-                } break;
             }
             result->mStyleBits |=
                 nsCachedStyleData::GetBitForSID(nsCSSProps::kSIDTable[iProp]);
         }
     }
 
     result_normal->mBlockEnd = cursor_normal;
     NS_ASSERTION(result_normal->DataSize() == ptrdiff_t(size.normal),
@@ -708,24 +584,16 @@ nsCSSExpandedDataBlock::ClearLonghandPro
     ClearImportantBit(aPropID);
 
     void *prop = PropertyAt(aPropID);
     switch (nsCSSProps::kTypeTable[aPropID]) {
         case eCSSType_Value: {
             nsCSSValue* val = static_cast<nsCSSValue*>(prop);
             val->Reset();
         } break;
-
-        case eCSSType_ValueList: {
-            nsCSSValueList*& val = *static_cast<nsCSSValueList**>(prop);
-            if (val) {
-                delete val;
-                val = nsnull;
-            }
-        } break;
     }
 }
 
 void
 nsCSSExpandedDataBlock::TransferFromBlock(nsCSSExpandedDataBlock& aFromBlock,
                                           nsCSSProperty aPropID,
                                           PRBool aIsImportant,
                                           PRBool aOverrideImportant,
@@ -801,17 +669,12 @@ nsCSSExpandedDataBlock::DoAssertInitialS
     for (PRUint32 i = 0; i < eCSSProperty_COUNT_no_shorthands; ++i) {
         void *prop = PropertyAt(nsCSSProperty(i));
         switch (nsCSSProps::kTypeTable[i]) {
             case eCSSType_Value: {
                 nsCSSValue* val = static_cast<nsCSSValue*>(prop);
                 NS_ASSERTION(val->GetUnit() == eCSSUnit_Null,
                              "not initial state");
             } break;
-
-            case eCSSType_ValueList: {
-                nsCSSValueList* val = *static_cast<nsCSSValueList**>(prop);
-                NS_ASSERTION(val == nsnull, "not initial state");
-            } break;
         }
     }
 }
 #endif
diff --git a/layout/style/nsCSSDataBlock.h b/layout/style/nsCSSDataBlock.h
--- a/layout/style/nsCSSDataBlock.h
+++ b/layout/style/nsCSSDataBlock.h
@@ -102,23 +102,16 @@ public:
      * A set of slightly more typesafe helpers for the above.  All
      * return null if the value is not present.
      */
     const nsCSSValue* ValueStorageFor(nsCSSProperty aProperty) const {
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                         "type mismatch");
       return static_cast<const nsCSSValue*>(StorageFor(aProperty));
     }
-    const nsCSSValueList*const*
-    ValueListStorageFor(nsCSSProperty aProperty) const {
-      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                          eCSSType_ValueList,
-                        "type mismatch");
-      return static_cast<const nsCSSValueList*const*>(StorageFor(aProperty));
-    }
 
     /**
      * Clone this block, or return null on out-of-memory.
      */
     nsCSSCompressedDataBlock* Clone() const;
 
     /**
      * Create a new nsCSSCompressedDataBlock holding no declarations.
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -151,16 +151,17 @@ namespace css = mozilla::css;
 #define VARIANT_HUO  (VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)
 #define VARIANT_AHUO (VARIANT_AUTO | VARIANT_HUO)
 #define VARIANT_HPN  (VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)
 #define VARIANT_HN   (VARIANT_INHERIT | VARIANT_NUMBER)
 #define VARIANT_HON  (VARIANT_HN | VARIANT_NONE)
 #define VARIANT_HOS  (VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)
 #define VARIANT_TIMING_FUNCTION (VARIANT_KEYWORD | VARIANT_CUBIC_BEZIER)
 #define VARIANT_UK   (VARIANT_URL | VARIANT_KEYWORD)
+#define VARIANT_UO   (VARIANT_URL | VARIANT_NONE)
 #define VARIANT_ANGLE_OR_ZERO (VARIANT_ANGLE | VARIANT_ZERO_ANGLE)
 #define VARIANT_TRANSFORM_LPCALC (VARIANT_LP | VARIANT_CALC | \
                                   VARIANT_CALC_NO_MIN_MAX)
 #define VARIANT_IMAGE (VARIANT_URL | VARIANT_NONE | VARIANT_GRADIENT | \
                        VARIANT_IMAGE_RECT | VARIANT_ELEMENT)
 
 //----------------------------------------------------------------------
 
@@ -425,45 +426,36 @@ protected:
 #endif
 
   void InitBoxPropsAsPhysical(const nsCSSProperty *aSourceProperties);
 
   // Property specific parsing routines
   PRBool ParseAzimuth(nsCSSValue& aValue);
   PRBool ParseBackground();
 
-  struct BackgroundItem;
-  friend struct BackgroundItem;
-  struct BackgroundItem {
-    nsCSSValue mImage;
-    nsCSSValue mRepeat;
-    nsCSSValue mAttachment;
-    nsCSSValuePair mPosition;
-    nsCSSValue mClip;
-    nsCSSValue mOrigin;
-    nsCSSValuePair mSize;
-    // The background-color is set as a side-effect, and if so, mLastItem
-    // is set to true.
-    PRBool mLastItem;
+  struct BackgroundParseState {
+    nsCSSValue&  mColor;
+    nsCSSValueList* mImage;
+    nsCSSValueList* mRepeat;
+    nsCSSValueList* mAttachment;
+    nsCSSValueList* mClip;
+    nsCSSValueList* mOrigin;
+    nsCSSValuePairList* mPosition;
+    nsCSSValuePairList* mSize;
   };
-  struct BackgroundItemSimpleValueInfo {
-    nsCSSValue BackgroundItem::*member;
-    nsCSSProperty propID;
-  };
-
-  PRBool ParseBackgroundItem(BackgroundItem& aItem, PRBool aFirstItem);
+
+  PRBool ParseBackgroundItem(BackgroundParseState& aState);
 
   PRBool ParseBackgroundList(nsCSSProperty aPropID); // a single value prop-id
   PRBool ParseBackgroundPosition();
   PRBool ParseBoxPositionValues(nsCSSValuePair& aOut, PRBool aAcceptsInherit);
   PRBool ParseBackgroundSize();
   PRBool ParseBackgroundSizeValues(nsCSSValuePair& aOut);
   PRBool ParseBorderColor();
-  PRBool ParseBorderColors(nsCSSValueList** aResult,
-                           nsCSSProperty aProperty);
+  PRBool ParseBorderColors(nsCSSProperty aProperty);
   PRBool ParseBorderImage();
   PRBool ParseBorderSpacing();
   PRBool ParseBorderSide(const nsCSSProperty aPropIDs[],
                          PRBool aSetAllSides);
   PRBool ParseDirectionalBorderSide(const nsCSSProperty aPropIDs[],
                                     PRInt32 aSourceType);
   PRBool ParseBorderStyle();
   PRBool ParseBorderWidth();
@@ -499,29 +491,26 @@ protected:
   PRBool ParseOutline();
   PRBool ParseOverflow();
   PRBool ParsePadding();
   PRBool ParsePause();
   PRBool ParseQuotes();
   PRBool ParseSize();
   PRBool ParseTextDecoration(nsCSSValue& aValue);
 
-  nsCSSValueList* ParseCSSShadowList(PRBool aIsBoxShadow);
-  PRBool ParseTextShadow();
-  PRBool ParseBoxShadow();
+  PRBool ParseShadowItem(nsCSSValue& aValue, PRBool aIsBoxShadow);
+  PRBool ParseShadowList(nsCSSProperty aProperty);
   PRBool ParseTransitionTime(nsCSSProperty aPropID);
   PRBool ParseTransitionProperty();
   PRBool ParseTransition();
   PRBool ParseTransitionTimingFunction();
   PRBool ParseTransitionTimingFunctionValues(nsCSSValue& aValue);
   PRBool ParseTransitionTimingFunctionValueComponent(float& aComponent,
                                                      char aStop,
                                                      PRBool aCheckRange);
-  PRBool AppendValueToList(nsCSSValueList**& aListTail,
-                           const nsCSSValue& aValue);
 
 #ifdef MOZ_SVG
   PRBool ParsePaint(nsCSSProperty aPropID);
   PRBool ParseDasharray();
   PRBool ParseMarker();
 #endif
 
   // Reused utility parsing routines
@@ -570,17 +559,17 @@ protected:
     NS_ASSERTION(aBool == PR_TRUE || aBool == PR_FALSE, "bad PRBool value");
     mParsingCompoundProperty = aBool;
   }
   PRBool IsParsingCompoundProperty(void) const {
     return mParsingCompoundProperty;
   }
 
   /* Functions for -moz-transform Parsing */
-  PRBool ReadSingleTransform(nsCSSValueList**& aTail);
+  PRBool ParseSingleTransform(nsCSSValue& aValue);
   PRBool ParseFunction(const nsString &aFunction, const PRInt32 aAllowedTypes[],
                        PRUint16 aMinElems, PRUint16 aMaxElems,
                        nsCSSValue &aValue);
   PRBool ParseFunctionInternals(const PRInt32 aVariantMask[],
                                 PRUint16 aMinElems,
                                 PRUint16 aMaxElems,
                                 nsTArray<nsCSSValue>& aOutput);
 
@@ -5253,27 +5242,20 @@ CSSParserImpl::ParseProperty(nsCSSProper
     return ParseDirectionalBorderSide(kBorderRightIDs,
                                       NS_BOXPROP_SOURCE_PHYSICAL);
   case eCSSProperty_border_start:
     return ParseDirectionalBorderSide(kBorderStartIDs,
                                       NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_top:
     return ParseBorderSide(kBorderTopIDs, PR_FALSE);
   case eCSSProperty_border_bottom_colors:
-    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mBottom,
-                             aPropID);
   case eCSSProperty_border_left_colors:
-    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mLeft,
-                             aPropID);
   case eCSSProperty_border_right_colors:
-    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mRight,
-                             aPropID);
   case eCSSProperty_border_top_colors:
-    return ParseBorderColors(&mTempData.mMargin.mBorderColors.mTop,
-                             aPropID);
+    return ParseBorderColors(aPropID);
   case eCSSProperty_border_image:
     return ParseBorderImage();
   case eCSSProperty_border_width:
     return ParseBorderWidth();
   case eCSSProperty_border_end_color:
     return ParseDirectionalBoxProperty(eCSSProperty_border_end_color,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_border_left_color:
@@ -5322,17 +5304,19 @@ CSSParserImpl::ParseProperty(nsCSSProper
   case eCSSProperty__moz_border_radius_bottomLeft:
   case eCSSProperty__moz_outline_radius_topLeft:
   case eCSSProperty__moz_outline_radius_topRight:
   case eCSSProperty__moz_outline_radius_bottomRight:
   case eCSSProperty__moz_outline_radius_bottomLeft:
     return ParseBoxCornerRadius(aPropID);
 
   case eCSSProperty_box_shadow:
-    return ParseBoxShadow();
+  case eCSSProperty_text_shadow:
+    return ParseShadowList(aPropID);
+
   case eCSSProperty_clip:
     return ParseRect(eCSSProperty_clip);
   case eCSSProperty__moz_column_rule:
     return ParseBorderSide(kColumnRuleIDs, PR_FALSE);
   case eCSSProperty_content:
     return ParseContent();
   case eCSSProperty_counter_increment:
   case eCSSProperty_counter_reset:
@@ -5380,18 +5364,16 @@ CSSParserImpl::ParseProperty(nsCSSProper
     return ParseDirectionalBoxProperty(eCSSProperty_padding_start,
                                        NS_BOXPROP_SOURCE_LOGICAL);
   case eCSSProperty_pause:
     return ParsePause();
   case eCSSProperty_quotes:
     return ParseQuotes();
   case eCSSProperty_size:
     return ParseSize();
-  case eCSSProperty_text_shadow:
-    return ParseTextShadow();
   case eCSSProperty__moz_transform:
     return ParseMozTransform();
   case eCSSProperty__moz_transform_origin:
     return ParseMozTransformOrigin();
   case eCSSProperty_transition:
       return ParseTransition();
   case eCSSProperty_transition_property:
     return ParseTransitionProperty();
@@ -5604,37 +5586,37 @@ CSSParserImpl::ParseSingleValueProperty(
 
   case eCSSProperty_appearance:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kAppearanceKTable);
   case eCSSProperty_azimuth:
     return ParseAzimuth(aValue);
   case eCSSProperty_background_attachment:
     // Used only internally.
-    return ParseVariant(aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_KEYWORD,
                         nsCSSProps::kBackgroundAttachmentKTable);
   case eCSSProperty_background_clip:
     // Used only internally.
-    return ParseVariant(aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_KEYWORD,
                         nsCSSProps::kBackgroundOriginKTable);
   case eCSSProperty_background_color:
     return ParseVariant(aValue, VARIANT_HC, nsnull);
   case eCSSProperty_background_image:
     // Used only internally.
-    return ParseVariant(aValue, VARIANT_IMAGE | VARIANT_INHERIT, nsnull);
+    return ParseVariant(aValue, VARIANT_IMAGE, nsnull);
   case eCSSProperty__moz_background_inline_policy:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBackgroundInlinePolicyKTable);
   case eCSSProperty_background_origin:
     // Used only internally.
-    return ParseVariant(aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_KEYWORD,
                         nsCSSProps::kBackgroundOriginKTable);
   case eCSSProperty_background_repeat:
     // Used only internally.
-    return ParseVariant(aValue, VARIANT_HK,
+    return ParseVariant(aValue, VARIANT_KEYWORD,
                         nsCSSProps::kBackgroundRepeatKTable);
   case eCSSProperty_binding:
     return ParseVariant(aValue, VARIANT_HUO, nsnull);
   case eCSSProperty_border_collapse:
     return ParseVariant(aValue, VARIANT_HK,
                         nsCSSProps::kBorderCollapseKTable);
   case eCSSProperty_border_bottom_color:
   case eCSSProperty_border_end_color_value: // for internal use
@@ -6173,348 +6155,278 @@ BoxPositionMaskToCSSValue(PRInt32 aMask,
   return nsCSSValue(val, eCSSUnit_Enumerated);
 }
 
 PRBool
 CSSParserImpl::ParseBackground()
 {
   nsAutoParseCompoundProperty compound(this);
 
-  // These two are set through side-effects of ParseBackgroundItem.
-  mTempData.SetPropertyBit(eCSSProperty_background_color);
-  mTempData.mColor.mBackColor.SetColorValue(NS_RGBA(0, 0, 0, 0));
-
-  BackgroundItem bgitem;
-  nsCSSValuePairList *positionHead = nsnull, **positionTail = &positionHead;
-  nsCSSValuePairList *sizeHead = nsnull, **sizeTail = &sizeHead;
-  static const BackgroundItemSimpleValueInfo simpleValues[] = {
-    { &BackgroundItem::mImage,      eCSSProperty_background_image },
-    { &BackgroundItem::mRepeat,     eCSSProperty_background_repeat },
-    { &BackgroundItem::mAttachment, eCSSProperty_background_attachment },
-    { &BackgroundItem::mClip,       eCSSProperty_background_clip },
-    { &BackgroundItem::mOrigin,     eCSSProperty_background_origin }
+  // background-color can only be set once, so it's not a list.
+  nsCSSValue color;
+
+  // Check first for inherit/initial.
+  if (ParseVariant(color, VARIANT_INHERIT, nsnull)) {
+    // must be alone
+    if (!ExpectEndProperty()) {
+      return PR_FALSE;
+    }
+    for (const nsCSSProperty* subprops =
+           nsCSSProps::SubpropertyEntryFor(eCSSProperty_background);
+         *subprops != eCSSProperty_UNKNOWN; ++subprops) {
+      AppendValue(*subprops, color);
+    }
+    return PR_TRUE;
+  }
+
+  nsCSSValue image, repeat, attachment, clip, origin, position, size;
+  BackgroundParseState state = {
+    color,
+    image.SetListValue(),
+    repeat.SetListValue(),
+    attachment.SetListValue(),
+    clip.SetListValue(),
+    origin.SetListValue(),
+    position.SetPairListValue(),
+    size.SetPairListValue()
   };
-  nsCSSValueList *simpleHeads[NS_ARRAY_LENGTH(simpleValues)];
-  nsCSSValueList **simpleTails[NS_ARRAY_LENGTH(simpleValues)];
-  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
-    simpleHeads[i] = nsnull;
-    simpleTails[i] = &simpleHeads[i];
-  }
+
   for (;;) {
-    if (!ParseBackgroundItem(bgitem, !positionHead)) {
+    if (!ParseBackgroundItem(state)) {
+      return PR_FALSE;
+    }
+    if (CheckEndProperty()) {
       break;
     }
-
-    nsCSSValuePairList *positionItem = new nsCSSValuePairList;
-    if (!positionItem) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    positionItem->mXValue = bgitem.mPosition.mXValue;
-    positionItem->mYValue = bgitem.mPosition.mYValue;
-    *positionTail = positionItem;
-    positionTail = &positionItem->mNext;
-
-    nsCSSValuePairList *sizeItem = new nsCSSValuePairList;
-    if (!sizeItem) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    sizeItem->mXValue = bgitem.mSize.mXValue;
-    sizeItem->mYValue = bgitem.mSize.mYValue;
-    *sizeTail = sizeItem;
-    sizeTail = &sizeItem->mNext;
-
-    PRBool fail = PR_FALSE;
-    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
-      nsCSSValueList *item = new nsCSSValueList;
-      if (!item) {
-        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-        fail = PR_TRUE;
-        break;
-      }
-      item->mValue = bgitem.*(simpleValues[i].member);
-      *simpleTails[i] = item;
-      simpleTails[i] = &item->mNext;
-    }
-    if (fail) {
-      break;
-    }
-
-    if (!bgitem.mLastItem && ExpectSymbol(',', PR_TRUE)) {
-      continue;
-    }
-    if (!ExpectEndProperty()) {
-      break;
-    }
-
-    // pairlists are not allowed to be initial/inherit anymore
-    if (positionHead->mXValue.GetUnit() == eCSSUnit_Inherit ||
-        positionHead->mXValue.GetUnit() == eCSSUnit_Initial) {
-      NS_ABORT_IF_FALSE(positionHead->mYValue == positionHead->mXValue,
-                        "half-inherit/initial");
-      mTempData.mColor.mBackPosition = positionHead->mXValue;
-      delete positionHead;
-    } else {
-      // this kludge will go away in the next patch
-      nsCSSValuePairList* list =
-        mTempData.mColor.mBackPosition.SetPairListValue();
-      list->mXValue = positionHead->mXValue;
-      list->mYValue = positionHead->mYValue;
-      list->mNext = positionHead->mNext;
-      positionHead->mNext = nsnull;
-      delete positionHead;
-    }
-    if (sizeHead->mXValue.GetUnit() == eCSSUnit_Inherit ||
-        sizeHead->mXValue.GetUnit() == eCSSUnit_Initial) {
-      NS_ABORT_IF_FALSE(sizeHead->mYValue == sizeHead->mXValue,
-                        "half-inherit/initial");
-      mTempData.mColor.mBackSize = sizeHead->mXValue;
-      delete sizeHead;
-    } else {
-      // this kludge will go away in the next patch
-      nsCSSValuePairList* list =
-        mTempData.mColor.mBackSize.SetPairListValue();
-      list->mXValue = sizeHead->mXValue;
-      list->mYValue = sizeHead->mYValue;
-      list->mNext = sizeHead->mNext;
-      sizeHead->mNext = nsnull;
-      delete sizeHead;
-    }
-    for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
-      nsCSSValueList **source = static_cast<nsCSSValueList**>(
-        mTempData.PropertyAt(simpleValues[i].propID));
-      *source = simpleHeads[i];
-    }
-
-    mTempData.SetPropertyBit(eCSSProperty_background_image);
-    mTempData.SetPropertyBit(eCSSProperty_background_repeat);
-    mTempData.SetPropertyBit(eCSSProperty_background_attachment);
-    mTempData.SetPropertyBit(eCSSProperty_background_position);
-    mTempData.SetPropertyBit(eCSSProperty_background_clip);
-    mTempData.SetPropertyBit(eCSSProperty_background_origin);
-    mTempData.SetPropertyBit(eCSSProperty_background_size);
-    return PR_TRUE;
-  }
-  delete positionHead;
-  delete sizeHead;
-  for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(simpleValues); ++i) {
-    delete simpleHeads[i];
-  }
-  return PR_FALSE;
+    // If we saw a color, this must be the last item.
+    if (color.GetUnit() != eCSSUnit_Null) {
+      REPORT_UNEXPECTED_TOKEN(PEExpectEndValue);
+      return PR_FALSE;
+    }
+    // Otherwise, a comma is mandatory.
+    if (!ExpectSymbol(',', PR_TRUE)) {
+      return PR_FALSE;
+    }
+    // Chain another entry on all the lists.
+    state.mImage->mNext = new nsCSSValueList;
+    state.mImage = state.mImage->mNext;
+    state.mRepeat->mNext = new nsCSSValueList;
+    state.mRepeat = state.mRepeat->mNext;
+    state.mAttachment->mNext = new nsCSSValueList;
+    state.mAttachment = state.mAttachment->mNext;
+    state.mClip->mNext = new nsCSSValueList;
+    state.mClip = state.mClip->mNext;
+    state.mOrigin->mNext = new nsCSSValueList;
+    state.mOrigin = state.mOrigin->mNext;
+    state.mPosition->mNext = new nsCSSValuePairList;
+    state.mPosition = state.mPosition->mNext;
+    state.mSize->mNext = new nsCSSValuePairList;
+    state.mSize = state.mSize->mNext;
+  }
+
+  // If we get to this point without seeing a color, provide a default.
+  if (color.GetUnit() == eCSSUnit_Null) {
+    color.SetColorValue(NS_RGBA(0,0,0,0));
+  }
+
+  AppendValue(eCSSProperty_background_image,      image);
+  AppendValue(eCSSProperty_background_repeat,     repeat);
+  AppendValue(eCSSProperty_background_attachment, attachment);
+  AppendValue(eCSSProperty_background_clip,       clip);
+  AppendValue(eCSSProperty_background_origin,     origin);
+  AppendValue(eCSSProperty_background_position,   position);
+  AppendValue(eCSSProperty_background_size,       size);
+  AppendValue(eCSSProperty_background_color,      color);
+  return PR_TRUE;
 }
 
 // Parse one item of the background shorthand property.
 PRBool
-CSSParserImpl::ParseBackgroundItem(CSSParserImpl::BackgroundItem& aItem,
-                                   PRBool aFirstItem)
+CSSParserImpl::ParseBackgroundItem(CSSParserImpl::BackgroundParseState& aState)
+
 {
   // Fill in the values that the shorthand will set if we don't find
   // other values.
-  aItem.mImage.SetNoneValue();
-  aItem.mRepeat.SetIntValue(NS_STYLE_BG_REPEAT_XY, eCSSUnit_Enumerated);
-  aItem.mAttachment.SetIntValue(NS_STYLE_BG_ATTACHMENT_SCROLL,
-                                eCSSUnit_Enumerated);
-  aItem.mPosition.mXValue.SetPercentValue(0.0f);
-  aItem.mPosition.mYValue.SetPercentValue(0.0f);
-  aItem.mClip.SetIntValue(NS_STYLE_BG_CLIP_BORDER, eCSSUnit_Enumerated);
-  aItem.mOrigin.SetIntValue(NS_STYLE_BG_ORIGIN_PADDING, eCSSUnit_Enumerated);
-  aItem.mSize.mXValue.SetAutoValue();
-  aItem.mSize.mYValue.SetAutoValue();
-  aItem.mLastItem = PR_FALSE;
+  aState.mImage->mValue.SetNoneValue();
+  aState.mRepeat->mValue.SetIntValue(NS_STYLE_BG_REPEAT_XY,
+                                     eCSSUnit_Enumerated);
+  aState.mAttachment->mValue.SetIntValue(NS_STYLE_BG_ATTACHMENT_SCROLL,
+                                         eCSSUnit_Enumerated);
+  aState.mClip->mValue.SetIntValue(NS_STYLE_BG_CLIP_BORDER,
+                                   eCSSUnit_Enumerated);
+  aState.mOrigin->mValue.SetIntValue(NS_STYLE_BG_ORIGIN_PADDING,
+                                     eCSSUnit_Enumerated);
+  aState.mPosition->mXValue.SetPercentValue(0.0f);
+  aState.mPosition->mYValue.SetPercentValue(0.0f);
+  aState.mSize->mXValue.SetAutoValue();
+  aState.mSize->mYValue.SetAutoValue();
 
   PRBool haveColor = PR_FALSE,
          haveImage = PR_FALSE,
          haveRepeat = PR_FALSE,
          haveAttach = PR_FALSE,
          havePosition = PR_FALSE,
          haveOrigin = PR_FALSE,
          haveSomething = PR_FALSE;
+
   while (GetToken(PR_TRUE)) {
     nsCSSTokenType tt = mToken.mType;
     UngetToken(); // ...but we'll still cheat and use mToken
     if (tt == eCSSToken_Symbol) {
       // ExpectEndProperty only looks for symbols, and nothing else will
       // show up as one.
       break;
     }
 
     if (tt == eCSSToken_Ident) {
       nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(mToken.mIdent);
       PRInt32 dummy;
       if (keyword == eCSSKeyword_inherit ||
           keyword == eCSSKeyword__moz_initial) {
-        if (haveSomething || !aFirstItem)
-          return PR_FALSE;
-        haveColor = haveImage = haveRepeat = haveAttach = havePosition = haveOrigin =
-          PR_TRUE;
-        GetToken(PR_TRUE); // undo the UngetToken above
-        nsCSSValue val;
-        if (keyword == eCSSKeyword_inherit) {
-          val.SetInheritValue();
-        } else {
-          val.SetInitialValue();
-        }
-        mTempData.mColor.mBackColor = val;
-        aItem.mImage = val;
-        aItem.mRepeat = val;
-        aItem.mAttachment = val;
-        aItem.mPosition.SetBothValuesTo(val);
-        aItem.mClip = val;
-        aItem.mOrigin = val;
-        aItem.mSize.mXValue = val;
-        aItem.mSize.mYValue = val;
-        aItem.mLastItem = PR_TRUE;
-        haveSomething = PR_TRUE;
-        break;
+        return PR_FALSE;
       } else if (keyword == eCSSKeyword_none) {
         if (haveImage)
           return PR_FALSE;
         haveImage = PR_TRUE;
-        if (!ParseSingleValueProperty(aItem.mImage,
+        if (!ParseSingleValueProperty(aState.mImage->mValue,
                                       eCSSProperty_background_image)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundAttachmentKTable, dummy)) {
         if (haveAttach)
           return PR_FALSE;
         haveAttach = PR_TRUE;
-        if (!ParseSingleValueProperty(aItem.mAttachment,
+        if (!ParseSingleValueProperty(aState.mAttachment->mValue,
                                       eCSSProperty_background_attachment)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundRepeatKTable, dummy)) {
         if (haveRepeat)
           return PR_FALSE;
         haveRepeat = PR_TRUE;
-        if (!ParseSingleValueProperty(aItem.mRepeat,
+        if (!ParseSingleValueProperty(aState.mRepeat->mValue,
                                       eCSSProperty_background_repeat)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundPositionKTable, dummy)) {
         if (havePosition)
           return PR_FALSE;
         havePosition = PR_TRUE;
-        if (!ParseBoxPositionValues(aItem.mPosition, PR_FALSE)) {
+        nsCSSValuePair scratch;
+        if (!ParseBoxPositionValues(scratch, PR_FALSE)) {
           return PR_FALSE;
         }
+        aState.mPosition->mXValue = scratch.mXValue;
+        aState.mPosition->mYValue = scratch.mYValue;
       } else if (nsCSSProps::FindKeyword(keyword,
                    nsCSSProps::kBackgroundOriginKTable, dummy)) {
         if (haveOrigin)
           return PR_FALSE;
         haveOrigin = PR_TRUE;
-        if (!ParseSingleValueProperty(aItem.mOrigin,
+        if (!ParseSingleValueProperty(aState.mOrigin->mValue,
                                       eCSSProperty_background_origin)) {
           NS_NOTREACHED("should be able to parse");
           return PR_FALSE;
         }
         PR_STATIC_ASSERT(NS_STYLE_BG_CLIP_BORDER ==
                          NS_STYLE_BG_ORIGIN_BORDER);
         PR_STATIC_ASSERT(NS_STYLE_BG_CLIP_PADDING ==
                          NS_STYLE_BG_ORIGIN_PADDING);
         PR_STATIC_ASSERT(NS_STYLE_BG_CLIP_CONTENT ==
                          NS_STYLE_BG_ORIGIN_CONTENT);
-        aItem.mClip = aItem.mOrigin;
+        aState.mClip->mValue = aState.mOrigin->mValue;
       } else {
         if (haveColor)
           return PR_FALSE;
         haveColor = PR_TRUE;
-        if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
+        if (!ParseSingleValueProperty(aState.mColor,
                                       eCSSProperty_background_color)) {
           return PR_FALSE;
         }
-        aItem.mLastItem = PR_TRUE;
-      }
-    } else if (eCSSToken_Function == tt &&
+      }
+    } else if (tt == eCSSToken_Function &&
                (mToken.mIdent.LowerCaseEqualsLiteral("url") ||
                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-linear-gradient") ||
                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-radial-gradient") ||
                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-repeating-linear-gradient") ||
                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-repeating-radial-gradient") ||
                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-image-rect") ||
                 mToken.mIdent.LowerCaseEqualsLiteral("-moz-element"))) {
       if (haveImage)
         return PR_FALSE;
       haveImage = PR_TRUE;
-      if (!ParseSingleValueProperty(aItem.mImage,
+      if (!ParseSingleValueProperty(aState.mImage->mValue,
                                     eCSSProperty_background_image)) {
         return PR_FALSE;
       }
-    } else if (tt == eCSSToken_Dimension || tt == eCSSToken_Number ||
+    } else if (tt == eCSSToken_Dimension ||
+               tt == eCSSToken_Number ||
                tt == eCSSToken_Percentage) {
       if (havePosition)
         return PR_FALSE;
       havePosition = PR_TRUE;
-      if (!ParseBoxPositionValues(aItem.mPosition, PR_FALSE)) {
+      nsCSSValuePair scratch;
+      if (!ParseBoxPositionValues(scratch, PR_FALSE)) {
         return PR_FALSE;
       }
+      aState.mPosition->mXValue = scratch.mXValue;
+      aState.mPosition->mYValue = scratch.mYValue;
     } else {
       if (haveColor)
         return PR_FALSE;
       haveColor = PR_TRUE;
       // Note: This parses 'inherit' and 'initial', but
       // we've already checked for them, so it's ok.
-      if (!ParseSingleValueProperty(mTempData.mColor.mBackColor,
+      if (!ParseSingleValueProperty(aState.mColor,
                                     eCSSProperty_background_color)) {
         return PR_FALSE;
       }
-      aItem.mLastItem = PR_TRUE;
     }
     haveSomething = PR_TRUE;
   }
 
   return haveSomething;
 }
 
 // This function is very similar to ParseBackgroundPosition and
 // ParseBackgroundSize.
 PRBool
 CSSParserImpl::ParseBackgroundList(nsCSSProperty aPropID)
 {
   // aPropID is a single value prop-id
   nsCSSValue value;
-  nsCSSValueList *head = nsnull, **tail = &head;
-  for (;;) {
-    if (!ParseSingleValueProperty(value, aPropID)) {
-      break;
-    }
-    PRBool inheritOrInitial = value.GetUnit() == eCSSUnit_Inherit ||
-                              value.GetUnit() == eCSSUnit_Initial;
-    if (inheritOrInitial && head) {
-      // inherit and initial are only allowed on their own
-      break;
-    }
-    nsCSSValueList *item = new nsCSSValueList;
-    if (!item) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    item->mValue = value;
-    *tail = item;
-    tail = &item->mNext;
-    if (!inheritOrInitial && ExpectSymbol(',', PR_TRUE)) {
-      continue;
-    }
+  if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
+    // 'initial' and 'inherit' stand alone, no list permitted.
     if (!ExpectEndProperty()) {
-      break;
-    }
-    nsCSSValueList **source =
-      static_cast<nsCSSValueList**>(mTempData.PropertyAt(aPropID));
-    *source = head;
-    mTempData.SetPropertyBit(aPropID);
-    return PR_TRUE;
-  }
-  delete head;
-  return PR_FALSE;
+      return PR_FALSE;
+    }
+  } else {
+    nsCSSValueList* item = value.SetListValue();
+    for (;;) {
+      if (!ParseSingleValueProperty(item->mValue, aPropID)) {
+        return PR_FALSE;
+      }
+      if (CheckEndProperty()) {
+        break;
+      }
+      if (!ExpectSymbol(',', PR_TRUE)) {
+        return PR_FALSE;
+      }
+      item->mNext = new nsCSSValueList;
+      item = item->mNext;
+    }
+  }
+  AppendValue(aPropID, value);
+  return PR_TRUE;
 }
 
 // This function is very similar to ParseBackgroundList and ParseBackgroundSize.
 PRBool
 CSSParserImpl::ParseBackgroundPosition()
 {
   nsCSSValue value;
   if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
@@ -6535,17 +6447,17 @@ CSSParserImpl::ParseBackgroundPosition()
         break;
       }
       if (!ExpectSymbol(',', PR_TRUE)) {
         return PR_FALSE;
       }
       if (!ParseBoxPositionValues(valuePair, PR_FALSE)) {
         return PR_FALSE;
       }
-      item->mNext = new nsCSSValuePairList();
+      item->mNext = new nsCSSValuePairList;
       item = item->mNext;
     }
   }
   AppendValue(eCSSProperty_background_position, value);
   return PR_TRUE;
 }
 
 /**
@@ -6662,17 +6574,17 @@ CSSParserImpl::ParseBackgroundSize()
         break;
       }
       if (!ExpectSymbol(',', PR_TRUE)) {
         return PR_FALSE;
       }
       if (!ParseBackgroundSizeValues(valuePair)) {
         return PR_FALSE;
       }
-      item->mNext = new nsCSSValuePairList();
+      item->mNext = new nsCSSValuePairList;
       item = item->mNext;
     }
   }
   AppendValue(eCSSProperty_background_size, value);
   return PR_TRUE;
 }
 
 /**
@@ -6899,23 +6811,17 @@ CSSParserImpl::ParseBorderSide(const nsC
     // initial values.
     nsCSSValue extraValue;
     switch (values[0].GetUnit()) {
       case eCSSUnit_Inherit:    extraValue.SetInheritValue();    break;
       case eCSSUnit_Initial:    extraValue.SetInitialValue();    break;
       default:                  extraValue.SetNoneValue();       break;
     }
     NS_FOR_CSS_SIDES(side) {
-      nsCSSValueList *l = new nsCSSValueList;
-      if (!l) {
-        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-        return PR_FALSE;
-      }
-      l->mValue = extraValue;
-      mTempData.mMargin.mBorderColors.*(nsCSSValueListRect::sides[side]) = l;
+      mTempData.mMargin.mBorderColors.*(nsCSSRect::sides[side]) = extraValue;
       mTempData.SetPropertyBit(kBorderColorsProps[side]);
     }
     mTempData.mMargin.mBorderImage = extraValue;
     mTempData.SetPropertyBit(eCSSProperty_border_image);
   }
   else {
     // Just set our one side
     for (PRInt32 index = 0; index < numProps; index++) {
@@ -6989,50 +6895,40 @@ CSSParserImpl::ParseBorderWidth()
 
   // do this now, in case 4 values weren't specified
   InitBoxPropsAsPhysical(kBorderWidthSources);
   return ParseBoxProperties(mTempData.mMargin.mBorderWidth,
                             kBorderWidthIDs);
 }
 
 PRBool
-CSSParserImpl::ParseBorderColors(nsCSSValueList** aResult,
-                                 nsCSSProperty aProperty)
-{
-  nsCSSValueList *list = nsnull;
-  for (nsCSSValueList **curp = &list, *cur; ; curp = &cur->mNext) {
-    cur = *curp = new nsCSSValueList();
-    if (!cur) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    if (!ParseVariant(cur->mValue,
-                      (cur == list)
-                        ? (VARIANT_HCK | VARIANT_NONE)
-                        : (VARIANT_COLOR | VARIANT_KEYWORD),
-                      nsCSSProps::kBorderColorKTable)) {
-      break;
-    }
-    if (ExpectEndProperty()) {
-      // Only success case here, since having the failure case at the
-      // end allows more sharing of code.
-      mTempData.SetPropertyBit(aProperty);
-      *aResult = list;
-      return PR_TRUE;
-    }
-    if (cur->mValue.GetUnit() == eCSSUnit_Inherit ||
-        cur->mValue.GetUnit() == eCSSUnit_Initial ||
-        cur->mValue.GetUnit() == eCSSUnit_None) {
-      // 'inherit', 'initial', and 'none' are only allowed on their own
-      break;
-    }
-  }
-  // Have failure case at the end so we can |break| to get to it.
-  delete list;
-  return PR_FALSE;
+CSSParserImpl::ParseBorderColors(nsCSSProperty aProperty)
+{
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
+    // 'inherit', 'initial', and 'none' are only allowed on their own
+    if (!ExpectEndProperty()) {
+      return PR_FALSE;
+    }
+  } else {
+    nsCSSValueList *cur = value.SetListValue();
+    for (;;) {
+      if (!ParseVariant(cur->mValue, VARIANT_COLOR | VARIANT_KEYWORD,
+                        nsCSSProps::kBorderColorKTable)) {
+        return PR_FALSE;
+      }
+      if (CheckEndProperty()) {
+        break;
+      }
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(aProperty, value);
+  return PR_TRUE;
 }
 
 static PRBool
 HasMinMax(const nsCSSValue::Array *aArray)
 {
   for (PRUint32 i = 0, i_end = aArray->Count(); i != i_end; ++i) {
     const nsCSSValue &v = aArray->Item(i);
     if (v.IsCalcUnit() &&
@@ -7468,66 +7364,64 @@ CSSParserImpl::ParseRect(nsCSSProperty a
   return PR_TRUE;
 }
 
 #define VARIANT_CONTENT (VARIANT_STRING | VARIANT_URL | VARIANT_COUNTER | VARIANT_ATTR | \
                          VARIANT_KEYWORD)
 PRBool
 CSSParserImpl::ParseContent()
 {
-  // XXX Rewrite to make it look more like ParseCursor or ParseCounterData?
-  nsCSSValue  value;
-  if (ParseVariant(value,
-                   VARIANT_CONTENT | VARIANT_INHERIT | VARIANT_NORMAL |
-                     VARIANT_NONE,
-                   nsCSSProps::kContentKTable)) {
-    nsCSSValueList* listHead = new nsCSSValueList();
-    nsCSSValueList* list = listHead;
-    if (nsnull == list) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  // We need to divide the 'content' keywords into two classes for
+  // ParseVariant's sake, so we can't just use nsCSSProps::kContentKTable.
+  static const PRInt32 kContentListKWs[] = {
+    eCSSKeyword_open_quote, NS_STYLE_CONTENT_OPEN_QUOTE,
+    eCSSKeyword_close_quote, NS_STYLE_CONTENT_CLOSE_QUOTE,
+    eCSSKeyword_no_open_quote, NS_STYLE_CONTENT_NO_OPEN_QUOTE,
+    eCSSKeyword_no_close_quote, NS_STYLE_CONTENT_NO_CLOSE_QUOTE,
+    eCSSKeyword_UNKNOWN,-1
+  };
+
+  static const PRInt32 kContentSolitaryKWs[] = {
+    eCSSKeyword__moz_alt_content, NS_STYLE_CONTENT_ALT_CONTENT,
+    eCSSKeyword_UNKNOWN,-1
+  };
+
+  // Verify that these two lists add up to the size of
+  // nsCSSProps::kContentKTable.
+  NS_ABORT_IF_FALSE(nsCSSProps::kContentKTable[
+                      NS_ARRAY_LENGTH(kContentListKWs) +
+                      NS_ARRAY_LENGTH(kContentSolitaryKWs) - 4] ==
+                    eCSSKeyword_UNKNOWN &&
+                    nsCSSProps::kContentKTable[
+                      NS_ARRAY_LENGTH(kContentListKWs) +
+                      NS_ARRAY_LENGTH(kContentSolitaryKWs) - 3] == -1,
+                    "content keyword tables out of sync");
+
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_HMK | VARIANT_NONE,
+                   kContentSolitaryKWs)) {
+    // 'inherit', 'initial', 'normal', 'none', and 'alt-content' must be alone
+    if (!ExpectEndProperty()) {
       return PR_FALSE;
     }
-    list->mValue = value;
-
-    while (nsnull != list) {
-      if (ExpectEndProperty()) {
-        mTempData.SetPropertyBit(eCSSProperty_content);
-        mTempData.mContent.mContent = listHead;
-        return PR_TRUE;
-      }
-      if (eCSSUnit_Inherit == value.GetUnit() ||
-          eCSSUnit_Initial == value.GetUnit() ||
-          eCSSUnit_Normal == value.GetUnit() ||
-          eCSSUnit_None == value.GetUnit() ||
-          (eCSSUnit_Enumerated == value.GetUnit() &&
-           NS_STYLE_CONTENT_ALT_CONTENT == value.GetIntValue())) {
-        // This only matters the first time through the loop.
-        delete listHead;
+  } else {
+    nsCSSValueList* cur = value.SetListValue();
+    for (;;) {
+      if (!ParseVariant(cur->mValue, VARIANT_CONTENT, kContentListKWs)) {
         return PR_FALSE;
       }
-      if (ParseVariant(value, VARIANT_CONTENT, nsCSSProps::kContentKTable) &&
-          // Make sure we didn't end up with NS_STYLE_CONTENT_ALT_CONTENT here
-          (value.GetUnit() != eCSSUnit_Enumerated ||
-           value.GetIntValue() != NS_STYLE_CONTENT_ALT_CONTENT)) {
-        list->mNext = new nsCSSValueList();
-        list = list->mNext;
-        if (nsnull != list) {
-          list->mValue = value;
-        }
-        else {
-          mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-        }
-      }
-      else {
+      if (CheckEndProperty()) {
         break;
       }
-    }
-    delete listHead;
-  }
-  return PR_FALSE;
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_content, value);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseCounterData(nsCSSProperty aPropID)
 {
   nsCSSValue value;
   if (!ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
     if (!GetToken(PR_TRUE) || mToken.mType != eCSSToken_Ident) {
@@ -7540,23 +7434,23 @@ CSSParserImpl::ParseCounterData(nsCSSPro
       if (!GetToken(PR_TRUE)) {
         break;
       }
       if (mToken.mType == eCSSToken_Number && mToken.mIntegerValid) {
         cur->mYValue.SetIntValue(mToken.mInteger, eCSSUnit_Integer);
       } else {
         UngetToken();
       }
-      if (ExpectEndProperty()) {
+      if (CheckEndProperty()) {
         break;
       }
       if (!GetToken(PR_TRUE) || mToken.mType != eCSSToken_Ident) {
         return PR_FALSE;
       }
-      cur->mNext = new nsCSSValuePairList();
+      cur->mNext = new nsCSSValuePairList;
       cur = cur->mNext;
     }
   }
   AppendValue(aPropID, value);
   return PR_TRUE;
 }
 
 PRBool
@@ -7583,62 +7477,57 @@ CSSParserImpl::ParseCue()
     }
   }
   return PR_FALSE;
 }
 
 PRBool
 CSSParserImpl::ParseCursor()
 {
-  nsCSSValueList *list = nsnull;
-  for (nsCSSValueList **curp = &list, *cur; ; curp = &cur->mNext) {
-    cur = *curp = new nsCSSValueList();
-    if (!cur) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    if (!ParseVariant(cur->mValue,
-                      (cur == list) ? VARIANT_HUK : VARIANT_UK,
-                      nsCSSProps::kCursorKTable)) {
-      break;
-    }
-    if (cur->mValue.GetUnit() != eCSSUnit_URL) {
-      if (!ExpectEndProperty()) {
-        break;
-      }
-      // Only success case here, since having the failure case at the
-      // end allows more sharing of code.
-      mTempData.SetPropertyBit(eCSSProperty_cursor);
-      mTempData.mUserInterface.mCursor = list;
-      return PR_TRUE;
-    }
-    // We have a URL, so make a value array with three values.
-    nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(3);
-    if (!val) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    val->Item(0) = cur->mValue;
-    cur->mValue.SetArrayValue(val, eCSSUnit_Array);
-
-    // Parse optional x and y position of cursor hotspot (css3-ui).
-    if (ParseVariant(val->Item(1), VARIANT_NUMBER, nsnull)) {
-      // If we have one number, we must have two.
-      if (!ParseVariant(val->Item(2), VARIANT_NUMBER, nsnull)) {
-        break;
-      }
-    }
-
-    if (!ExpectSymbol(',', PR_TRUE)) {
-      break;
-    }
-  }
-  // Have failure case at the end so we can |break| to get to it.
-  delete list;
-  return PR_FALSE;
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
+    // 'inherit' and 'initial' must be alone
+    if (!ExpectEndProperty()) {
+      return PR_FALSE;
+    }
+  } else {
+    nsCSSValueList* cur = value.SetListValue();
+    for (;;) {
+      if (!ParseVariant(cur->mValue, VARIANT_UK, nsCSSProps::kCursorKTable)) {
+        return PR_FALSE;
+      }
+      if (cur->mValue.GetUnit() != eCSSUnit_URL) { // keyword must be last
+        if (ExpectEndProperty()) {
+          break;
+        }
+        return PR_FALSE;
+      }
+
+      // We have a URL, so make a value array with three values.
+      nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(3);
+      val->Item(0) = cur->mValue;
+
+      // Parse optional x and y position of cursor hotspot (css3-ui).
+      if (ParseVariant(val->Item(1), VARIANT_NUMBER, nsnull)) {
+        // If we have one number, we must have two.
+        if (!ParseVariant(val->Item(2), VARIANT_NUMBER, nsnull)) {
+          return PR_FALSE;
+        }
+      }
+      cur->mValue.SetArrayValue(val, eCSSUnit_Array);
+
+      if (!ExpectSymbol(',', PR_TRUE)) { // url must not be last
+        return PR_FALSE;
+      }
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_cursor, value);
+  return PR_TRUE;
 }
 
 
 PRBool
 CSSParserImpl::ParseFont()
 {
   static const nsCSSProperty fontIDs[] = {
     eCSSProperty_font_style,
@@ -8042,127 +7931,65 @@ static PRBool GetFunctionParseInformatio
                "Invalid aMaxElems for this variant mask.");
 #endif
 
   // Convert the index into a mask.
   aVariantMask = kVariantMasks[variantIndex];
 
   return PR_TRUE;
 }
-                                          
 
 /* Reads a single transform function from the tokenizer stream, reporting an
  * error if something goes wrong.
  */
-PRBool CSSParserImpl::ReadSingleTransform(nsCSSValueList **& aTail)
-{
-  typedef nsTArray<nsCSSValue>::size_type arrlen_t;
-
+PRBool
+CSSParserImpl::ParseSingleTransform(nsCSSValue& aValue)
+{
   if (!GetToken(PR_TRUE))
     return PR_FALSE;
-  
-  /* Check to make sure that we've read a function. */
+
   if (mToken.mType != eCSSToken_Function) {
     UngetToken();
     return PR_FALSE;
   }
 
-  /* Load up the variant mask information for ParseFunction.  If we can't,
-   * abort.
-   */
   const PRInt32* variantMask;
   PRUint16 minElems, maxElems;
   if (!GetFunctionParseInformation(nsCSSKeywords::LookupKeyword(mToken.mIdent),
                                    minElems, maxElems, variantMask))
     return PR_FALSE;
 
-  /* Create a cell to populate, fail if we're out of memory. */
-  nsAutoPtr<nsCSSValue> newCell(new nsCSSValue);
-  if (!newCell) {
-    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-    return PR_FALSE;
-  }
-
-  /* Try reading things in, failing if we can't */
-  if (!ParseFunction(mToken.mIdent, variantMask, minElems, maxElems, *newCell))
-    return PR_FALSE;
-
-  /* Wrap up our result in an nsCSSValueList cell. */
-  nsAutoPtr<nsCSSValueList> toAppend(new nsCSSValueList);
-  if (!toAppend)
-    return PR_FALSE;
-
-  toAppend->mValue = *newCell;
-  
-  /* Chain the element to the end of the transform list, then update the
-   * list.
-   */
-  *aTail = toAppend.forget();
-  aTail = &(*aTail)->mNext;
-  
-  /* It worked!  Return true. */
-  return PR_TRUE;
+  return ParseFunction(mToken.mIdent, variantMask, minElems, maxElems, aValue);
 }
 
 /* Parses a -moz-transform property list by continuously reading in properties
  * and constructing a matrix from it.
  */
 PRBool CSSParserImpl::ParseMozTransform()
 {
-  mTempData.mDisplay.mTransform = nsnull;
- 
-  /* First, check to see if this is some sort of keyword - none, inherit,
-   * or initial.
-   */
-  nsCSSValue keywordValue;
-  if (ParseVariant(keywordValue, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
-    /* Looks like it is.  Make a new value list and fill it in, failing if
-     * we can't.
-     */
-    mTempData.mDisplay.mTransform = new nsCSSValueList;
-    if (!mTempData.mDisplay.mTransform) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
+    // 'inherit', 'initial', and 'none' must be alone
+    if (!ExpectEndProperty()) {
       return PR_FALSE;
     }
-
-    /* Inform the parser that everything worked. */
-    mTempData.mDisplay.mTransform->mValue = keywordValue;
-    mTempData.SetPropertyBit(eCSSProperty__moz_transform);
-    return PR_TRUE;
-  }
-  
-  /* We will read a nonempty list of transforms.  Thus we'll read in a
-   * transform, then continuously read transforms until we're no longer
-   * able to do so.
-   */
-  nsCSSValueList *transformList = nsnull;
-  nsCSSValueList **tail = &transformList;
-  do {
-    /* Try reading a transform.  If we fail to do so, abort. */
-    if (!ReadSingleTransform(tail)) {
-      delete transformList;
-      return PR_FALSE;
-    }
-  }
-  while (!CheckEndProperty());
-
-  /* Confirm that this is the end of the property and set error code
-   * appropriately otherwise.
-   */
-  if (!ExpectEndProperty()) {
-    delete transformList;
-    return PR_FALSE;
-  }
-  
-  /* Validate our data. */
-  NS_ASSERTION(transformList, "Didn't read any transforms!");
-  
-  mTempData.SetPropertyBit(eCSSProperty__moz_transform);
-  mTempData.mDisplay.mTransform = transformList;
-
+  } else {
+    nsCSSValueList* cur = value.SetListValue();
+    for (;;) {
+      if (!ParseSingleTransform(cur->mValue)) {
+        return PR_FALSE;
+      }
+      if (CheckEndProperty()) {
+        break;
+      }
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(eCSSProperty__moz_transform, value);
   return PR_TRUE;
 }
 
 PRBool CSSParserImpl::ParseMozTransformOrigin()
 {
   nsCSSValuePair position;
   if (!ParseBoxPositionValues(position, PR_TRUE) || !ExpectEndProperty())
     return PR_FALSE;
@@ -8628,17 +8455,17 @@ CSSParserImpl::ParseQuotes()
       }
       if (CheckEndProperty()) {
         break;
       }
       // look for another open
       if (!ParseVariant(open, VARIANT_STRING, nsnull)) {
         return PR_FALSE;
       }
-      quotes->mNext = new nsCSSValuePairList();
+      quotes->mNext = new nsCSSValuePairList;
       quotes = quotes->mNext;
     }
   }
   AppendValue(eCSSProperty_quotes, value);
   return PR_TRUE;
 }
 
 PRBool
@@ -8696,166 +8523,116 @@ CSSParserImpl::ParseTextDecoration(nsCSS
   }
   return PR_FALSE;
 }
 
 
 PRBool
 CSSParserImpl::ParseTransitionTime(nsCSSProperty aPropID)
 {
-  NS_ABORT_IF_FALSE(aPropID == eCSSProperty_transition_duration ||
-                    aPropID == eCSSProperty_transition_delay,
-                    "Invalid property");
-  nsCSSValueList** storage =
-    aPropID == eCSSProperty_transition_duration
-      ? &mTempData.mDisplay.mTransitionDuration
-      : &mTempData.mDisplay.mTransitionDelay;
-
-  nsCSSValue timeval;
-  // first see if 'inherit' or '-moz-initial' is specified.  If one is,
-  // it can be the only thing specified, so don't attempt to parse any
-  // additional properties
-  if (ParseVariant(timeval, VARIANT_INHERIT, nsnull)) {
-    nsCSSValueList* list = new nsCSSValueList();
-    if (!list) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
+    // 'inherit' and 'initial' must be alone
+    if (!ExpectEndProperty()) {
       return PR_FALSE;
     }
-    list->mValue = timeval;
-    mTempData.SetPropertyBit(aPropID);
-    *storage = list;
-    return PR_TRUE;
-  }
-
-  // now try to parse normal time values
-  nsCSSValueList *listHead = nsnull;
-  nsCSSValueList **next = &listHead;
-
-  for (;;) {
-    if (!ParseVariant(timeval, VARIANT_TIME, nsnull)) {
-      break;
-    }
-    if (!AppendValueToList(next, timeval)) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    if (CheckEndProperty()) {
-      mTempData.SetPropertyBit(aPropID);
-      *storage = listHead;
-      return PR_TRUE;
-    }
-    if (!ExpectSymbol(',', PR_TRUE)) {
-      break;
-    }
-  }
-  delete listHead;
-  return PR_FALSE;
+  } else {
+    nsCSSValueList* cur = value.SetListValue();
+    for (;;) {
+      if (!ParseVariant(cur->mValue, VARIANT_TIME, nsnull)) {
+        return PR_FALSE;
+      }
+      if (CheckEndProperty()) {
+        break;
+      }
+      if (!ExpectSymbol(',', PR_TRUE)) {
+        return PR_FALSE;
+      }
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(aPropID, value);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseTransitionProperty()
 {
   nsCSSValue value;
-  // first see if 'inherit', '-moz-initial', 'none', or 'all' is
-  // specified.  If one is, it can be the only thing specified, so don't
-  // attempt to parse any additional properties
   if (ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE | VARIANT_ALL,
                    nsnull)) {
-    nsCSSValueList* list = new nsCSSValueList();
-    if (!list) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+    // 'inherit', 'initial', 'none', and 'all' must be alone
+    if (!ExpectEndProperty()) {
       return PR_FALSE;
     }
-    list->mValue = value;
-    mTempData.SetPropertyBit(eCSSProperty_transition_property);
-    mTempData.mDisplay.mTransitionProperty = list;
-    return PR_TRUE;
-  }
-
-  // Accept a list of arbitrary identifiers.  They should be CSS
-  // properties, but we want to accept any so that we accept properties
-  // that we don't know about yet, e.g.
-  // transition-property: invalid-property, left, opacity;
-  nsCSSValueList *listHead = nsnull;
-  nsCSSValueList **next = &listHead;
-
-  for (;;) {
-    if (!ParseVariant(value, VARIANT_IDENTIFIER, nsnull)) {
-      break;
-    }
-    // Exclude 'none' and 'all' and 'inherit' and 'initial' according to
-    // the same rules as for 'counter-reset' in CSS 2.1 (except
-    // 'counter-reset' doesn't exclude 'all' since it doesn't support
-    // 'all' as a special value).
-    nsDependentString str(value.GetStringBufferValue());
-    if (str.EqualsLiteral("none") || str.EqualsLiteral("all") ||
-        str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {
-      break;
-    }
-
-    if (!AppendValueToList(next, value)) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    if (CheckEndProperty()) {
-      mTempData.SetPropertyBit(eCSSProperty_transition_property);
-      mTempData.mDisplay.mTransitionProperty = listHead;
-      return PR_TRUE;
-    }
-    if (!ExpectSymbol(',', PR_TRUE)) {
-      break;
-    }
-  }
-  delete listHead;
-  return PR_FALSE;
+  } else {
+    // Accept a list of arbitrary identifiers.  They should be
+    // CSS properties, but we want to accept any so that we
+    // accept properties that we don't know about yet, e.g.
+    // transition-property: invalid-property, left, opacity;
+    nsCSSValueList* cur = value.SetListValue();
+    for (;;) {
+      if (!ParseVariant(cur->mValue, VARIANT_IDENTIFIER, nsnull)) {
+        return PR_FALSE;
+      }
+      nsDependentString str(cur->mValue.GetStringBufferValue());
+      // Exclude 'none' and 'all' and 'inherit' and 'initial'
+      // according to the same rules as for 'counter-reset' in CSS 2.1
+      // (except 'counter-reset' doesn't exclude 'all' since it
+      // doesn't support 'all' as a special value).
+      if (str.LowerCaseEqualsLiteral("none") ||
+          str.LowerCaseEqualsLiteral("all") ||
+          str.LowerCaseEqualsLiteral("inherit") ||
+          str.LowerCaseEqualsLiteral("initial")) {
+        return PR_FALSE;
+      }
+      if (CheckEndProperty()) {
+        break;
+      }
+      if (!ExpectSymbol(',', PR_TRUE)) {
+        REPORT_UNEXPECTED_TOKEN(PEExpectedComma);
+        return PR_FALSE;
+      }
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_transition_property, value);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseTransitionTimingFunction()
 {
-  nsCSSValue timeFunction;
-  // first see if 'inherit' or '-moz-initial' is specified.  If one is,
-  // it can be the only thing specified, so don't attempt to parse any
-  // additional properties
-  if (ParseVariant(timeFunction, VARIANT_INHERIT, nsnull)) {
-    nsCSSValueList* list = new nsCSSValueList();
-    if (!list) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT, nsnull)) {
+    // 'inherit' and 'initial' must be alone
+    if (!ExpectEndProperty()) {
       return PR_FALSE;
     }
-    list->mValue = timeFunction;
-    mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
-    mTempData.mDisplay.mTransitionTimingFunction = list;
-    return PR_TRUE;
-  }
-
-  nsCSSValueList *listHead = nsnull;
-  nsCSSValueList **next = &listHead;
-
-  for (;;) {
-    if (!ParseVariant(timeFunction, VARIANT_TIMING_FUNCTION,
-                      nsCSSProps::kTransitionTimingFunctionKTable)) {
-      break;
-    }
-    if (!AppendValueToList(next, timeFunction)) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-    if (CheckEndProperty()) {
-      mTempData.SetPropertyBit(eCSSProperty_transition_timing_function);
-      mTempData.mDisplay.mTransitionTimingFunction = listHead;
-      return PR_TRUE;
-    }
-    if (!ExpectSymbol (',', PR_TRUE)) {
-      break;
-    }
-  }
-
-  delete listHead;
-  return PR_FALSE;
+  } else {
+    nsCSSValueList* cur = value.SetListValue();
+    for (;;) {
+      if (!ParseVariant(cur->mValue, VARIANT_TIMING_FUNCTION,
+                        nsCSSProps::kTransitionTimingFunctionKTable)) {
+        return PR_FALSE;
+      }
+      if (CheckEndProperty()) {
+        break;
+      }
+      if (!ExpectSymbol(',', PR_TRUE)) {
+        return PR_FALSE;
+      }
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_transition_timing_function, value);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseTransitionTimingFunctionValues(nsCSSValue& aValue)
 {
   NS_ASSERTION(!mHavePushBack &&
                mToken.mType == eCSSToken_Function &&
                mToken.mIdent.LowerCaseEqualsLiteral("cubic-bezier"),
@@ -8902,30 +8679,33 @@ CSSParserImpl::ParseTransitionTimingFunc
     aComponent = num;
     if (ExpectSymbol(aStop, PR_TRUE)) {
       return PR_TRUE;
     }
   }
   return PR_FALSE;
 }
 
-PRBool
-CSSParserImpl::AppendValueToList(nsCSSValueList**& aListTail,
-                                 const nsCSSValue& aValue)
-{
-  NS_ABORT_IF_FALSE(!*aListTail, "should not have a next entry");
-  nsCSSValueList *entry = new nsCSSValueList();
-  if (!entry) {
-    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-    return PR_FALSE;
+static nsCSSValueList*
+AppendValueToList(nsCSSValue& aContainer,
+                  nsCSSValueList* aTail,
+                  const nsCSSValue& aValue)
+{
+  nsCSSValueList* entry;
+  if (aContainer.GetUnit() == eCSSUnit_Null) {
+    NS_ABORT_IF_FALSE(!aTail, "should not have an entry");
+    entry = aContainer.SetListValue();
+  } else {
+    NS_ABORT_IF_FALSE(!aTail->mNext, "should not have a next entry");
+    NS_ABORT_IF_FALSE(aContainer.GetUnit() == eCSSUnit_List, "not a list");
+    entry = new nsCSSValueList;
+    aTail->mNext = entry;
   }
   entry->mValue = aValue;
-  *aListTail = entry;
-  aListTail = &entry->mNext;
-  return PR_TRUE;
+  return entry;
 }
 
 PRBool
 CSSParserImpl::ParseTransition()
 {
   static const nsCSSProperty kTransitionProperties[] = {
     eCSSProperty_transition_duration,
     eCSSProperty_transition_timing_function,
@@ -8945,34 +8725,23 @@ CSSParserImpl::ParseTransition()
   // there can be multiple transitions, separated with commas
 
   nsCSSValue tempValue;
   // first see if 'inherit' or '-moz-initial' is specified.  If one is,
   // it can be the only thing specified, so don't attempt to parse any
   // additional properties
   if (ParseVariant(tempValue, VARIANT_INHERIT, nsnull)) {
     for (PRUint32 i = 0; i < numProps; ++i) {
-      nsCSSValueList* list = new nsCSSValueList();
-      if (!list) {
-        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-        return PR_FALSE;
-      }
-      list->mValue = tempValue;
-      nsCSSProperty prop = kTransitionProperties[i];
-      *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) = list;
-      mTempData.SetPropertyBit(prop);
+      AppendValue(kTransitionProperties[i], tempValue);
     }
     return PR_TRUE;
   }
 
-  nsAutoPtr<nsCSSValueList> values[numProps];
-  nsCSSValueList **tails[numProps] = { getter_Transfers(values[0]),
-                                       getter_Transfers(values[1]),
-                                       getter_Transfers(values[2]),
-                                       getter_Transfers(values[3]) };
+  nsCSSValue values[numProps];
+  nsCSSValueList *cur[numProps] = { nsnull, nsnull, nsnull, nsnull };
   PRBool atEOP = PR_FALSE; // at end of property?
   for (;;) { // loop over comma-separated transitions
     // whether a particular subproperty was specified for this transition
     PRBool parsedProperty[numProps] =
       { PR_FALSE, PR_FALSE, PR_FALSE, PR_FALSE };
     for (;;) { // loop over values within a transition
       PRBool foundProperty = PR_FALSE;
       // check to see if we're at the end of one full transition definition
@@ -9003,19 +8772,17 @@ CSSParserImpl::ParseTransition()
               variantMask = VARIANT_TIMING_FUNCTION;
               table = nsCSSProps::kTransitionTimingFunctionKTable;
               break;
             default:
               NS_ABORT_IF_FALSE(PR_FALSE, "Invalid transition property");
           }
           if (ParseVariant(tempValue, variantMask, table)) {
             parsedProperty[i] = PR_TRUE;
-            if (!AppendValueToList(tails[i], tempValue)) {
-              return PR_FALSE;
-            }
+            cur[i] = AppendValueToList(values[i], cur[i], tempValue);
             foundProperty = PR_TRUE;
             break; // out of inner loop; continue looking for next sub-property
           }
         }
       }
       if (!foundProperty) {
         // We're not at a ',' or at the end of the property, but we couldn't
         // parse any of the sub-properties, so the declaration is invalid.
@@ -9039,19 +8806,17 @@ CSSParserImpl::ParseTransition()
             break;
           case eCSSProperty_transition_timing_function:
             tempValue.SetIntValue(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE,
                                   eCSSUnit_Enumerated);
             break;
           default:
             NS_ABORT_IF_FALSE(PR_FALSE, "Invalid transition property");
         }
-        if (!AppendValueToList(tails[i], tempValue)) {
-          return PR_FALSE;
-        }
+        cur[i] = AppendValueToList(values[i], cur[i], tempValue);
       }
     }
 
     if (atEOP)
       break;
     // else we just hit a ',' so continue parsing the next compound transition
   }
 
@@ -9060,197 +8825,161 @@ CSSParserImpl::ParseTransition()
   //     'none' or 'all'.
   //   + None of the items can be 'inherit' or 'initial' (this is the case,
   //     like with counter-reset &c., where CSS 2.1 specifies 'initial', so
   //     we should check it without the -moz- prefix).
   {
     NS_ABORT_IF_FALSE(kTransitionProperties[3] ==
                         eCSSProperty_transition_property,
                       "array index mismatch");
-    nsCSSValueList *l = values[3];
+    nsCSSValueList *l = values[3].GetListValue();
     PRBool multipleItems = !!l->mNext;
     do {
       const nsCSSValue& val = l->mValue;
       if (val.GetUnit() != eCSSUnit_Ident) {
         NS_ABORT_IF_FALSE(val.GetUnit() == eCSSUnit_None ||
                           val.GetUnit() == eCSSUnit_All, "unexpected unit");
         if (multipleItems) {
           // This is a syntax error.
           return PR_FALSE;
         }
-        continue;
+
+        // Unbox a solitary 'none' or 'all'.
+        if (val.GetUnit() == eCSSUnit_None) {
+          values[3].SetNoneValue();
+        } else {
+          values[3].SetAllValue();
+        }
+        break;
       }
       nsDependentString str(val.GetStringBufferValue());
       if (str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {
         return PR_FALSE;
       }
     } while ((l = l->mNext));
   }
 
   // Save all parsed transition sub-properties in mTempData
   for (PRUint32 i = 0; i < numProps; ++i) {
-    nsCSSProperty prop = kTransitionProperties[i];
-    *static_cast<nsCSSValueList**>(mTempData.PropertyAt(prop)) =
-      values[i].forget();
-    mTempData.SetPropertyBit(prop);
+    AppendValue(kTransitionProperties[i], values[i]);
   }
   return PR_TRUE;
 }
 
-nsCSSValueList*
-CSSParserImpl::ParseCSSShadowList(PRBool aIsBoxShadow)
-{
-  nsAutoParseCompoundProperty compound(this);
-
-  // Parses x, y, radius, color (in two possible orders)
-  // This parses the input into a list. Either it contains just a "none" or
-  // "inherit" value, or a list of arrays.
-  // The resulting arrays will always contain the above order, with color and
-  // radius as null values as needed
+PRBool
+CSSParserImpl::ParseShadowItem(nsCSSValue& aValue, PRBool aIsBoxShadow)
+{
+  // A shadow list item is an array, with entries in this sequence:
   enum {
     IndexX,
     IndexY,
     IndexRadius,
-    IndexSpread,
+    IndexSpread,  // only for box-shadow
     IndexColor,
-    IndexInset
+    IndexInset    // only for box-shadow
   };
 
-  nsCSSValueList *list = nsnull;
-  for (nsCSSValueList **curp = &list, *cur; ; curp = &cur->mNext) {
-    cur = *curp = new nsCSSValueList();
-    if (!cur) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-      break;
-    }
-
-    nsCSSValue isInset;
-    if (aIsBoxShadow) {
-      // Optional inset keyword (ignore errors)
-      ParseVariant(isInset, VARIANT_KEYWORD,
-                   nsCSSProps::kBoxShadowTypeKTable);
-    }
-
-    PRBool isFirstToken = (cur == list && isInset.GetUnit() == eCSSUnit_Null);
-    if (!ParseVariant(cur->mValue,
-                      ( isFirstToken ? VARIANT_INHERIT | VARIANT_NONE : 0) |
-                      VARIANT_COLOR | VARIANT_LENGTH | VARIANT_CALC,
+  nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(6);
+
+  if (aIsBoxShadow) {
+    // Optional inset keyword (ignore errors)
+    ParseVariant(val->Item(IndexInset), VARIANT_KEYWORD,
+                 nsCSSProps::kBoxShadowTypeKTable);
+  }
+
+  nsCSSValue xOrColor;
+  PRBool haveColor = PR_FALSE;
+  if (!ParseVariant(xOrColor, VARIANT_COLOR | VARIANT_LENGTH | VARIANT_CALC,
+                    nsnull)) {
+    return PR_FALSE;
+  }
+  if (xOrColor.IsLengthUnit() || xOrColor.IsCalcUnit()) {
+    val->Item(IndexX) = xOrColor;
+  } else {
+    // Must be a color (as string or color value)
+    NS_ASSERTION(xOrColor.GetUnit() == eCSSUnit_Ident ||
+                 xOrColor.GetUnit() == eCSSUnit_Color ||
+                 xOrColor.GetUnit() == eCSSUnit_EnumColor,
+                 "Must be a color value");
+    val->Item(IndexColor) = xOrColor;
+    haveColor = PR_TRUE;
+
+    // X coordinate mandatory after color
+    if (!ParseVariant(val->Item(IndexX), VARIANT_LENGTH | VARIANT_CALC,
                       nsnull)) {
-      break;
-    }
-
-    nsCSSUnit unit = cur->mValue.GetUnit();
-    if (unit != eCSSUnit_None && unit != eCSSUnit_Inherit &&
-        unit != eCSSUnit_Initial) {
-      nsRefPtr<nsCSSValue::Array> val = nsCSSValue::Array::Create(6);
-      if (!val) {
-        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+      return PR_FALSE;
+    }
+  }
+
+  // Y coordinate; mandatory
+  if (!ParseVariant(val->Item(IndexY), VARIANT_LENGTH | VARIANT_CALC,
+                    nsnull)) {
+    return PR_FALSE;
+  }
+
+  // Optional radius. Ignore errors except if they pass a negative
+  // value which we must reject. If we use ParseNonNegativeVariant
+  // we can't tell the difference between an unspecified radius
+  // and a negative radius.
+  if (ParseVariant(val->Item(IndexRadius), VARIANT_LENGTH | VARIANT_CALC,
+                   nsnull) &&
+      val->Item(IndexRadius).IsLengthUnit() &&
+      val->Item(IndexRadius).GetFloatValue() < 0) {
+    return PR_FALSE;
+  }
+
+  if (aIsBoxShadow) {
+    // Optional spread
+    ParseVariant(val->Item(IndexSpread), VARIANT_LENGTH | VARIANT_CALC, nsnull);
+  }
+
+  if (!haveColor) {
+    // Optional color
+    ParseVariant(val->Item(IndexColor), VARIANT_COLOR, nsnull);
+  }
+
+  if (aIsBoxShadow && val->Item(IndexInset).GetUnit() == eCSSUnit_Null) {
+    // Optional inset keyword
+    ParseVariant(val->Item(IndexInset), VARIANT_KEYWORD,
+                 nsCSSProps::kBoxShadowTypeKTable);
+  }
+
+  aValue.SetArrayValue(val, eCSSUnit_Array);
+  return PR_TRUE;
+}
+
+PRBool
+CSSParserImpl::ParseShadowList(nsCSSProperty aProperty)
+{
+  nsAutoParseCompoundProperty compound(this);
+  PRBool isBoxShadow = aProperty == eCSSProperty_box_shadow;
+
+  nsCSSValue value;
+  if (ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
+    // 'inherit', 'initial', and 'none' must be alone
+    if (!ExpectEndProperty()) {
+      return PR_FALSE;
+    }
+  } else {
+    nsCSSValueList* cur = value.SetListValue();
+    for (;;) {
+      if (!ParseShadowItem(cur->mValue, isBoxShadow)) {
+        return PR_FALSE;
+      }
+      if (CheckEndProperty()) {
         break;
       }
-      PRBool haveColor = PR_FALSE;
-      if (cur->mValue.IsLengthUnit() || cur->mValue.IsCalcUnit()) {
-        val->Item(IndexX) = cur->mValue;
-      } else {
-        // Must be a color (as string or color value)
-        NS_ASSERTION(unit == eCSSUnit_Ident || unit == eCSSUnit_Color ||
-                     unit == eCSSUnit_EnumColor,
-                     "Must be a color value (named color, numeric color, "
-                     "or system color)");
-        haveColor = PR_TRUE;
-        val->Item(IndexColor) = cur->mValue;
-
-        // Parse the X coordinate
-        if (!ParseVariant(val->Item(IndexX), VARIANT_LENGTH | VARIANT_CALC,
-                          nsnull)) {
-          break;
-        }
-      }
-      cur->mValue.SetArrayValue(val, eCSSUnit_Array);
-
-      // Y coordinate; this one is not optional
-      if (!ParseVariant(val->Item(IndexY), VARIANT_LENGTH | VARIANT_CALC,
-                        nsnull)) {
-        break;
-      }
-
-      // Optional radius. Ignore errors except if they pass a negative
-      // value which we must reject. If we use ParseNonNegativeVariant we can't
-      // tell the difference between an unspecified radius and a negative
-      // radius, so that's why we don't use it.
-      if (ParseVariant(val->Item(IndexRadius), VARIANT_LENGTH | VARIANT_CALC,
-                       nsnull) &&
-          val->Item(IndexRadius).IsLengthUnit() &&
-          val->Item(IndexRadius).GetFloatValue() < 0) {
-        break;
-      }
-
-      if (aIsBoxShadow) {
-        // Optional spread (ignore errors)
-        ParseVariant(val->Item(IndexSpread), VARIANT_LENGTH | VARIANT_CALC,
-                     nsnull);
-      }
-
-      if (!haveColor) {
-        // Optional color (ignore errors)
-        ParseVariant(val->Item(IndexColor), VARIANT_COLOR,
-                     nsnull);
-      }
-
-      if (aIsBoxShadow && isInset.GetUnit() == eCSSUnit_Null) {
-        // Optional inset keyword (ignore errors)
-        ParseVariant(val->Item(IndexInset), VARIANT_KEYWORD,
-                     nsCSSProps::kBoxShadowTypeKTable);
-      } else if (isInset.GetUnit() == eCSSUnit_Enumerated) {
-        val->Item(IndexInset) = isInset;
-      }
-
-      // Might be at a comma now
-      if (ExpectSymbol(',', PR_TRUE)) {
-        // Go to next value
-        continue;
-      }
-    }
-
-    if (!ExpectEndProperty()) {
-      // If we don't have a comma to delimit the next value, we
-      // must be at the end of the property.  Otherwise we've hit
-      // something else, which is an error.
-      break;
-    }
-
-    // Only success case here, since having the failure case at the
-    // end allows more sharing of code.
-    return list;
-  }
-  // Have failure case at the end so we can |break| to get to it.
-  delete list;
-  return nsnull;
-}
-
-PRBool
-CSSParserImpl::ParseTextShadow()
-{
-  nsCSSValueList* list = ParseCSSShadowList(PR_FALSE);
-  if (!list)
-    return PR_FALSE;
-
-  mTempData.SetPropertyBit(eCSSProperty_text_shadow);
-  mTempData.mText.mTextShadow = list;
-  return PR_TRUE;
-}
-
-PRBool
-CSSParserImpl::ParseBoxShadow()
-{
-  nsCSSValueList* list = ParseCSSShadowList(PR_TRUE);
-  if (!list)
-    return PR_FALSE;
-
-  mTempData.SetPropertyBit(eCSSProperty_box_shadow);
-  mTempData.mMargin.mBoxShadow = list;
+      if (!ExpectSymbol(',', PR_TRUE)) {
+        return PR_FALSE;
+      }
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(aProperty, value);
   return PR_TRUE;
 }
 
 PRInt32
 CSSParserImpl::GetNamespaceIdForPrefix(const nsString& aPrefix)
 {
   NS_PRECONDITION(!aPrefix.IsEmpty(), "Must have a prefix here");
 
@@ -9306,58 +9035,41 @@ CSSParserImpl::ParsePaint(nsCSSProperty 
   }
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseDasharray()
 {
   nsCSSValue value;
-  if (ParseVariant(value, VARIANT_HLPN | VARIANT_NONE, nsnull)) {
-    nsCSSValueList *listHead = new nsCSSValueList;
-    nsCSSValueList *list = listHead;
-    if (!list) {
-      mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
+  if (ParseVariant(value, VARIANT_INHERIT | VARIANT_NONE, nsnull)) {
+    // 'inherit', 'initial', and 'none' are only allowed on their own
+    if (!ExpectEndProperty()) {
       return PR_FALSE;
     }
-
-    list->mValue = value;
-
+  } else {
+    nsCSSValueList *cur = value.SetListValue();
     for (;;) {
+      if (!ParseVariant(cur->mValue,
+                        VARIANT_LENGTH | VARIANT_PERCENT | VARIANT_NUMBER,
+                        nsnull)) {
+        return PR_FALSE;
+      }
       if (CheckEndProperty()) {
-        mTempData.SetPropertyBit(eCSSProperty_stroke_dasharray);
-        mTempData.mSVG.mStrokeDasharray = listHead;
-        return PR_TRUE;
-      }
-
-      if (eCSSUnit_Inherit == value.GetUnit() ||
-          eCSSUnit_Initial == value.GetUnit() ||
-          eCSSUnit_None    == value.GetUnit())
         break;
-
+      }
       // skip optional commas between elements
       (void)ExpectSymbol(',', PR_TRUE);
 
-      if (!ParseVariant(value,
-                        VARIANT_LENGTH | VARIANT_PERCENT | VARIANT_NUMBER,
-                        nsnull))
-        break;
-
-      list->mNext = new nsCSSValueList;
-      list = list->mNext;
-      if (list)
-        list->mValue = value;
-      else {
-        mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-        break;
-      }
-    }
-    delete listHead;
-  }
-  return PR_FALSE;
+      cur->mNext = new nsCSSValueList;
+      cur = cur->mNext;
+    }
+  }
+  AppendValue(eCSSProperty_stroke_dasharray, value);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseMarker()
 {
   nsCSSValue marker;
   if (ParseSingleValueProperty(marker, eCSSProperty_marker_end)) {
     if (ExpectEndProperty()) {
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -440,29 +440,29 @@ CSS_PROP_SHORTHAND(
 CSS_PROP_BACKGROUND(
     background-attachment,
     background_attachment,
     BackgroundAttachment,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackAttachment,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kBackgroundAttachmentKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BACKGROUND(
     background-clip,
     background_clip,
     BackgroundClip,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackClip,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kBackgroundOriginKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BACKGROUND(
     background-color,
     background_color,
     BackgroundColor,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
@@ -478,17 +478,17 @@ CSS_PROP_BACKGROUND(
     background_image,
     BackgroundImage,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED |
         CSS_PROPERTY_START_IMAGE_LOADS,
     Color,
     mBackImage,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BACKGROUND(
     -moz-background-inline-policy,
     _moz_background_inline_policy,
     MozBackgroundInlinePolicy,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE,
@@ -501,17 +501,17 @@ CSS_PROP_BACKGROUND(
 CSS_PROP_BACKGROUND(
     background-origin,
     background_origin,
     BackgroundOrigin,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackOrigin,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kBackgroundOriginKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BACKGROUND(
     background-position,
     background_position,
     BackgroundPosition,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
@@ -525,17 +525,17 @@ CSS_PROP_BACKGROUND(
 CSS_PROP_BACKGROUND(
     background-repeat,
     background_repeat,
     BackgroundRepeat,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Color,
     mBackRepeat,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kBackgroundRepeatKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BACKGROUND(
     background-size,
     background_size,
     BackgroundSize,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
@@ -582,17 +582,17 @@ CSS_PROP_BORDER(
 CSS_PROP_BORDER(
     -moz-border-bottom-colors,
     border_bottom_colors,
     MozBorderBottomColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColors.mBottom,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     border-bottom-style,
     border_bottom_style,
     BorderBottomStyle,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
@@ -755,17 +755,17 @@ CSS_PROP_BORDER(
 CSS_PROP_BORDER(
     -moz-border-left-colors,
     border_left_colors,
     MozBorderLeftColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColors.mLeft,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_SHORTHAND(
     border-left-style,
     border_left_style,
     BorderLeftStyle,
     0) // on/off will need reflow
@@ -904,17 +904,17 @@ CSS_PROP_BORDER(
 CSS_PROP_BORDER(
     -moz-border-right-colors,
     border_right_colors,
     MozBorderRightColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColors.mRight,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_SHORTHAND(
     border-right-style,
     border_right_style,
     BorderRightStyle,
     0) // on/off will need reflow
@@ -1094,17 +1094,17 @@ CSS_PROP_BORDER(
 CSS_PROP_BORDER(
     -moz-border-top-colors,
     border_top_colors,
     MozBorderTopColors,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBorderColors.mTop,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_BORDER(
     border-top-style,
     border_top_style,
     BorderTopStyle,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
@@ -1145,17 +1145,17 @@ CSS_PROP_BORDER(
     -moz-box-shadow,
     box_shadow,
     MozBoxShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Margin,
     mBoxShadow,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kBoxShadowTypeKTable,
     offsetof(nsStyleBorder, mBoxShadow),
     eStyleAnimType_Shadow)
 CSS_PROP_POSITION(
     -moz-box-sizing,
     box_sizing,
     MozBoxSizing,
     0,
@@ -1283,17 +1283,17 @@ CSS_PROP_COLUMN(
     eStyleAnimType_Custom)
 CSS_PROP_CONTENT(
     content,
     content,
     Content,
     CSS_PROPERTY_START_IMAGE_LOADS,
     Content,
     mContent,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kContentKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_CONTENT(
     counter-increment,
     counter_increment,
     CounterIncrement,
     0,
@@ -1341,17 +1341,17 @@ CSS_PROP_USERINTERFACE(
     cursor,
     cursor,
     Cursor,
     CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_START_IMAGE_LOADS |
         CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0,
     UserInterface,
     mCursor,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kCursorKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_VISIBILITY(
     direction,
     direction,
     Direction,
     0,
@@ -2349,17 +2349,17 @@ CSS_PROP_TEXT(
     text-shadow,
     text_shadow,
     TextShadow,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE |
         CSS_PROPERTY_VALUE_LIST_USES_COMMAS |
         CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED,
     Text,
     mTextShadow,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleText, mTextShadow),
     eStyleAnimType_Shadow)
 CSS_PROP_TEXT(
     text-transform,
     text_transform,
     TextTransform,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE,
@@ -2371,17 +2371,17 @@ CSS_PROP_TEXT(
     eStyleAnimType_None)
 CSS_PROP_DISPLAY(
     -moz-transform,
     _moz_transform,
     MozTransform,
     0,
     Display,
     mTransform,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kDisplayKTable,
     offsetof(nsStyleDisplay, mSpecifiedTransform),
     eStyleAnimType_Custom)
 CSS_PROP_DISPLAY(
     -moz-transform-origin,
     _moz_transform_origin,
     MozTransformOrigin,
     0,
@@ -2409,50 +2409,50 @@ CSS_PROP_SHORTHAND(
     0)
 CSS_PROP_DISPLAY(
     -moz-transition-delay,
     transition_delay,
     MozTransitionDelay,
     CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Display,
     mTransitionDelay,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_DISPLAY(
     -moz-transition-duration,
     transition_duration,
     MozTransitionDuration,
     CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Display,
     mTransitionDuration,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_DISPLAY(
     -moz-transition-property,
     transition_property,
     MozTransitionProperty,
     CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Display,
     mTransitionProperty,
-    eCSSType_ValueList /* list of CSS properties that have transitions ? */,
+    eCSSType_Value /* list of CSS properties that have transitions ? */,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_DISPLAY(
     -moz-transition-timing-function,
     transition_timing_function,
     MozTransitionTimingFunction,
     CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     Display,
     mTransitionTimingFunction,
-    eCSSType_ValueList,
+    eCSSType_Value,
     kTransitionTimingFunctionKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_TEXTRESET(
     unicode-bidi,
     unicode_bidi,
     UnicodeBidi,
     0,
@@ -2978,17 +2978,17 @@ CSS_PROP_SVG(
     eStyleAnimType_PaintServer)
 CSS_PROP_SVG(
     stroke-dasharray,
     stroke_dasharray,
     StrokeDasharray,
     CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
     SVG,
     mStrokeDasharray,
-    eCSSType_ValueList,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET, /* property stored in 2 separate members */
     eStyleAnimType_Custom)
 CSS_PROP_SVG(
     stroke-dashoffset,
     stroke_dashoffset,
     StrokeDashoffset,
     0,
diff --git a/layout/style/nsCSSProperty.h b/layout/style/nsCSSProperty.h
--- a/layout/style/nsCSSProperty.h
+++ b/layout/style/nsCSSProperty.h
@@ -77,18 +77,17 @@ enum nsCSSProperty {
 
   // Extra dummy values for nsCSSParser internal use.
   eCSSPropertyExtra_x_none_value
 };
 
 // The types of values that can be in the nsCSS*/nsRuleData* structs.
 // See nsCSSPropList.h for uses.
 enum nsCSSType {
-  eCSSType_Value,
-  eCSSType_ValueList
+  eCSSType_Value
 };
 
 // The "descriptors" that can appear in a @font-face rule.
 // They have the syntax of properties but different value rules.
 // Keep in sync with kCSSRawFontDescs in nsCSSProps.cpp and
 // nsCSSFontFaceStyleDecl::Fields in nsCSSRules.cpp.
 enum nsCSSFontDesc {
   eCSSFontDesc_UNKNOWN = -1,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -64,18 +64,20 @@
 #define CSS_PROPERTY_APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE \
   (CSS_PROPERTY_APPLIES_TO_FIRST_LETTER | CSS_PROPERTY_APPLIES_TO_FIRST_LINE)
 
 // Note that 'background-color' is ignored differently from the other
 // properties that have this set, but that's just special-cased.
 #define CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED (1<<4)
 
 // A property that needs to have image loads started when a URL value
-// for the property is used for an element.  Supported only for
-// eCSSType_Value and eCSSType_ValueList.
+// for the property is used for an element.  This is supported only
+// for a few possible value formats: image directly in the value; list
+// of images; and with CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0, image in slot
+// 0 of an array, or list of such arrays.
 #define CSS_PROPERTY_START_IMAGE_LOADS            (1<<5)
 
 // Should be set only for properties with START_IMAGE_LOADS.  Indicates
 // that the property has an array value with a URL/image value at index
 // 0 in the array, rather than the URL/image being in the value or value
 // list.
 #define CSS_PROPERTY_IMAGE_IS_IN_ARRAY_0          (1<<6)
 
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -56,48 +56,35 @@ nsCSSFont::nsCSSFont(void)
 nsCSSFont::~nsCSSFont(void)
 {
   MOZ_COUNT_DTOR(nsCSSFont);
 }
 
 // --- nsCSSColor -----------------
 
 nsCSSColor::nsCSSColor(void)
-  : mBackImage(nsnull)
-  , mBackRepeat(nsnull)
-  , mBackAttachment(nsnull)
-  , mBackClip(nsnull)
-  , mBackOrigin(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSColor);
 }
 
 nsCSSColor::~nsCSSColor(void)
 {
   MOZ_COUNT_DTOR(nsCSSColor);
-
-  delete mBackImage;
-  delete mBackRepeat;
-  delete mBackAttachment;
-  delete mBackClip;
-  delete mBackOrigin;
 }
 
 // --- nsCSSText -----------------
 
 nsCSSText::nsCSSText(void)
-  : mTextShadow(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSText);
 }
 
 nsCSSText::~nsCSSText(void)
 {
   MOZ_COUNT_DTOR(nsCSSText);
-  delete mTextShadow;
 }
 
 // --- nsCSSCornerSizes -----------------
 
 nsCSSCornerSizes::nsCSSCornerSizes(void)
 {
   MOZ_COUNT_CTOR(nsCSSCornerSizes);
 }
@@ -130,78 +117,38 @@ PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT == 0
 /* static */ const nsCSSCornerSizes::corner_type
 nsCSSCornerSizes::corners[4] = {
   &nsCSSCornerSizes::mTopLeft,
   &nsCSSCornerSizes::mTopRight,
   &nsCSSCornerSizes::mBottomRight,
   &nsCSSCornerSizes::mBottomLeft,
 };
 
-// --- nsCSSValueListRect -----------------
-
-nsCSSValueListRect::nsCSSValueListRect(void)
-  : mTop(nsnull),
-    mRight(nsnull),
-    mBottom(nsnull),
-    mLeft(nsnull)
-{
-  MOZ_COUNT_CTOR(nsCSSValueListRect);
-}
-
-nsCSSValueListRect::nsCSSValueListRect(const nsCSSValueListRect& aCopy)
-  : mTop(aCopy.mTop),
-    mRight(aCopy.mRight),
-    mBottom(aCopy.mBottom),
-    mLeft(aCopy.mLeft)
-{
-  MOZ_COUNT_CTOR(nsCSSValueListRect);
-}
-
-nsCSSValueListRect::~nsCSSValueListRect()
-{
-  MOZ_COUNT_DTOR(nsCSSValueListRect);
-}
-
-/* static */ const nsCSSValueListRect::side_type
-nsCSSValueListRect::sides[4] = {
-  &nsCSSValueListRect::mTop,
-  &nsCSSValueListRect::mRight,
-  &nsCSSValueListRect::mBottom,
-  &nsCSSValueListRect::mLeft,
-};
-
 // --- nsCSSDisplay -----------------
 
-/* During allocation, null-out the transform list. */
-nsCSSDisplay::nsCSSDisplay(void) : mTransform(nsnull)
-  , mTransitionProperty(nsnull)
-  , mTransitionDuration(nsnull)
-  , mTransitionTimingFunction(nsnull)
-  , mTransitionDelay(nsnull)
+nsCSSDisplay::nsCSSDisplay(void)
 {
   MOZ_COUNT_CTOR(nsCSSDisplay);
 }
 
 nsCSSDisplay::~nsCSSDisplay(void)
 {
   MOZ_COUNT_DTOR(nsCSSDisplay);
 }
 
 // --- nsCSSMargin -----------------
 
 nsCSSMargin::nsCSSMargin(void)
-  : mBoxShadow(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSMargin);
 }
 
 nsCSSMargin::~nsCSSMargin(void)
 {
   MOZ_COUNT_DTOR(nsCSSMargin);
-  delete mBoxShadow;
 }
 
 // --- nsCSSPosition -----------------
 
 nsCSSPosition::nsCSSPosition(void)
 {
   MOZ_COUNT_CTOR(nsCSSPosition);
 }
@@ -257,39 +204,35 @@ nsCSSPage::nsCSSPage(void)
 nsCSSPage::~nsCSSPage(void)
 {
   MOZ_COUNT_DTOR(nsCSSPage);
 }
 
 // --- nsCSSContent -----------------
 
 nsCSSContent::nsCSSContent(void)
-  : mContent(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSContent);
 }
 
 nsCSSContent::~nsCSSContent(void)
 {
   MOZ_COUNT_DTOR(nsCSSContent);
-  delete mContent;
 }
 
 // --- nsCSSUserInterface -----------------
 
 nsCSSUserInterface::nsCSSUserInterface(void)
-  : mCursor(nsnull)
 {
   MOZ_COUNT_CTOR(nsCSSUserInterface);
 }
 
 nsCSSUserInterface::~nsCSSUserInterface(void)
 {
   MOZ_COUNT_DTOR(nsCSSUserInterface);
-  delete mCursor;
 }
 
 // --- nsCSSAural -----------------
 
 nsCSSAural::nsCSSAural(void)
 {
   MOZ_COUNT_CTOR(nsCSSAural);
 }
@@ -320,18 +263,17 @@ nsCSSColumn::nsCSSColumn(void)
 
 nsCSSColumn::~nsCSSColumn(void)
 {
   MOZ_COUNT_DTOR(nsCSSColumn);
 }
 
 // --- nsCSSSVG -----------------
 
-nsCSSSVG::nsCSSSVG(void) : mStrokeDasharray(nsnull)
+nsCSSSVG::nsCSSSVG(void)
 {
   MOZ_COUNT_CTOR(nsCSSSVG);
 }
 
 nsCSSSVG::~nsCSSSVG(void)
 {
   MOZ_COUNT_DTOR(nsCSSSVG);
-  delete mStrokeDasharray;
 }
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -92,30 +92,16 @@ struct nsCSSCornerSizes {
   nsCSSValue mBottomRight;
   nsCSSValue mBottomLeft;
 
 protected:
   typedef nsCSSValue nsCSSCornerSizes::*corner_type;
   static const corner_type corners[4];
 };
 
-struct nsCSSValueListRect {
-  nsCSSValueListRect(void);
-  nsCSSValueListRect(const nsCSSValueListRect& aCopy);
-  ~nsCSSValueListRect();
-
-  nsCSSValueList* mTop;
-  nsCSSValueList* mRight;
-  nsCSSValueList* mBottom;
-  nsCSSValueList* mLeft;
-
-  typedef nsCSSValueList* nsCSSValueListRect::*side_type;
-  static const side_type sides[4];
-};
-
 /****************************************************************************/
 
 struct nsCSSStruct {
   // EMPTY on purpose.  ABSTRACT with no virtuals (typedef void nsCSSStruct?)
 };
 
 // We use the nsCSS* structures for storing css::Declaration's
 // *temporary* data during parsing and modification.  (They are too big
@@ -159,54 +145,49 @@ struct nsRuleDataFont : public nsCSSFont
 private:
   nsRuleDataFont(const nsRuleDataFont& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSColor : public nsCSSStruct  {
   nsCSSColor(void);
   ~nsCSSColor(void);
 
-  nsCSSValue      mColor;
-  nsCSSValue      mBackColor;
-  nsCSSValueList* mBackImage;
-  nsCSSValueList* mBackRepeat;
-  nsCSSValueList* mBackAttachment;
-  nsCSSValue      mBackPosition;
-  nsCSSValue      mBackSize;
-  nsCSSValueList* mBackClip;
-  nsCSSValueList* mBackOrigin;
-  nsCSSValue      mBackInlinePolicy;
+  nsCSSValue mColor;
+  nsCSSValue mBackColor;
+  nsCSSValue mBackImage;
+  nsCSSValue mBackRepeat;
+  nsCSSValue mBackAttachment;
+  nsCSSValue mBackPosition;
+  nsCSSValue mBackSize;
+  nsCSSValue mBackClip;
+  nsCSSValue mBackOrigin;
+  nsCSSValue mBackInlinePolicy;
 private:
   nsCSSColor(const nsCSSColor& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataColor : public nsCSSColor {
   nsRuleDataColor() {}
-
-  // A little bit of a hack here:  now that background-image is
-  // represented by a value list, attribute mapping code needs a place
-  // to store one item in a value list in order to map a simple value.
-  nsCSSValueList mTempBackImage;
 private:
   nsRuleDataColor(const nsRuleDataColor& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSText : public nsCSSStruct  {
   nsCSSText(void);
   ~nsCSSText(void);
 
   nsCSSValue mTabSize;
   nsCSSValue mWordSpacing;
   nsCSSValue mLetterSpacing;
   nsCSSValue mVerticalAlign;
   nsCSSValue mTextTransform;
   nsCSSValue mTextAlign;
   nsCSSValue mTextIndent;
   nsCSSValue mDecoration;
-  nsCSSValueList* mTextShadow; // NEW
+  nsCSSValue mTextShadow; // NEW
   nsCSSValue mUnicodeBidi;  // NEW
   nsCSSValue mLineHeight;
   nsCSSValue mWhiteSpace;
   nsCSSValue mWordWrap;
 private:
   nsCSSText(const nsCSSText& aOther); // NOT IMPLEMENTED
 };
 
@@ -229,22 +210,22 @@ struct nsCSSDisplay : public nsCSSStruct
   nsCSSValue mClear;
   nsCSSValue mClip;
   nsCSSValue mOverflowX;
   nsCSSValue mOverflowY;
   nsCSSValue mResize;
   nsCSSValue mPointerEvents;
   nsCSSValue mVisibility;
   nsCSSValue mOpacity;
-  nsCSSValueList *mTransform; // List of Arrays containing transform information
+  nsCSSValue mTransform; // List of Arrays containing transform information
   nsCSSValue mTransformOrigin;
-  nsCSSValueList* mTransitionProperty;
-  nsCSSValueList* mTransitionDuration;
-  nsCSSValueList* mTransitionTimingFunction;
-  nsCSSValueList* mTransitionDelay;
+  nsCSSValue mTransitionProperty;
+  nsCSSValue mTransitionDuration;
+  nsCSSValue mTransitionTimingFunction;
+  nsCSSValue mTransitionDelay;
 
   // temp fix for bug 24000 
   nsCSSValue mBreakBefore;
   nsCSSValue mBreakAfter;
   // end temp fix
 private:
   nsCSSDisplay(const nsCSSDisplay& aOther); // NOT IMPLEMENTED
 };
@@ -283,33 +264,33 @@ struct nsCSSMargin : public nsCSSStruct 
   nsCSSValue  mBorderRightWidthRTLSource;
   nsCSSRect   mBorderColor;
   nsCSSValue  mBorderStartColor;
   nsCSSValue  mBorderEndColor;
   nsCSSValue  mBorderLeftColorLTRSource;
   nsCSSValue  mBorderLeftColorRTLSource;
   nsCSSValue  mBorderRightColorLTRSource;
   nsCSSValue  mBorderRightColorRTLSource;
-  nsCSSValueListRect mBorderColors;
+  nsCSSRect   mBorderColors;
   nsCSSRect   mBorderStyle;
   nsCSSValue  mBorderStartStyle;
   nsCSSValue  mBorderEndStyle;
   nsCSSValue  mBorderLeftStyleLTRSource;
   nsCSSValue  mBorderLeftStyleRTLSource;
   nsCSSValue  mBorderRightStyleLTRSource;
   nsCSSValue  mBorderRightStyleRTLSource;
   nsCSSCornerSizes mBorderRadius;
   nsCSSValue  mOutlineWidth;
   nsCSSValue  mOutlineColor;
   nsCSSValue  mOutlineStyle;
   nsCSSValue  mOutlineOffset;
   nsCSSCornerSizes mOutlineRadius;
   nsCSSValue  mFloatEdge; // NEW
   nsCSSValue  mBorderImage;
-  nsCSSValueList* mBoxShadow;
+  nsCSSValue  mBoxShadow;
 private:
   nsCSSMargin(const nsCSSMargin& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataMargin : public nsCSSMargin {
   nsRuleDataMargin() {}
 private:
   nsRuleDataMargin(const nsRuleDataMargin& aOther); // NOT IMPLEMENTED
@@ -414,44 +395,44 @@ struct nsRuleDataPage : public nsCSSPage
 private:
   nsRuleDataPage(const nsRuleDataPage& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSContent : public nsCSSStruct  {
   nsCSSContent(void);
   ~nsCSSContent(void);
 
-  nsCSSValueList*     mContent;
-  nsCSSValue          mCounterIncrement;
-  nsCSSValue          mCounterReset;
-  nsCSSValue          mMarkerOffset;
-  nsCSSValue          mQuotes;
+  nsCSSValue mContent;
+  nsCSSValue mCounterIncrement;
+  nsCSSValue mCounterReset;
+  nsCSSValue mMarkerOffset;
+  nsCSSValue mQuotes;
 private:
   nsCSSContent(const nsCSSContent& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataContent : public nsCSSContent {
   nsRuleDataContent() {}
 private:
   nsRuleDataContent(const nsRuleDataContent& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSUserInterface : public nsCSSStruct  { // NEW
   nsCSSUserInterface(void);
   ~nsCSSUserInterface(void);
 
-  nsCSSValue      mUserInput;
-  nsCSSValue      mUserModify;
-  nsCSSValue      mUserSelect;
-  nsCSSValue      mUserFocus;
-  
-  nsCSSValueList* mCursor;
-  nsCSSValue      mForceBrokenImageIcon;
-  nsCSSValue      mIMEMode;
-  nsCSSValue      mWindowShadow;
+  nsCSSValue mUserInput;
+  nsCSSValue mUserModify;
+  nsCSSValue mUserSelect;
+  nsCSSValue mUserFocus;
+
+  nsCSSValue mCursor;
+  nsCSSValue mForceBrokenImageIcon;
+  nsCSSValue mIMEMode;
+  nsCSSValue mWindowShadow;
 private:
   nsCSSUserInterface(const nsCSSUserInterface& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataUserInterface : public nsCSSUserInterface {
   nsRuleDataUserInterface() {}
 private:
   nsRuleDataUserInterface(const nsRuleDataUserInterface& aOther); // NOT IMPLEMENTED
@@ -549,17 +530,17 @@ struct nsCSSSVG : public nsCSSStruct {
   nsCSSValue mMarkerEnd;
   nsCSSValue mMarkerMid;
   nsCSSValue mMarkerStart;
   nsCSSValue mMask;
   nsCSSValue mShapeRendering;
   nsCSSValue mStopColor;
   nsCSSValue mStopOpacity;
   nsCSSValue mStroke;
-  nsCSSValueList *mStrokeDasharray;
+  nsCSSValue mStrokeDasharray;
   nsCSSValue mStrokeDashoffset;
   nsCSSValue mStrokeLinecap;
   nsCSSValue mStrokeLinejoin;
   nsCSSValue mStrokeMiterlimit;
   nsCSSValue mStrokeOpacity;
   nsCSSValue mStrokeWidth;
   nsCSSValue mTextAnchor;
   nsCSSValue mTextRendering;
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -161,16 +161,23 @@ nsCSSValue::nsCSSValue(const nsCSSValue&
   else if (eCSSUnit_Pair == mUnit) {
     mValue.mPair = aCopy.mValue.mPair;
     mValue.mPair->AddRef();
   }
   else if (eCSSUnit_Rect == mUnit) {
     mValue.mRect = aCopy.mValue.mRect;
     mValue.mRect->AddRef();
   }
+  else if (eCSSUnit_List == mUnit) {
+    mValue.mList = aCopy.mValue.mList;
+    mValue.mList->AddRef();
+  }
+  else if (eCSSUnit_ListDep == mUnit) {
+    mValue.mListDependent = aCopy.mValue.mListDependent;
+  }
   else if (eCSSUnit_PairList == mUnit) {
     mValue.mPairList = aCopy.mValue.mPairList;
     mValue.mPairList->AddRef();
   }
   else if (eCSSUnit_PairListDep == mUnit) {
     mValue.mPairListDependent = aCopy.mValue.mPairListDependent;
   }
   else {
@@ -184,17 +191,19 @@ nsCSSValue& nsCSSValue::operator=(const 
     Reset();
     new (this) nsCSSValue(aCopy);
   }
   return *this;
 }
 
 PRBool nsCSSValue::operator==(const nsCSSValue& aOther) const
 {
-  NS_ABORT_IF_FALSE(mUnit != eCSSUnit_PairListDep &&
+  NS_ABORT_IF_FALSE(mUnit != eCSSUnit_ListDep &&
+                    aOther.mUnit != eCSSUnit_ListDep &&
+                    mUnit != eCSSUnit_PairListDep &&
                     aOther.mUnit != eCSSUnit_PairListDep,
                     "don't use operator== with dependent lists");
 
   if (mUnit == aOther.mUnit) {
     if (mUnit <= eCSSUnit_DummyInherit) {
       return PR_TRUE;
     }
     else if (UnitHasStringValue()) {
@@ -220,16 +229,19 @@ PRBool nsCSSValue::operator==(const nsCS
       return *mValue.mGradient == *aOther.mValue.mGradient;
     }
     else if (eCSSUnit_Pair == mUnit) {
       return *mValue.mPair == *aOther.mValue.mPair;
     }
     else if (eCSSUnit_Rect == mUnit) {
       return *mValue.mRect == *aOther.mValue.mRect;
     }
+    else if (eCSSUnit_List == mUnit) {
+      return *mValue.mList == *aOther.mValue.mList;
+    }
     else if (eCSSUnit_PairList == mUnit) {
       return *mValue.mPairList == *aOther.mValue.mPairList;
     }
     else {
       return mValue.mFloat == aOther.mValue.mFloat;
     }
   }
   return PR_FALSE;
@@ -294,16 +306,18 @@ void nsCSSValue::DoReset()
   } else if (eCSSUnit_Image == mUnit) {
     mValue.mImage->Release();
   } else if (eCSSUnit_Gradient == mUnit) {
     mValue.mGradient->Release();
   } else if (eCSSUnit_Pair == mUnit) {
     mValue.mPair->Release();
   } else if (eCSSUnit_Rect == mUnit) {
     mValue.mRect->Release();
+  } else if (eCSSUnit_List == mUnit) {
+    mValue.mList->Release();
   } else if (eCSSUnit_PairList == mUnit) {
     mValue.mPairList->Release();
   }
   mUnit = eCSSUnit_Null;
 }
 
 void nsCSSValue::SetIntValue(PRInt32 aValue, nsCSSUnit aUnit)
 {
@@ -428,30 +442,50 @@ nsCSSRect& nsCSSValue::SetRectValue()
 {
   Reset();
   mUnit = eCSSUnit_Rect;
   mValue.mRect = new nsCSSRect_heap;
   mValue.mRect->AddRef();
   return *mValue.mRect;
 }
 
+nsCSSValueList* nsCSSValue::SetListValue()
+{
+  Reset();
+  mUnit = eCSSUnit_List;
+  mValue.mList = new nsCSSValueList_heap;
+  mValue.mList->AddRef();
+  return mValue.mList;
+}
+
+void nsCSSValue::SetDependentListValue(nsCSSValueList* aList)
+{
+  Reset();
+  if (aList) {
+    mUnit = eCSSUnit_ListDep;
+    mValue.mListDependent = aList;
+  }
+}
+
 nsCSSValuePairList* nsCSSValue::SetPairListValue()
 {
   Reset();
   mUnit = eCSSUnit_PairList;
   mValue.mPairList = new nsCSSValuePairList_heap;
   mValue.mPairList->AddRef();
   return mValue.mPairList;
 }
 
 void nsCSSValue::SetDependentPairListValue(nsCSSValuePairList* aList)
 {
   Reset();
-  mUnit = eCSSUnit_PairListDep;
-  mValue.mPairListDependent = aList;
+  if (aList) {
+    mUnit = eCSSUnit_PairListDep;
+    mValue.mPairListDependent = aList;
+  }
 }
 
 void nsCSSValue::SetAutoValue()
 {
   Reset();
   mUnit = eCSSUnit_Auto;
 }
 
@@ -919,16 +953,18 @@ nsCSSValue::AppendToString(nsCSSProperty
       aResult.AppendLiteral(", ");
     }
 
     aResult.AppendLiteral(")");
   } else if (eCSSUnit_Pair == unit) {
     GetPairValue().AppendToString(aProperty, aResult);
   } else if (eCSSUnit_Rect == unit) {
     GetRectValue().AppendToString(aProperty, aResult);
+  } else if (eCSSUnit_List == unit || eCSSUnit_ListDep == unit) {
+    GetListValue()->AppendToString(aProperty, aResult);
   } else if (eCSSUnit_PairList == unit || eCSSUnit_PairListDep == unit) {
     GetPairListValue()->AppendToString(aProperty, aResult);
   }
 
   switch (unit) {
     case eCSSUnit_Null:         break;
     case eCSSUnit_Auto:         aResult.AppendLiteral("auto");     break;
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
@@ -968,16 +1004,18 @@ nsCSSValue::AppendToString(nsCSSProperty
     case eCSSUnit_Enumerated:   break;
     case eCSSUnit_EnumColor:    break;
     case eCSSUnit_Color:        break;
     case eCSSUnit_Percent:      aResult.Append(PRUnichar('%'));    break;
     case eCSSUnit_Number:       break;
     case eCSSUnit_Gradient:     break;
     case eCSSUnit_Pair:         break;
     case eCSSUnit_Rect:         break;
+    case eCSSUnit_List:         break;
+    case eCSSUnit_ListDep:      break;
     case eCSSUnit_PairList:     break;
     case eCSSUnit_PairListDep:  break;
 
     case eCSSUnit_Inch:         aResult.AppendLiteral("in");   break;
     case eCSSUnit_Millimeter:   aResult.AppendLiteral("mm");   break;
     case eCSSUnit_PhysicalMillimeter: aResult.AppendLiteral("mozmm");   break;
     case eCSSUnit_Centimeter:   aResult.AppendLiteral("cm");   break;
     case eCSSUnit_Point:        aResult.AppendLiteral("pt");   break;
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -139,16 +139,19 @@ enum nsCSSUnit {
   eCSSUnit_Calc_Maximum = 32,     // (nsCSSValue::Array*) max() within calc
 
   eCSSUnit_URL          = 40,     // (nsCSSValue::URL*) value
   eCSSUnit_Image        = 41,     // (nsCSSValue::Image*) value
   eCSSUnit_Gradient     = 42,     // (nsCSSValueGradient*) value
 
   eCSSUnit_Pair         = 50,     // (nsCSSValuePair*) pair of values
   eCSSUnit_Rect         = 51,     // (nsCSSRect*) rectangle (four values)
+  eCSSUnit_List         = 52,     // (nsCSSValueList*) list of values
+  eCSSUnit_ListDep      = 53,     // (nsCSSValueList*) same as List
+                                  //   but does not own the list
   eCSSUnit_PairList     = 54,     // (nsCSSValuePairList*) list of value pairs
   eCSSUnit_PairListDep  = 55,     // (nsCSSValuePairList*) same as PairList
                                   //   but does not own the list
 
   eCSSUnit_Integer      = 70,     // (int) simple value
   eCSSUnit_Enumerated   = 71,     // (int) value has enumerated meaning
 
   eCSSUnit_EnumColor    = 80,     // (int) enumerated color (kColorKTable)
@@ -189,16 +192,18 @@ enum nsCSSUnit {
   eCSSUnit_Milliseconds = 3001     // (float) 1/1000 second
 };
 
 struct nsCSSValueGradient;
 struct nsCSSValuePair;
 struct nsCSSValuePair_heap;
 struct nsCSSRect;
 struct nsCSSRect_heap;
+struct nsCSSValueList;
+struct nsCSSValueList_heap;
 struct nsCSSValuePairList;
 struct nsCSSValuePairList_heap;
 
 class nsCSSValue {
 public:
   struct Array;
   friend struct Array;
 
@@ -354,16 +359,19 @@ public:
 
   // bodies of these are below
   inline nsCSSValuePair& GetPairValue();
   inline const nsCSSValuePair& GetPairValue() const;
 
   inline nsCSSRect& GetRectValue();
   inline const nsCSSRect& GetRectValue() const;
 
+  inline nsCSSValueList* GetListValue();
+  inline const nsCSSValueList* GetListValue() const;
+
   inline nsCSSValuePairList* GetPairListValue();
   inline const nsCSSValuePairList* GetPairListValue() const;
 
   URL* GetURLStructValue() const
   {
     // Not allowing this for Image values, because if the caller takes
     // a ref to them they won't be able to delete them properly.
     NS_ASSERTION(mUnit == eCSSUnit_URL, "not a URL value");
@@ -402,30 +410,32 @@ public:
   void SetStringValue(const nsString& aValue, nsCSSUnit aUnit);
   void SetColorValue(nscolor aValue);
   void SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
   void SetURLValue(nsCSSValue::URL* aURI);
   void SetImageValue(nsCSSValue::Image* aImage);
   void SetGradientValue(nsCSSValueGradient* aGradient);
   void SetPairValue(const nsCSSValuePair* aPair);
   void SetPairValue(const nsCSSValue& xValue, const nsCSSValue& yValue);
+  void SetDependentListValue(nsCSSValueList* aList);
   void SetDependentPairListValue(nsCSSValuePairList* aList);
   void SetAutoValue();
   void SetInheritValue();
   void SetInitialValue();
   void SetNoneValue();
   void SetAllValue();
   void SetNormalValue();
   void SetSystemFontValue();
   void SetDummyValue();
   void SetDummyInheritValue();
 
   // These are a little different - they allocate storage for you and
   // return a handle.
   nsCSSRect& SetRectValue();
+  nsCSSValueList* SetListValue();
   nsCSSValuePairList* SetPairListValue();
 
   void StartImageLoad(nsIDocument* aDocument) const;  // Only pretend const
 
   // Initializes as a function value with the specified function id.
   Array* InitFunction(nsCSSKeyword aFunctionId, PRUint32 aNumArgs);
   // Checks if this is a function value with the specified function id.
   PRBool EqualsFunction(nsCSSKeyword aFunctionId) const;
@@ -502,16 +512,18 @@ protected:
     nsStringBuffer* mString;
     nscolor    mColor;
     Array*     mArray;
     URL*       mURL;
     Image*     mImage;
     nsCSSValueGradient* mGradient;
     nsCSSValuePair_heap* mPair;
     nsCSSRect_heap* mRect;
+    nsCSSValueList_heap* mList;
+    nsCSSValueList* mListDependent;
     nsCSSValuePairList_heap* mPairList;
     nsCSSValuePairList* mPairListDependent;
   }         mValue;
 };
 
 struct nsCSSValue::Array {
 
   // return |Array| with reference count of zero
@@ -633,16 +645,47 @@ struct nsCSSValueList {
 private:
   nsCSSValueList(const nsCSSValueList& aCopy) // makes a shallow copy
     : mValue(aCopy.mValue), mNext(nsnull)
   {
     MOZ_COUNT_CTOR(nsCSSValueList);
   }
 };
 
+// nsCSSValueList_heap differs from nsCSSValueList only in being
+// refcounted.  It should not be necessary to use this class directly;
+// it's an implementation detail of nsCSSValue.
+struct nsCSSValueList_heap : public nsCSSValueList {
+  NS_INLINE_DECL_REFCOUNTING(nsCSSValueList_heap)
+};
+
+// This has to be here so that the relationship between nsCSSValueList
+// and nsCSSValueList_heap is visible.
+inline nsCSSValueList*
+nsCSSValue::GetListValue()
+{
+  if (mUnit == eCSSUnit_List)
+    return mValue.mList;
+  else {
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_ListDep, "not a pairlist value");
+    return mValue.mListDependent;
+  }
+}
+
+inline const nsCSSValueList*
+nsCSSValue::GetListValue() const
+{
+  if (mUnit == eCSSUnit_List)
+    return mValue.mList;
+  else {
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_ListDep, "not a pairlist value");
+    return mValue.mListDependent;
+  }
+}
+
 struct nsCSSRect {
   nsCSSRect(void);
   nsCSSRect(const nsCSSRect& aCopy);
   ~nsCSSRect();
 
   void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
 
   PRBool operator==(const nsCSSRect& aOther) const {
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -75,16 +75,17 @@
 #include "nsStyleStructInlines.h"
 #include "nsStyleTransformMatrix.h"
 #include "nsCSSKeywords.h"
 #include "nsCSSProps.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "mozilla/dom/Element.h"
 #include "CSSCalc.h"
+#include "nsPrintfCString.h"
 
 using namespace mozilla::dom;
 namespace css = mozilla::css;
 
 #define NS_SET_IMAGE_REQUEST(method_, context_, request_)                   \
   if ((context_)->PresContext()->IsDynamic()) {                               \
     method_(request_);                                                      \
   } else {                                                                  \
@@ -1738,30 +1739,16 @@ nsRuleNode::CheckSpecifiedProperties(con
     switch (prop->type) {
 
       case eCSSType_Value:
         ++total;
         ExamineCSSValue(ValueAtOffset(aRuleDataStruct, prop->offset),
                         specified, inherited);
         break;
 
-      case eCSSType_ValueList:
-        {
-          ++total;
-          const nsCSSValueList* valueList =
-              ValueListAtOffset(aRuleDataStruct, prop->offset);
-          if (valueList) {
-            ++specified;
-            if (eCSSUnit_Inherit == valueList->mValue.GetUnit()) {
-              ++inherited;
-            }
-          }
-        }
-        break;
-
       default:
         NS_NOTREACHED("unknown type");
         break;
 
     }
 
 #if 0
   printf("CheckSpecifiedProperties: SID=%d total=%d spec=%d inh=%d.\n",
@@ -1837,19 +1824,17 @@ nsRuleNode::GetVisibilityData(nsStyleCon
 
 const void*
 nsRuleNode::GetTextData(nsStyleContext* aContext)
 {
   nsRuleDataText textData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Text), mPresContext, aContext);
   ruleData.mTextData = &textData;
 
-  const void* res = WalkRuleTree(eStyleStruct_Text, aContext, &ruleData, &textData);
-  textData.mTextShadow = nsnull; // We are sharing with some style rule.  It really owns the data.
-  return res;
+  return WalkRuleTree(eStyleStruct_Text, aContext, &ruleData, &textData);
 }
 
 const void*
 nsRuleNode::GetTextResetData(nsStyleContext* aContext)
 {
   nsRuleDataText textData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(TextReset), mPresContext, aContext);
   ruleData.mTextData = &textData;
@@ -1859,19 +1844,17 @@ nsRuleNode::GetTextResetData(nsStyleCont
 
 const void*
 nsRuleNode::GetUserInterfaceData(nsStyleContext* aContext)
 {
   nsRuleDataUserInterface uiData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(UserInterface), mPresContext, aContext);
   ruleData.mUserInterfaceData = &uiData;
 
-  const void* res = WalkRuleTree(eStyleStruct_UserInterface, aContext, &ruleData, &uiData);
-  uiData.mCursor = nsnull; // We are sharing with some style rule.  It really owns the data.
-  return res;
+  return WalkRuleTree(eStyleStruct_UserInterface, aContext, &ruleData, &uiData);
 }
 
 const void*
 nsRuleNode::GetUIResetData(nsStyleContext* aContext)
 {
   nsRuleDataUserInterface uiData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(UIReset), mPresContext, aContext);
   ruleData.mUserInterfaceData = &uiData;
@@ -1901,30 +1884,17 @@ nsRuleNode::GetColorData(nsStyleContext*
 
 const void*
 nsRuleNode::GetBackgroundData(nsStyleContext* aContext)
 {
   nsRuleDataColor colorData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Background), mPresContext, aContext);
   ruleData.mColorData = &colorData;
 
-  // If any members need to be set to null here, they must also be set to
-  // null in HasAuthorSpecifiedRules (look at mBoxShadow in GetBorderData
-  // and HasAuthorSpecifiedRules).
-
-  const void *res = WalkRuleTree(eStyleStruct_Background, aContext, &ruleData, &colorData);
-
-  // We are sharing with some style rule.  It really owns the data.
-  colorData.mBackImage = nsnull;
-  colorData.mBackRepeat = nsnull;
-  colorData.mBackAttachment = nsnull;
-  colorData.mBackClip = nsnull;
-  colorData.mBackOrigin = nsnull;
-
-  return res;
+  return WalkRuleTree(eStyleStruct_Background, aContext, &ruleData, &colorData);
 }
 
 const void*
 nsRuleNode::GetMarginData(nsStyleContext* aContext)
 {
   nsRuleDataMargin marginData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Margin), mPresContext, aContext);
   ruleData.mMarginData = &marginData;
@@ -1934,34 +1904,26 @@ nsRuleNode::GetMarginData(nsStyleContext
 
 const void*
 nsRuleNode::GetBorderData(nsStyleContext* aContext)
 {
   nsRuleDataMargin marginData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Border), mPresContext, aContext);
   ruleData.mMarginData = &marginData;
 
-  const void* res = WalkRuleTree(eStyleStruct_Border, aContext, &ruleData, &marginData);
-  // We are sharing with some style rule.  It really owns the data.
-  // This nulling must also happen in HasAuthorSpecifiedRules.
-  marginData.mBoxShadow = nsnull;
-  return res;
+  return WalkRuleTree(eStyleStruct_Border, aContext, &ruleData, &marginData);
 }
 
 const void*
 nsRuleNode::GetPaddingData(nsStyleContext* aContext)
 {
   nsRuleDataMargin marginData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Padding), mPresContext, aContext);
   ruleData.mMarginData = &marginData;
 
-  // If any members need to be set to null here, they must also be set to
-  // null in HasAuthorSpecifiedRules (look at mBoxShadow in GetBorderData
-  // and HasAuthorSpecifiedRules).
-
   return WalkRuleTree(eStyleStruct_Padding, aContext, &ruleData, &marginData);
 }
 
 const void*
 nsRuleNode::GetOutlineData(nsStyleContext* aContext)
 {
   nsRuleDataMargin marginData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Outline), mPresContext, aContext);
@@ -2012,19 +1974,17 @@ nsRuleNode::GetTableBorderData(nsStyleCo
 
 const void*
 nsRuleNode::GetContentData(nsStyleContext* aContext)
 {
   nsRuleDataContent contentData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Content), mPresContext, aContext);
   ruleData.mContentData = &contentData;
 
-  const void* res = WalkRuleTree(eStyleStruct_Content, aContext, &ruleData, &contentData);
-  contentData.mContent = nsnull; // We are sharing with some style rule.  It really owns the data.
-  return res;
+  return WalkRuleTree(eStyleStruct_Content, aContext, &ruleData, &contentData);
 }
 
 const void*
 nsRuleNode::GetQuotesData(nsStyleContext* aContext)
 {
   nsRuleDataContent contentData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Quotes), mPresContext, aContext);
   ruleData.mContentData = &contentData;
@@ -2054,19 +2014,17 @@ nsRuleNode::GetColumnData(nsStyleContext
 
 const void*
 nsRuleNode::GetSVGData(nsStyleContext* aContext)
 {
   nsRuleDataSVG svgData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(SVG), mPresContext, aContext);
   ruleData.mSVGData = &svgData;
 
-  const void *res = WalkRuleTree(eStyleStruct_SVG, aContext, &ruleData, &svgData);
-  svgData.mStrokeDasharray = nsnull; // We are sharing with some style rule.  It really owns the data.
-  return res;
+  return WalkRuleTree(eStyleStruct_SVG, aContext, &ruleData, &svgData);
 }
 
 const void*
 nsRuleNode::GetSVGResetData(nsStyleContext* aContext)
 {
   nsRuleDataSVG svgData; // Declare a struct with null CSS values.
   nsRuleData ruleData(NS_STYLE_INHERIT_BIT(SVGReset), mPresContext, aContext);
   ruleData.mSVGData = &svgData;
@@ -2108,19 +2066,16 @@ UnsetPropertiesWithoutFlags(const nsStyl
     if ((prop->flags & aFlags) == aFlags)
       // Don't unset the property.
       continue;
 
     switch (prop->type) {
       case eCSSType_Value:
         ValueAtOffset(aRuleDataStruct, prop->offset).Reset();
         break;
-      case eCSSType_ValueList:
-        ValueListAtOffset(aRuleDataStruct, prop->offset) = nsnull;
-        break;
       default:
         NS_NOTREACHED("unknown type");
         break;
     }
   }
 }
 
 const void*
@@ -3463,37 +3418,51 @@ nsRuleNode::ComputeFontData(void* aStart
     canStoreInRuleTree = PR_FALSE;
     nsRuleNode::SetGenericFont(mPresContext, aContext, generic,
                                minimumFontSize, font);
   }
 
   COMPUTE_END_INHERITED(Font, font)
 }
 
+template <typename T>
+inline PRUint32 ListLength(const T* aList)
+{
+  PRUint32 len = 0;
+  while (aList) {
+    len++;
+    aList = aList->mNext;
+  }
+  return len;
+}
+
+
+
 already_AddRefed<nsCSSShadowArray>
-nsRuleNode::GetShadowData(nsCSSValueList* aList,
+nsRuleNode::GetShadowData(const nsCSSValueList* aList,
                           nsStyleContext* aContext,
                           PRBool aIsBoxShadow,
                           PRBool& canStoreInRuleTree)
 {
-  PRUint32 arrayLength = 0;
-  for (nsCSSValueList *list2 = aList; list2; list2 = list2->mNext)
-    ++arrayLength;
-
-  NS_ASSERTION(arrayLength > 0, "Non-null text-shadow list, yet we counted 0 items.");
+  PRUint32 arrayLength = ListLength(aList);
+
+  NS_ABORT_IF_FALSE(arrayLength > 0,
+                    "Non-null text-shadow list, yet we counted 0 items.");
   nsCSSShadowArray* shadowList = new(arrayLength) nsCSSShadowArray(arrayLength);
 
   if (!shadowList)
     return nsnull;
 
   nsStyleCoord tempCoord;
   PRBool unitOK;
   for (nsCSSShadowItem* item = shadowList->ShadowAt(0);
        aList;
        aList = aList->mNext, ++item) {
+    NS_ABORT_IF_FALSE(aList->mValue.GetUnit() == eCSSUnit_Array,
+                      "expecting a plain array value");
     nsCSSValue::Array *arr = aList->mValue.GetArrayValue();
     // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
     unitOK = SetCoord(arr->Item(0), tempCoord, nsStyleCoord(),
                       SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
                       aContext, mPresContext, canStoreInRuleTree);
     NS_ASSERTION(unitOK, "unexpected unit");
     item->mXOffset = tempCoord.GetCoordValue();
 
@@ -3564,29 +3533,29 @@ nsRuleNode::ComputeTextData(void* aStart
 
   // letter-spacing: normal, length, inherit
   SetCoord(textData.mLetterSpacing, text->mLetterSpacing, parentText->mLetterSpacing,
            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
              SETCOORD_CALC_LENGTH_ONLY,
            aContext, mPresContext, canStoreInRuleTree);
 
   // text-shadow: none, list, inherit, initial
-  nsCSSValueList* list = textData.mTextShadow;
-  if (list) {
+  if (textData.mTextShadow.GetUnit() != eCSSUnit_Null) {
     text->mTextShadow = nsnull;
 
     // Don't need to handle none/initial explicitly: The above assignment
     // takes care of that
-    if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
+    if (textData.mTextShadow.GetUnit() == eCSSUnit_Inherit) {
       canStoreInRuleTree = PR_FALSE;
       text->mTextShadow = parentText->mTextShadow;
-    } else if (eCSSUnit_Array == list->mValue.GetUnit()) {
+    } else if (textData.mTextShadow.GetUnit() == eCSSUnit_List ||
+               textData.mTextShadow.GetUnit() == eCSSUnit_ListDep) {
       // List of arrays
-      text->mTextShadow = GetShadowData(list, aContext, PR_FALSE,
-                                        canStoreInRuleTree);
+      text->mTextShadow = GetShadowData(textData.mTextShadow.GetListValue(),
+                                        aContext, PR_FALSE, canStoreInRuleTree);
     }
   }
 
   // line-height: normal, number, length, percent, inherit
   if (eCSSUnit_Percent == textData.mLineHeight.GetUnit()) {
     canStoreInRuleTree = PR_FALSE;
     // Use |mFont.size| to pick up minimum font size.
     text->mLineHeight.SetCoordValue(
@@ -3740,35 +3709,40 @@ nsRuleNode::ComputeUserInterfaceData(voi
                                      nsRuleNode* aHighestNode,
                                      const RuleDetail aRuleDetail,
                                      const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_INHERITED(UserInterface, (), ui, parentUI,
                           UserInterface, uiData)
 
   // cursor: enum, url, inherit
-  nsCSSValueList*  list = uiData.mCursor;
-  if (nsnull != list) {
+  nsCSSUnit cursorUnit = uiData.mCursor.GetUnit();
+  if (cursorUnit != eCSSUnit_Null) {
     delete [] ui->mCursorArray;
     ui->mCursorArray = nsnull;
     ui->mCursorArrayLength = 0;
 
-    if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
+    if (cursorUnit == eCSSUnit_Inherit) {
       canStoreInRuleTree = PR_FALSE;
       ui->mCursor = parentUI->mCursor;
       ui->CopyCursorArrayFrom(*parentUI);
     }
-    else if (eCSSUnit_Initial == list->mValue.GetUnit()) {
+    else if (cursorUnit == eCSSUnit_Initial) {
       ui->mCursor = NS_STYLE_CURSOR_AUTO;
     }
     else {
       // The parser will never create a list that is *all* URL values --
       // that's invalid.
+      NS_ABORT_IF_FALSE(cursorUnit == eCSSUnit_List ||
+                        cursorUnit == eCSSUnit_ListDep,
+                        nsPrintfCString(64, "unrecognized cursor unit %d",
+                                        cursorUnit).get());
+      const nsCSSValueList* list = uiData.mCursor.GetListValue();
+      const nsCSSValueList* list2 = list;
       PRUint32 arrayLength = 0;
-      nsCSSValueList* list2 = list;
       for ( ; list->mValue.GetUnit() == eCSSUnit_Array; list = list->mNext)
         if (list->mValue.GetArrayValue()->Item(0).GetImageValue())
           ++arrayLength;
 
       if (arrayLength != 0) {
         ui->mCursorArray = new nsCursorImage[arrayLength];
         if (ui->mCursorArray) {
           ui->mCursorArrayLength = arrayLength;
@@ -3847,32 +3821,20 @@ nsRuleNode::ComputeUIResetData(void* aSt
   // -moz-window-shadow: enum, inherit, initial
   SetDiscrete(uiData.mWindowShadow, ui->mWindowShadow, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentUI->mWindowShadow,
               NS_STYLE_WINDOW_SHADOW_DEFAULT, 0, 0, 0, 0);
 
   COMPUTE_END_RESET(UIReset, ui)
 }
 
-// A simple helper function to get the length of a nsCSSValueList
-inline static PRUint32 GetValueListLength(nsCSSValueList* aValueList)
-{
-  PRUint32 len = 0;
-  nsCSSValueList* val = aValueList;
-  while (val) {
-    len++;
-    val = val->mNext;
-  }
-  return len;
-}
-
 // Information about each transition property that is constant.
 struct TransitionPropInfo {
   // Location of the property's specified value.
-  nsCSSValueList* nsRuleDataDisplay::* rdList;
+  nsCSSValue nsRuleDataDisplay::* rdList;
   // Location of the count of the property's computed value.
   PRUint32 nsStyleDisplay::* sdCount;
 };
 
 // Each property's index in this array must match its index in the
 // mutable array |transitionPropData| below.
 static const TransitionPropInfo transitionPropInfo[4] = {
   { &nsRuleDataDisplay::mTransitionDelay,
@@ -3883,18 +3845,18 @@ static const TransitionPropInfo transiti
     &nsStyleDisplay::mTransitionPropertyCount },
   { &nsRuleDataDisplay::mTransitionTimingFunction,
     &nsStyleDisplay::mTransitionTimingFunctionCount },
 };
 
 // Information about each transition property that changes during
 // ComputeDisplayData.
 struct TransitionPropData {
-  nsCSSValueList *list;
-  PRBool inherited;
+  const nsCSSValueList *list;
+  nsCSSUnit unit;
   PRUint32 num;
 };
 
 const void*
 nsRuleNode::ComputeDisplayData(void* aStartStruct,
                                const nsRuleDataStruct& aData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
@@ -3945,43 +3907,44 @@ nsRuleNode::ComputeDisplayData(void* aSt
   // fully-specified transition, which we do by remembering the number
   // of values for each property.
 
   PRUint32 numTransitions = 0;
   FOR_ALL_TRANSITION_PROPS(p) {
     const TransitionPropInfo& i = transitionPropInfo[p];
     TransitionPropData& d = transitionPropData[p];
 
-    d.list = displayData.*(i.rdList);
-
     // cache whether any of the properties are specified as 'inherit' so
     // we can use it below
-    d.inherited = d.list && d.list->mValue.GetUnit() == eCSSUnit_Inherit;
+
+    const nsCSSValue& value = displayData.*(i.rdList);
+    d.unit = value.GetUnit();
+    d.list = (value.GetUnit() == eCSSUnit_List ||
+              value.GetUnit() == eCSSUnit_ListDep)
+      ? value.GetListValue() : nsnull;
     d.num = 0;
 
     // General algorithm to determine how many total transitions we need
     // to build.  For each property:
     //  - if there is no value specified in for the property in
     //    displayData, use the values from the start struct, but only if
     //    they were explicitly specified
     //  - if there is a value specified for the property in displayData:
     //    - if the value is 'inherit', count the number of values for
     //      that property are specified by the parent, but only those
     //      that were explicitly specified
     //    - otherwise, count the number of values specified in displayData
 
 
     // calculate number of elements
-    if (d.list) {
-      if (d.inherited) {
-        d.num = parentDisplay->*(i.sdCount);
-        canStoreInRuleTree = PR_FALSE;
-      } else {
-        d.num = GetValueListLength(d.list);
-      }
+    if (d.unit == eCSSUnit_Inherit) {
+      d.num = parentDisplay->*(i.sdCount);
+      canStoreInRuleTree = PR_FALSE;
+    } else if (d.list) {
+      d.num = ListLength(d.list);
     } else {
       d.num = display->*(i.sdCount);
     }
     if (d.num > numTransitions)
       numTransitions = d.num;
   }
 
   if (!display->mTransitions.SetLength(numTransitions)) {
@@ -4005,112 +3968,108 @@ nsRuleNode::ComputeDisplayData(void* aSt
   }
 
   // Fill in the transitions we just allocated with the appropriate values.
   for (PRUint32 i = 0; i < numTransitions; ++i) {
     nsTransition *transition = &display->mTransitions[i];
 
     if (i >= delay.num) {
       transition->SetDelay(display->mTransitions[i % delay.num].GetDelay());
-    } else if (delay.inherited) {
+    } else if (delay.unit == eCSSUnit_Inherit) {
       // FIXME (Bug 522599) (for all transition properties): write a test that
       // detects when this was wrong for i >= delay.num if parent had
       // count for this property not equal to length
       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionDelayCount,
                         "delay.num computed incorrectly");
       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
                         "should have made canStoreInRuleTree false above");
       transition->SetDelay(parentDisplay->mTransitions[i].GetDelay());
+    } else if (delay.unit == eCSSUnit_Initial) {
+      transition->SetDelay(0.0);
     } else if (delay.list) {
       switch (delay.list->mValue.GetUnit()) {
         case eCSSUnit_Seconds:
           transition->SetDelay(PR_MSEC_PER_SEC *
                                delay.list->mValue.GetFloatValue());
           break;
         case eCSSUnit_Milliseconds:
           transition->SetDelay(delay.list->mValue.GetFloatValue());
           break;
-        case eCSSUnit_Initial:
-          transition->SetDelay(0.0);
-          break;
         default:
           NS_NOTREACHED("Invalid delay unit");
       }
     }
 
     if (i >= duration.num) {
       transition->SetDuration(
         display->mTransitions[i % duration.num].GetDuration());
-    } else if (duration.inherited) {
+    } else if (duration.unit == eCSSUnit_Inherit) {
       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionDurationCount,
                         "duration.num computed incorrectly");
       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
                         "should have made canStoreInRuleTree false above");
       transition->SetDuration(parentDisplay->mTransitions[i].GetDuration());
+    } else if (duration.unit == eCSSUnit_Initial) {
+      transition->SetDuration(0.0);
     } else if (duration.list) {
       switch (duration.list->mValue.GetUnit()) {
         case eCSSUnit_Seconds:
           transition->SetDuration(PR_MSEC_PER_SEC *
                                   duration.list->mValue.GetFloatValue());
           break;
         case eCSSUnit_Milliseconds:
           transition->SetDuration(duration.list->mValue.GetFloatValue());
           break;
-        case eCSSUnit_Initial:
-          transition->SetDuration(0.0);
-          break;
         default:
           NS_NOTREACHED("Invalid duration unit");
       }
     }
 
     if (i >= property.num) {
       transition->CopyPropertyFrom(display->mTransitions[i % property.num]);
-    } else if (property.inherited) {
+    } else if (property.unit == eCSSUnit_Inherit) {
       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionPropertyCount,
                         "property.num computed incorrectly");
       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
                         "should have made canStoreInRuleTree false above");
       transition->CopyPropertyFrom(parentDisplay->mTransitions[i]);
+    } else if (property.unit == eCSSUnit_Initial ||
+               property.unit == eCSSUnit_All) {
+      transition->SetProperty(eCSSPropertyExtra_all_properties);
+    } else if (property.unit == eCSSUnit_None) {
+      transition->SetProperty(eCSSPropertyExtra_no_properties);
     } else if (property.list) {
-      switch (property.list->mValue.GetUnit()) {
-        case eCSSUnit_Ident:
-          {
-            nsDependentString
-              propertyStr(property.list->mValue.GetStringBufferValue());
-            nsCSSProperty prop = nsCSSProps::LookupProperty(propertyStr);
-            if (prop == eCSSProperty_UNKNOWN) {
-              transition->SetUnknownProperty(propertyStr);
-            } else {
-              transition->SetProperty(prop);
-            }
-          }
-          break;
-        case eCSSUnit_None:
-          transition->SetProperty(eCSSPropertyExtra_no_properties);
-          break;
-        case eCSSUnit_All:
-        case eCSSUnit_Initial:
-          transition->SetProperty(eCSSPropertyExtra_all_properties);
-          break;
-        default:
-          NS_NOTREACHED("Invalid transition property unit");
+      NS_ABORT_IF_FALSE(property.list->mValue.GetUnit() == eCSSUnit_Ident,
+                        nsPrintfCString(64,
+                                        "Invalid transition property unit %d",
+                                        property.list->mValue.GetUnit()).get());
+
+      nsDependentString
+        propertyStr(property.list->mValue.GetStringBufferValue());
+      nsCSSProperty prop = nsCSSProps::LookupProperty(propertyStr);
+      if (prop == eCSSProperty_UNKNOWN) {
+        transition->SetUnknownProperty(propertyStr);
+      } else {
+        transition->SetProperty(prop);
       }
     }
 
     if (i >= timingFunction.num) {
       transition->SetTimingFunction(
         display->mTransitions[i % timingFunction.num].GetTimingFunction());
-    } else if (timingFunction.inherited) {
+    } else if (timingFunction.unit == eCSSUnit_Inherit) {
       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionTimingFunctionCount,
                         "timingFunction.num computed incorrectly");
       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
                         "should have made canStoreInRuleTree false above");
       transition->SetTimingFunction(
         parentDisplay->mTransitions[i].GetTimingFunction());
+    } else if (timingFunction.unit == eCSSUnit_Initial) {
+      transition->SetTimingFunction(
+        nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE));
     } else if (timingFunction.list) {
       switch (timingFunction.list->mValue.GetUnit()) {
         case eCSSUnit_Enumerated:
           transition->SetTimingFunction(
             nsTimingFunction(timingFunction.list->mValue.GetIntValue()));
           break;
         case eCSSUnit_Cubic_Bezier:
           {
@@ -4120,33 +4079,30 @@ nsRuleNode::ComputeDisplayData(void* aSt
                          "Need 4 control points");
             transition->SetTimingFunction(
               nsTimingFunction(array->Item(0).GetFloatValue(),
                                array->Item(1).GetFloatValue(),
                                array->Item(2).GetFloatValue(),
                                array->Item(3).GetFloatValue()));
           }
           break;
-        case eCSSUnit_Initial:
-          transition->SetTimingFunction(
-            nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE));
-          break;
         default:
           NS_NOTREACHED("Invalid transition property unit");
       }
     }
 
     FOR_ALL_TRANSITION_PROPS(p) {
       const TransitionPropInfo& info = transitionPropInfo[p];
       TransitionPropData& d = transitionPropData[p];
 
       // if we're at the end of the list, start at the beginning and repeat
       // until we're out of transitions to populate
-      if (d.list) { // could also check && !d.inherited if desired
-        d.list = d.list->mNext ? d.list->mNext : displayData.*(info.rdList);
+      if (d.list) {
+        d.list = d.list->mNext ? d.list->mNext :
+          (displayData.*(info.rdList)).GetListValue();
       }
     }
   }
 
   // opacity: factor, inherit, initial
   SetFactor(displayData.mOpacity, display->mOpacity, canStoreInRuleTree,
             parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
 
@@ -4328,17 +4284,18 @@ nsRuleNode::ComputeDisplayData(void* aSt
       display->mClip.width = NS_MAXSIZE;
       display->mClipFlags |= NS_STYLE_CLIP_RIGHT_AUTO;
     }
     else if (clipRect.mRight.IsLengthUnit()) {
       display->mClip.width = CalcLength(clipRect.mRight, aContext,
                                         mPresContext, canStoreInRuleTree) -
                              display->mClip.x;
     }
-  } break;
+    break;
+  }
 
   default:
     NS_ABORT_IF_FALSE(false, "unrecognized clip unit");
   }
 
   if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
     // CSS2 9.7 specifies display type corrections dealing with 'float'
     // and 'position'.  Since generated content can't be floated or
@@ -4380,48 +4337,49 @@ nsRuleNode::ComputeDisplayData(void* aSt
       // rule has 'float: none' we'll end up with the wrong 'display'
       // property.
       canStoreInRuleTree = PR_FALSE;
     }
 
   }
 
   /* Convert the nsCSSValueList into an nsTArray<nsTransformFunction *>. */
-  const nsCSSValueList *head = displayData.mTransform;
-
-  if (head != nsnull) {
-    /* There is a chance that we will discover that
-     * the transform property has been set to 'none,' 'initial,' or 'inherit.'
-     * If so, process appropriately.
-     */
-
-    /* If it's 'none,' indicate that there are no transforms. */
+  switch (displayData.mTransform.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_Initial:
+  case eCSSUnit_None:
+    display->mSpecifiedTransform = nsnull;
+    break;
+
+  case eCSSUnit_Inherit:
+    display->mSpecifiedTransform = parentDisplay->mSpecifiedTransform;
+    if (parentDisplay->mSpecifiedTransform)
+      display->mTransform = parentDisplay->mTransform;
+    canStoreInRuleTree = PR_FALSE;
+    break;
+
+  case eCSSUnit_List:
+  case eCSSUnit_ListDep: {
+    const nsCSSValueList* head = displayData.mTransform.GetListValue();
+    // can get a _None in here from transform animation
     if (head->mValue.GetUnit() == eCSSUnit_None) {
+      NS_ABORT_IF_FALSE(head->mNext == nsnull, "none must be alone");
       display->mSpecifiedTransform = nsnull;
-    }
-    /* If we need to inherit, copy the pointer owned by a style rule */
-    else if (head->mValue.GetUnit() == eCSSUnit_Inherit)  {
-      display->mSpecifiedTransform = parentDisplay->mSpecifiedTransform;
-      if (parentDisplay->mSpecifiedTransform)
-        display->mTransform = parentDisplay->mTransform;
-      canStoreInRuleTree = PR_FALSE;
-    }
-    /* If it's 'initial', then we reset to empty. */
-    else if (head->mValue.GetUnit() == eCSSUnit_Initial) {
-      display->mSpecifiedTransform = nsnull;
-    }
-    /* Otherwise, we are looking at a list of CSS tokens.  We'll read each of
-     * them in as an array of nsTransformFunction objects, then will accumulate
-     * them all together to form the final transform matrix.
-     */
-    else {
+    } else {
       display->mSpecifiedTransform = head; // weak pointer, owned by rule
       display->mTransform = nsStyleTransformMatrix::ReadTransforms(head,
                               aContext, mPresContext, canStoreInRuleTree);
     }
+    break;
+  }
+
+  default:
+    NS_ABORT_IF_FALSE(false, "unrecognized transform unit");
   }
 
   /* Convert -moz-transform-origin. */
   if (displayData.mTransformOrigin.GetUnit() != eCSSUnit_Null) {
 #ifdef DEBUG
     PRBool result =
 #endif
       SetPairCoords(displayData.mTransformOrigin,
@@ -4699,71 +4657,82 @@ struct BackgroundItemComputer<nsCSSValue
                       "bad height type");
     NS_ABORT_IF_FALSE((size.mWidthType != nsStyleBackground::Size::eContain &&
                        size.mWidthType != nsStyleBackground::Size::eCover) ||
                       size.mWidthType == size.mHeightType,
                       "contain/cover apply to both dimensions or to neither");
   }
 };
 
-
-template <class SpecifiedValueItem, class ComputedValueItem>
+template <class ComputedValueItem>
 static void
 SetBackgroundList(nsStyleContext* aStyleContext,
-                  const SpecifiedValueItem* aValueList,
+                  const nsCSSValue& aValue,
                   nsAutoTArray< nsStyleBackground::Layer, 1> &aLayers,
-                  const nsAutoTArray<nsStyleBackground::Layer, 1>
-                                                                 &aParentLayers,
+                  const nsAutoTArray<nsStyleBackground::Layer, 1> &aParentLayers,
                   ComputedValueItem nsStyleBackground::Layer::* aResultLocation,
                   ComputedValueItem aInitialValue,
                   PRUint32 aParentItemCount,
                   PRUint32& aItemCount,
                   PRUint32& aMaxItemCount,
                   PRBool& aRebuild,
                   PRBool& aCanStoreInRuleTree)
 {
-  if (aValueList) {
+  switch (aValue.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_Inherit:
     aRebuild = PR_TRUE;
-    nsCSSValue SpecifiedValueItem::* initialInherit =
-      InitialInheritLocationFor<SpecifiedValueItem>::Location();
-    if (eCSSUnit_Inherit == (aValueList->*initialInherit).GetUnit()) {
-      NS_ASSERTION(!aValueList->mNext, "should have only one value");
-      aCanStoreInRuleTree = PR_FALSE;
-      if (!aLayers.EnsureLengthAtLeast(aParentItemCount)) {
+    aCanStoreInRuleTree = PR_FALSE;
+    if (!aLayers.EnsureLengthAtLeast(aParentItemCount)) {
+      NS_WARNING("out of memory");
+      aParentItemCount = aLayers.Length();
+    }
+    aItemCount = aParentItemCount;
+    for (PRUint32 i = 0; i < aParentItemCount; ++i) {
+      aLayers[i].*aResultLocation = aParentLayers[i].*aResultLocation;
+    }
+    break;
+
+  case eCSSUnit_Initial:
+    aRebuild = PR_TRUE;
+    aItemCount = 1;
+    aLayers[0].*aResultLocation = aInitialValue;
+    break;
+
+  case eCSSUnit_List:
+  case eCSSUnit_ListDep: {
+    aRebuild = PR_TRUE;
+    aItemCount = 0;
+    const nsCSSValueList* item = aValue.GetListValue();
+    do {
+      NS_ASSERTION(item->mValue.GetUnit() != eCSSUnit_Null &&
+                   item->mValue.GetUnit() != eCSSUnit_Inherit &&
+                   item->mValue.GetUnit() != eCSSUnit_Initial,
+                   "unexpected unit");
+      ++aItemCount;
+      if (!aLayers.EnsureLengthAtLeast(aItemCount)) {
         NS_WARNING("out of memory");
-        aParentItemCount = aLayers.Length();
+        --aItemCount;
+        break;
       }
-      aItemCount = aParentItemCount;
-      for (PRUint32 i = 0; i < aParentItemCount; ++i) {
-        aLayers[i].*aResultLocation = aParentLayers[i].*aResultLocation;
-      }
-    } else if (eCSSUnit_Initial == (aValueList->*initialInherit).GetUnit()) {
-      NS_ASSERTION(!aValueList->mNext, "should have only one value");
-      aItemCount = 1;
-      aLayers[0].*aResultLocation = aInitialValue;
-    } else {
-      const SpecifiedValueItem *item = aValueList;
-      aItemCount = 0;
-      do {
-        NS_ASSERTION((item->*initialInherit).GetUnit() != eCSSUnit_Inherit &&
-                     (item->*initialInherit).GetUnit() != eCSSUnit_Initial,
-                     "unexpected unit");
-        ++aItemCount;
-        if (!aLayers.EnsureLengthAtLeast(aItemCount)) {
-          NS_WARNING("out of memory");
-          --aItemCount;
-          break;
-        }
-        BackgroundItemComputer<SpecifiedValueItem, ComputedValueItem>
-          ::ComputeValue(aStyleContext, item,
-                         aLayers[aItemCount-1].*aResultLocation,
-                         aCanStoreInRuleTree);
-        item = item->mNext;
-      } while (item);
-    }
+      BackgroundItemComputer<nsCSSValueList, ComputedValueItem>
+        ::ComputeValue(aStyleContext, item,
+                       aLayers[aItemCount-1].*aResultLocation,
+                       aCanStoreInRuleTree);
+      item = item->mNext;
+    } while (item);
+    break;
+  }
+
+  default:
+    NS_ABORT_IF_FALSE(false,
+                      nsPrintfCString(32, "unexpected unit %d",
+                                      aValue.GetUnit()).get());
   }
 
   if (aItemCount > aMaxItemCount)
     aMaxItemCount = aItemCount;
 }
 
 template <class ComputedValueItem>
 static void
@@ -4822,20 +4791,23 @@ SetBackgroundPairList(nsStyleContext* aS
         break;
       }
       BackgroundItemComputer<nsCSSValuePairList, ComputedValueItem>
         ::ComputeValue(aStyleContext, item,
                        aLayers[aItemCount-1].*aResultLocation,
                        aCanStoreInRuleTree);
       item = item->mNext;
     } while (item);
-  } break;
+    break;
+  }
 
   default:
-    NS_ABORT_IF_FALSE(false, "unexpected unit");
+    NS_ABORT_IF_FALSE(false,
+                      nsPrintfCString(32, "unexpected unit %d",
+                                      aValue.GetUnit()).get());
   }
 
   if (aItemCount > aMaxItemCount)
     aMaxItemCount = aItemCount;
 }
 
 template <class ComputedValueItem>
 static void
@@ -5006,31 +4978,40 @@ nsRuleNode::ComputeBorderData(void* aSta
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
                               const PRBool aCanStoreInRuleTree)
 {
   COMPUTE_START_RESET(Border, (mPresContext), border, parentBorder,
                       Margin, marginData)
 
   // -moz-box-shadow: none, list, inherit, initial
-  {
-    nsCSSValueList* list = marginData.mBoxShadow;
-    if (list) {
-      // This handles 'none' and 'initial'
-      border->mBoxShadow = nsnull;
-
-      if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-        canStoreInRuleTree = PR_FALSE;
-        border->mBoxShadow = parentBorder->mBoxShadow;
-      } else if (eCSSUnit_Array == list->mValue.GetUnit()) {
-        // List of arrays
-        border->mBoxShadow = GetShadowData(list, aContext, PR_TRUE,
-                                           canStoreInRuleTree);
-      }
-    }
+  switch (marginData.mBoxShadow.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_Initial:
+  case eCSSUnit_None:
+    border->mBoxShadow = nsnull;
+    break;
+
+  case eCSSUnit_Inherit:
+    border->mBoxShadow = parentBorder->mBoxShadow;
+    canStoreInRuleTree = PR_FALSE;
+    break;
+
+  case eCSSUnit_List:
+  case eCSSUnit_ListDep:
+    border->mBoxShadow = GetShadowData(marginData.mBoxShadow.GetListValue(),
+                                       aContext, PR_TRUE, canStoreInRuleTree);
+    break;
+
+  default:
+    NS_ABORT_IF_FALSE(false,
+                      nsPrintfCString(64, "unrecognized shadow unit %d",
+                                      marginData.mBoxShadow.GetUnit()).get());
   }
 
   // border-width, border-*-width: length, enum, inherit
   nsStyleCoord  coord;
   nsCSSRect ourBorderWidth(marginData.mBorderWidth);
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderLeftWidthLTRSource,
                        marginData.mBorderLeftWidthRTLSource,
@@ -5114,55 +5095,63 @@ nsRuleNode::ComputeBorderData(void* aSta
       }
     }
   }
 
   // -moz-border-*-colors: color, string, enum, none, inherit/initial
   nscolor borderColor;
   nscolor unused = NS_RGB(0,0,0);
 
-  { // scope for compilers with broken |for| loop scoping
-    NS_FOR_CSS_SIDES(side) {
-      nsCSSValueList* list =
-          marginData.mBorderColors.*(nsCSSValueListRect::sides[side]);
-      if (list) {
-        if (eCSSUnit_Initial == list->mValue.GetUnit() ||
-            eCSSUnit_None == list->mValue.GetUnit()) {
-          NS_ASSERTION(!list->mNext, "should have only one item");
-          border->ClearBorderColors(side);
+  NS_FOR_CSS_SIDES(side) {
+    const nsCSSValue& value =
+      marginData.mBorderColors.*(nsCSSRect::sides[side]);
+    switch (value.GetUnit()) {
+    case eCSSUnit_Null:
+      break;
+
+    case eCSSUnit_Initial:
+    case eCSSUnit_None:
+      border->ClearBorderColors(side);
+      break;
+
+    case eCSSUnit_Inherit: {
+      canStoreInRuleTree = PR_FALSE;
+      nsBorderColors *parentColors;
+      parentBorder->GetCompositeColors(side, &parentColors);
+      if (parentColors) {
+        border->EnsureBorderColors();
+        border->ClearBorderColors(side);
+        border->mBorderColors[side] = parentColors->Clone();
+      } else {
+        border->ClearBorderColors(side);
+      }
+      break;
+    }
+
+    case eCSSUnit_List:
+    case eCSSUnit_ListDep: {
+      // Some composite border color information has been specified for this
+      // border side.
+      border->EnsureBorderColors();
+      border->ClearBorderColors(side);
+      const nsCSSValueList* list = value.GetListValue();
+      while (list) {
+        if (SetColor(list->mValue, unused, mPresContext,
+                     aContext, borderColor, canStoreInRuleTree))
+          border->AppendBorderColor(side, borderColor);
+        else {
+          NS_NOTREACHED("unexpected item in -moz-border-*-colors list");
         }
-        else if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-          canStoreInRuleTree = PR_FALSE;
-          NS_ASSERTION(!list->mNext, "should have only one item");
-          nsBorderColors *parentColors;
-          parentBorder->GetCompositeColors(side, &parentColors);
-          if (parentColors) {
-            border->EnsureBorderColors();
-            border->ClearBorderColors(side);
-            border->mBorderColors[side] = parentColors->Clone();
-          } else {
-            border->ClearBorderColors(side);
-          }
-        }
-        else {
-          // Some composite border color information has been specified for this
-          // border side.
-          border->EnsureBorderColors();
-          border->ClearBorderColors(side);
-          while (list) {
-            if (SetColor(list->mValue, unused, mPresContext,
-                         aContext, borderColor, canStoreInRuleTree))
-              border->AppendBorderColor(side, borderColor);
-            else {
-              NS_NOTREACHED("unexpected item in -moz-border-*-colors list");
-            }
-            list = list->mNext;
-          }
-        }
+        list = list->mNext;
       }
+      break;
+    }
+
+    default:
+      NS_ABORT_IF_FALSE(false, "unrecognized border color unit");
     }
   }
 
   // border-color, border-*-color: color, string, enum, inherit
   nsCSSRect ourBorderColor(marginData.mBorderColor);
   PRBool foreground;
   AdjustLogicalBoxProp(aContext,
                        marginData.mBorderLeftColorLTRSource,
@@ -5532,17 +5521,18 @@ nsRuleNode::ComputeListData(void* aStart
         CalcLength(rgnRect.mLeft, aContext, mPresContext, canStoreInRuleTree);
 
     if (rgnRect.mRight.GetUnit() == eCSSUnit_Auto)
       list->mImageRegion.width = 0;
     else if (rgnRect.mRight.IsLengthUnit())
       list->mImageRegion.width =
         CalcLength(rgnRect.mRight, aContext, mPresContext,
                    canStoreInRuleTree) - list->mImageRegion.x;
-  } break;
+    break;
+  }
 
   default:
     NS_ABORT_IF_FALSE(false, "unrecognized image-region unit");
   }
 
   COMPUTE_END_INHERITED(List, list)
 }
 
@@ -5692,78 +5682,94 @@ nsRuleNode::ComputeTableBorderData(void*
 const void*
 nsRuleNode::ComputeContentData(void* aStartStruct,
                                const nsRuleDataStruct& aData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
                                const PRBool aCanStoreInRuleTree)
 {
+  PRUint32 count;
+  nsAutoString buffer;
+
   COMPUTE_START_RESET(Content, (), content, parentContent,
                       Content, contentData)
 
   // content: [string, url, counter, attr, enum]+, normal, none, inherit
-  PRUint32 count;
-  nsAutoString  buffer;
-  nsCSSValueList* contentValue = contentData.mContent;
-  if (contentValue) {
-    if (eCSSUnit_Normal == contentValue->mValue.GetUnit() ||
-        eCSSUnit_None == contentValue->mValue.GetUnit() ||
-        eCSSUnit_Initial == contentValue->mValue.GetUnit()) {
-      // "normal", "none", and "initial" all mean no content
-      content->AllocateContents(0);
-    }
-    else if (eCSSUnit_Inherit == contentValue->mValue.GetUnit()) {
-      canStoreInRuleTree = PR_FALSE;
-      count = parentContent->ContentCount();
-      if (NS_SUCCEEDED(content->AllocateContents(count))) {
-        while (0 < count--) {
-          content->ContentAt(count) = parentContent->ContentAt(count);
-        }
+  switch (contentData.mContent.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_Normal:
+  case eCSSUnit_None:
+  case eCSSUnit_Initial:
+    // "normal", "none", and "initial" all mean no content
+    content->AllocateContents(0);
+    break;
+
+  case eCSSUnit_Inherit:
+    canStoreInRuleTree = PR_FALSE;
+    count = parentContent->ContentCount();
+    if (NS_SUCCEEDED(content->AllocateContents(count))) {
+      while (0 < count--) {
+        content->ContentAt(count) = parentContent->ContentAt(count);
       }
     }
-    else {
+    break;
+
+  case eCSSUnit_Enumerated: {
+    NS_ABORT_IF_FALSE(contentData.mContent.GetIntValue() ==
+                      NS_STYLE_CONTENT_ALT_CONTENT,
+                      "unrecognized solitary content keyword");
+    content->AllocateContents(1);
+    nsStyleContentData& data = content->ContentAt(0);
+    data.mType = eStyleContentType_AltContent;
+    data.mContent.mString = nsnull;
+    break;
+  }
+
+  case eCSSUnit_List:
+  case eCSSUnit_ListDep: {
+    const nsCSSValueList* contentValue = contentData.mContent.GetListValue();
       count = 0;
       while (contentValue) {
         count++;
         contentValue = contentValue->mNext;
       }
       if (NS_SUCCEEDED(content->AllocateContents(count))) {
         const nsAutoString  nullStr;
         count = 0;
-        contentValue = contentData.mContent;
+        contentValue = contentData.mContent.GetListValue();
         while (contentValue) {
           const nsCSSValue& value = contentValue->mValue;
           nsCSSUnit unit = value.GetUnit();
           nsStyleContentType type;
           nsStyleContentData &data = content->ContentAt(count++);
           switch (unit) {
-            case eCSSUnit_String:   type = eStyleContentType_String;    break;
-            case eCSSUnit_Image:    type = eStyleContentType_Image;       break;
-            case eCSSUnit_Attr:     type = eStyleContentType_Attr;      break;
-            case eCSSUnit_Counter:  type = eStyleContentType_Counter;   break;
-            case eCSSUnit_Counters: type = eStyleContentType_Counters;  break;
-            case eCSSUnit_Enumerated:
-              switch (value.GetIntValue()) {
-                case NS_STYLE_CONTENT_OPEN_QUOTE:
-                  type = eStyleContentType_OpenQuote;     break;
-                case NS_STYLE_CONTENT_CLOSE_QUOTE:
-                  type = eStyleContentType_CloseQuote;    break;
-                case NS_STYLE_CONTENT_NO_OPEN_QUOTE:
-                  type = eStyleContentType_NoOpenQuote;   break;
-                case NS_STYLE_CONTENT_NO_CLOSE_QUOTE:
-                  type = eStyleContentType_NoCloseQuote;  break;
-                case NS_STYLE_CONTENT_ALT_CONTENT:
-                  type = eStyleContentType_AltContent;    break;
-                default:
-                  NS_ERROR("bad content value");
-              }
-              break;
+          case eCSSUnit_String:   type = eStyleContentType_String;    break;
+          case eCSSUnit_Image:    type = eStyleContentType_Image;     break;
+          case eCSSUnit_Attr:     type = eStyleContentType_Attr;      break;
+          case eCSSUnit_Counter:  type = eStyleContentType_Counter;   break;
+          case eCSSUnit_Counters: type = eStyleContentType_Counters;  break;
+          case eCSSUnit_Enumerated:
+            switch (value.GetIntValue()) {
+            case NS_STYLE_CONTENT_OPEN_QUOTE:
+              type = eStyleContentType_OpenQuote;     break;
+            case NS_STYLE_CONTENT_CLOSE_QUOTE:
+              type = eStyleContentType_CloseQuote;    break;
+            case NS_STYLE_CONTENT_NO_OPEN_QUOTE:
+              type = eStyleContentType_NoOpenQuote;   break;
+            case NS_STYLE_CONTENT_NO_CLOSE_QUOTE:
+              type = eStyleContentType_NoCloseQuote;  break;
             default:
-              NS_ERROR("bad content type");
+              NS_ERROR("bad content value");
+            }
+            break;
+          default:
+            NS_ERROR("bad content type");
           }
           data.mType = type;
           if (type == eStyleContentType_Image) {
             NS_SET_IMAGE_REQUEST(data.SetImage, aContext, value.GetImageValue());
           }
           else if (type <= eStyleContentType_Attr) {
             value.GetStringValue(buffer);
             data.mContent.mString = NS_strdup(buffer.get());
@@ -5773,17 +5779,23 @@ nsRuleNode::ComputeContentData(void* aSt
             data.mContent.mCounters->AddRef();
           }
           else {
             data.mContent.mString = nsnull;
           }
           contentValue = contentValue->mNext;
         }
       }
-    }
+      break;
+  }
+
+  default:
+    NS_ABORT_IF_FALSE(false,
+                      nsPrintfCString(64, "unrecognized content unit %d",
+                                      contentData.mContent.GetUnit()).get());
   }
 
   // counter-increment: [string [int]]+, none, inherit
   switch (contentData.mCounterIncrement.GetUnit()) {
   case eCSSUnit_Null:
     break;
 
   case eCSSUnit_None:
@@ -5804,35 +5816,34 @@ nsRuleNode::ComputeContentData(void* aSt
     break;
 
   case eCSSUnit_PairList:
   case eCSSUnit_PairListDep: {
     const nsCSSValuePairList* ourIncrement =
       contentData.mCounterIncrement.GetPairListValue();
     NS_ABORT_IF_FALSE(ourIncrement->mXValue.GetUnit() == eCSSUnit_Ident,
                       "unexpected value unit");
-    count = 0;
-    for (const nsCSSValuePairList* p = ourIncrement; p; p = p->mNext)
-      count++;
+    count = ListLength(ourIncrement);
     if (NS_FAILED(content->AllocateCounterIncrements(count))) {
       break;
     }
 
     count = 0;
     for (const nsCSSValuePairList* p = ourIncrement; p; p = p->mNext, count++) {
       PRInt32 increment;
       if (p->mYValue.GetUnit() == eCSSUnit_Integer) {
         increment = p->mYValue.GetIntValue();
       } else {
         increment = 1;
       }
       p->mXValue.GetStringValue(buffer);
       content->SetCounterIncrementAt(count, buffer, increment);
     }
-  } break;
+    break;
+  }
 
   default:
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   // counter-reset: [string [int]]+, none, inherit
   switch (contentData.mCounterReset.GetUnit()) {
   case eCSSUnit_Null:
@@ -5856,35 +5867,34 @@ nsRuleNode::ComputeContentData(void* aSt
     break;
 
   case eCSSUnit_PairList:
   case eCSSUnit_PairListDep: {
     const nsCSSValuePairList* ourReset =
       contentData.mCounterReset.GetPairListValue();
     NS_ABORT_IF_FALSE(ourReset->mXValue.GetUnit() == eCSSUnit_Ident,
                       "unexpected value unit");
-    count = 0;
-    for (const nsCSSValuePairList* p = ourReset; p; p = p->mNext)
-      count++;
+    count = ListLength(ourReset);
     if (NS_FAILED(content->AllocateCounterResets(count))) {
       break;
     }
 
     count = 0;
     for (const nsCSSValuePairList* p = ourReset; p; p = p->mNext, count++) {
       PRInt32 reset;
       if (p->mYValue.GetUnit() == eCSSUnit_Integer) {
         reset = p->mYValue.GetIntValue();
       } else {
         reset = 0;
       }
       p->mXValue.GetStringValue(buffer);
       content->SetCounterResetAt(count, buffer, reset);
     }
-  } break;
+    break;
+  }
 
   default:
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   // marker-offset: length, auto, inherit
   SetCoord(contentData.mMarkerOffset, content->mMarkerOffset, parentContent->mMarkerOffset,
            SETCOORD_LH | SETCOORD_AUTO | SETCOORD_INITIAL_AUTO |
@@ -5924,38 +5934,36 @@ nsRuleNode::ComputeQuotesData(void* aSta
   case eCSSUnit_Initial:
     quotes->SetInitial();
     break;
   case eCSSUnit_None:
     quotes->AllocateQuotes(0);
     break;
   case eCSSUnit_PairList:
   case eCSSUnit_PairListDep: {
-    const nsCSSValuePairList* ourQuotes = contentData.mQuotes.GetPairListValue();
+    const nsCSSValuePairList* ourQuotes
+      = contentData.mQuotes.GetPairListValue();
     nsAutoString buffer;
     nsAutoString closeBuffer;
-    PRUint32 count = 0;
-
-    for (const nsCSSValuePairList* p = ourQuotes; p; p = p->mNext) {
-      count++;
-    }
+    PRUint32 count = ListLength(ourQuotes);
     if (NS_FAILED(quotes->AllocateQuotes(count))) {
       break;
     }
     count = 0;
     while (ourQuotes) {
       NS_ABORT_IF_FALSE(ourQuotes->mXValue.GetUnit() == eCSSUnit_String &&
                         ourQuotes->mYValue.GetUnit() == eCSSUnit_String,
                         "improper list contents for quotes");
       ourQuotes->mXValue.GetStringValue(buffer);
       ourQuotes->mYValue.GetStringValue(closeBuffer);
       quotes->SetQuotesAt(count++, buffer, closeBuffer);
       ourQuotes = ourQuotes->mNext;
     }
-  } break;
+    break;
+  }
   default:
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
   COMPUTE_END_INHERITED(Quotes, quotes)
 }
 
 const void*
@@ -6242,66 +6250,76 @@ nsRuleNode::ComputeSVGData(void* aStartS
               SETDSC_ENUMERATED, parentSVG->mShapeRendering,
               NS_STYLE_SHAPE_RENDERING_AUTO, 0, 0, 0, 0);
 
   // stroke:
   SetSVGPaint(SVGData.mStroke, parentSVG->mStroke, mPresContext, aContext,
               svg->mStroke, eStyleSVGPaintType_None, canStoreInRuleTree);
 
   // stroke-dasharray: <dasharray>, none, inherit
-  nsCSSValueList *list = SVGData.mStrokeDasharray;
-  if (list) {
-    if (eCSSUnit_Inherit == list->mValue.GetUnit()) {
-      canStoreInRuleTree = PR_FALSE;
-      // only do the copy if weren't already set up by the copy constructor
-      // FIXME Bug 389408: This is broken when aStartStruct is non-null!
-      if (!svg->mStrokeDasharray) {
-        svg->mStrokeDasharrayLength = parentSVG->mStrokeDasharrayLength;
-        if (svg->mStrokeDasharrayLength) {
-          svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
-          if (svg->mStrokeDasharray)
-            memcpy(svg->mStrokeDasharray,
-                   parentSVG->mStrokeDasharray,
-                   svg->mStrokeDasharrayLength * sizeof(nsStyleCoord));
-          else
-            svg->mStrokeDasharrayLength = 0;
-        }
+  switch (SVGData.mStrokeDasharray.GetUnit()) {
+  case eCSSUnit_Null:
+    break;
+
+  case eCSSUnit_Inherit:
+    canStoreInRuleTree = PR_FALSE;
+    // only do the copy if weren't already set up by the copy constructor
+    // FIXME Bug 389408: This is broken when aStartStruct is non-null!
+    if (!svg->mStrokeDasharray) {
+      svg->mStrokeDasharrayLength = parentSVG->mStrokeDasharrayLength;
+      if (svg->mStrokeDasharrayLength) {
+        svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
+        if (svg->mStrokeDasharray)
+          memcpy(svg->mStrokeDasharray,
+                 parentSVG->mStrokeDasharray,
+                 svg->mStrokeDasharrayLength * sizeof(nsStyleCoord));
+        else
+          svg->mStrokeDasharrayLength = 0;
+      }
+    }
+    break;
+
+  case eCSSUnit_Initial:
+  case eCSSUnit_None:
+    delete [] svg->mStrokeDasharray;
+    svg->mStrokeDasharray = nsnull;
+    svg->mStrokeDasharrayLength = 0;
+    break;
+
+  case eCSSUnit_List:
+  case eCSSUnit_ListDep: {
+    delete [] svg->mStrokeDasharray;
+    svg->mStrokeDasharray = nsnull;
+    svg->mStrokeDasharrayLength = 0;
+
+    // count number of values
+    const nsCSSValueList *value = SVGData.mStrokeDasharray.GetListValue();
+    svg->mStrokeDasharrayLength = ListLength(value);
+
+    NS_ASSERTION(svg->mStrokeDasharrayLength != 0, "no dasharray items");
+
+    svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
+
+    if (svg->mStrokeDasharray) {
+      PRUint32 i = 0;
+      while (nsnull != value) {
+        SetCoord(value->mValue,
+                 svg->mStrokeDasharray[i++], nsStyleCoord(),
+                 SETCOORD_LP | SETCOORD_FACTOR,
+                 aContext, mPresContext, canStoreInRuleTree);
+        value = value->mNext;
       }
     } else {
-      delete [] svg->mStrokeDasharray;
-      svg->mStrokeDasharray = nsnull;
       svg->mStrokeDasharrayLength = 0;
-
-      if (eCSSUnit_Initial != list->mValue.GetUnit() &&
-          eCSSUnit_None    != list->mValue.GetUnit()) {
-        // count number of values
-        nsCSSValueList *value = SVGData.mStrokeDasharray;
-        while (nsnull != value) {
-          ++svg->mStrokeDasharrayLength;
-          value = value->mNext;
-        }
-
-        NS_ASSERTION(svg->mStrokeDasharrayLength != 0, "no dasharray items");
-
-        svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
-
-        if (svg->mStrokeDasharray) {
-          value = SVGData.mStrokeDasharray;
-          PRUint32 i = 0;
-          while (nsnull != value) {
-            SetCoord(value->mValue,
-                     svg->mStrokeDasharray[i++], nsStyleCoord(),
-                     SETCOORD_LP | SETCOORD_FACTOR,
-                     aContext, mPresContext, canStoreInRuleTree);
-            value = value->mNext;
-          }
-        } else
-          svg->mStrokeDasharrayLength = 0;
-      }
-    }
+    }
+    break;
+  }
+
+  default:
+    NS_ABORT_IF_FALSE(false, "unrecognized dasharray unit");
   }
 
   // stroke-dashoffset: <dashoffset>, inherit
   SetCoord(SVGData.mStrokeDashoffset,
            svg->mStrokeDashoffset, parentSVG->mStrokeDashoffset,
            SETCOORD_LPH | SETCOORD_FACTOR | SETCOORD_INITIAL_ZERO,
            aContext, mPresContext, canStoreInRuleTree);
 
@@ -6627,17 +6645,16 @@ nsRuleNode::Sweep()
 
 /* static */ PRBool
 nsRuleNode::HasAuthorSpecifiedRules(nsStyleContext* aStyleContext,
                                     PRUint32 ruleTypeMask,
                                     PRBool aAuthorColorsAllowed)
 {
   nsRuleDataColor colorData;
   nsRuleDataMargin marginData;
-  nsCSSValue firstBackgroundImage;
   PRUint32 nValues = 0;
 
   PRUint32 inheritBits = 0;
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND)
     inheritBits |= NS_STYLE_INHERIT_BIT(Background);
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER)
     inheritBits |= NS_STYLE_INHERIT_BIT(Border);
@@ -6648,17 +6665,17 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
   /* We're relying on the use of |aStyleContext| not mutating it! */
   nsRuleData ruleData(inheritBits,
                       aStyleContext->PresContext(), aStyleContext);
   ruleData.mColorData = &colorData;
   ruleData.mMarginData = &marginData;
 
   nsCSSValue* backgroundValues[] = {
     &colorData.mBackColor,
-    &firstBackgroundImage
+    &colorData.mBackImage,
   };
 
   nsCSSValue* borderValues[] = {
     &marginData.mBorderColor.mTop,
     &marginData.mBorderStyle.mTop,
     &marginData.mBorderWidth.mTop,
     &marginData.mBorderColor.mRight,
     &marginData.mBorderStyle.mRight,
@@ -6681,27 +6698,30 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
     &marginData.mPaddingEnd
   };
 
   nsCSSValue* values[NS_ARRAY_LENGTH(backgroundValues) +
                      NS_ARRAY_LENGTH(borderValues) +
                      NS_ARRAY_LENGTH(paddingValues)];
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) {
-    memcpy(&values[nValues], backgroundValues, NS_ARRAY_LENGTH(backgroundValues) * sizeof(nsCSSValue*));
+    memcpy(&values[nValues], backgroundValues,
+           NS_ARRAY_LENGTH(backgroundValues) * sizeof(nsCSSValue*));
     nValues += NS_ARRAY_LENGTH(backgroundValues);
   }
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER) {
-    memcpy(&values[nValues], borderValues, NS_ARRAY_LENGTH(borderValues) * sizeof(nsCSSValue*));
+    memcpy(&values[nValues], borderValues,
+           NS_ARRAY_LENGTH(borderValues) * sizeof(nsCSSValue*));
     nValues += NS_ARRAY_LENGTH(borderValues);
   }
 
   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING) {
-    memcpy(&values[nValues], paddingValues, NS_ARRAY_LENGTH(paddingValues) * sizeof(nsCSSValue*));
+    memcpy(&values[nValues], paddingValues,
+           NS_ARRAY_LENGTH(paddingValues) * sizeof(nsCSSValue*));
     nValues += NS_ARRAY_LENGTH(paddingValues);
   }
 
   nsStyleContext* styleContext = aStyleContext;
 
   // We need to be careful not to count styles covered up by user-important or
   // UA-important declarations.  But we do want to catch explicit inherit
   // styling in those and check our parent style context to see whether we have
@@ -6715,32 +6735,16 @@ nsRuleNode::HasAuthorSpecifiedRules(nsSt
          ruleNode = ruleNode->GetParent()) {
       nsIStyleRule *rule = ruleNode->GetRule();
       if (rule) {
         ruleData.mLevel = ruleNode->GetLevel();
         ruleData.mIsImportantRule = ruleNode->IsImportantRule();
 
         rule->MapRuleInfoInto(&ruleData);
 
-        if ((ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) &&
-            colorData.mBackImage &&
-            firstBackgroundImage.GetUnit() == eCSSUnit_Null) {
-          // Handle background-image being a value list
-          firstBackgroundImage = colorData.mBackImage->mValue;
-        }
-        // Do the same nulling out as in GetBorderData, GetBackgroundData
-        // or GetPaddingData.
-        // We are sharing with some style rule.  It really owns the data.
-        marginData.mBoxShadow = nsnull;
-        colorData.mBackImage = nsnull;
-        colorData.mBackRepeat = nsnull;
-        colorData.mBackAttachment = nsnull;
-        colorData.mBackClip = nsnull;
-        colorData.mBackOrigin = nsnull;
-
         if (ruleData.mLevel == nsStyleSet::eAgentSheet ||
             ruleData.mLevel == nsStyleSet::eUserSheet) {
           // This is a rule whose effect we want to ignore, so if any of
           // the properties we care about were set, set them to the dummy
           // value that they'll never otherwise get.
           for (PRUint32 i = 0; i < nValues; ++i) {
             nsCSSUnit unit = values[i]->GetUnit();
             if (unit != eCSSUnit_Null &&
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -685,17 +685,17 @@ protected:
 
   const void* GetUIResetData(nsStyleContext* aContext);
   const void* GetXULData(nsStyleContext* aContext);
   const void* GetColumnData(nsStyleContext* aContext);
   const void* GetSVGData(nsStyleContext* aContext);
   const void* GetSVGResetData(nsStyleContext* aContext);
 
   already_AddRefed<nsCSSShadowArray>
-              GetShadowData(nsCSSValueList* aList,
+              GetShadowData(const nsCSSValueList* aList,
                             nsStyleContext* aContext,
                             PRBool aIsBoxShadow,
                             PRBool& inherited);
 
 private:
   nsRuleNode(nsPresContext* aPresContext, nsRuleNode* aParent,
              nsIStyleRule* aRule, PRUint8 aLevel, PRBool aIsImportant);
   ~nsRuleNode();
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -1815,20 +1815,18 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
     case eUnit_CSSRect: {
       nsCSSRect& rect = static_cast<nsCSSValue*>(aSpecifiedValue)->
         SetRectValue();
       rect = *aComputedValue.GetCSSRectValue();
     } break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
     case eUnit_Transform:
-      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                          eCSSType_ValueList, "type mismatch");
-      *static_cast<nsCSSValueList**>(aSpecifiedValue) =
-        aComputedValue.GetCSSValueListValue();
+      static_cast<nsCSSValue*>(aSpecifiedValue)->
+        SetDependentListValue(aComputedValue.GetCSSValueListValue());
       break;
     case eUnit_CSSValuePairList:
       static_cast<nsCSSValue*>(aSpecifiedValue)->
         SetDependentPairListValue(aComputedValue.GetCSSValuePairListValue());
       break;
     default:
       return PR_FALSE;
   }
@@ -1844,43 +1842,36 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
   NS_ABORT_IF_FALSE(aPresContext, "null pres context");
   aSpecifiedValue.Truncate(); // Clear outparam, if it's not already empty
 
   if (aComputedValue.GetUnit() == eUnit_UnparsedString) {
     aComputedValue.GetStringValue(aSpecifiedValue);
     return PR_TRUE;
   }
   nsCSSValue val;
-  nsCSSValueList* vl = nsnull;
   void *storage;
   switch (nsCSSProps::kTypeTable[aProperty]) {
     case eCSSType_Value:
       storage = &val;
       break;
-    case eCSSType_ValueList:
-      storage = &vl;
-      break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected case");
       storage = nsnull;
       break;
   }
 
   if (!nsStyleAnimation::UncomputeValue(aProperty, aPresContext,
                                         aComputedValue, storage)) {
     return PR_FALSE;
   }
 
   switch (nsCSSProps::kTypeTable[aProperty]) {
     case eCSSType_Value:
       val.AppendToString(aProperty, aSpecifiedValue);
       break;
-    case eCSSType_ValueList:
-      vl->AppendToString(aProperty, aSpecifiedValue);
-      break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected case");
       return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 inline const void*
diff --git a/layout/style/test/property_database.js b/layout/style/test/property_database.js
--- a/layout/style/test/property_database.js
+++ b/layout/style/test/property_database.js
@@ -1377,18 +1377,18 @@ var gCSSProperties = {
 		invalid_values: [ "fff", "ffffff", "#f", "#ff", "#ffff", "#fffff", "#fffffff", "#ffffffff", "#fffffffff" ]
 	},
 	"content": {
 		domProp: "content",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		/* XXX needs to be on pseudo-elements */
 		initial_values: [ "normal", "none" ],
-		other_values: [ '""', "''", '"hello"', "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==)", "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==')", 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")', 'counter(foo)', 'counter(bar, upper-roman)', 'counters(foo, ".")', "counters(bar, '-', lower-greek)", "'-' counter(foo) '.'", "attr(title)", "open-quote", "close-quote", "no-open-quote", "no-close-quote", "close-quote attr(title) counters(foo, '.', upper-alpha)", "counter(foo, none)", "counters(bar, '.', none)", "attr(\\32)", "attr(\\2)", "attr(-\\2)", "attr(-\\32)", "counter(\\2)", "counters(\\32, '.')", "counter(-\\32, upper-roman)", "counters(-\\2, '-', lower-greek)", "counter(\\()", "counters(a\\+b, '.')", "counter(\\}, upper-alpha)" ],
-		invalid_values: [ 'counters(foo)', 'counter(foo, ".")', 'attr("title")', "attr('title')", "attr(2)", "attr(-2)", "counter(2)", "counters(-2, '.')" ]
+		other_values: [ '""', "''", '"hello"', "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==)", "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==')", 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAKElEQVR42u3NQQ0AAAgEoNP+nTWFDzcoQE1udQQCgUAgEAgEAsGTYAGjxAE/G/Q2tQAAAABJRU5ErkJggg==")', 'counter(foo)', 'counter(bar, upper-roman)', 'counters(foo, ".")', "counters(bar, '-', lower-greek)", "'-' counter(foo) '.'", "attr(title)", "open-quote", "close-quote", "no-open-quote", "no-close-quote", "close-quote attr(title) counters(foo, '.', upper-alpha)", "counter(foo, none)", "counters(bar, '.', none)", "attr(\\32)", "attr(\\2)", "attr(-\\2)", "attr(-\\32)", "counter(\\2)", "counters(\\32, '.')", "counter(-\\32, upper-roman)", "counters(-\\2, '-', lower-greek)", "counter(\\()", "counters(a\\+b, '.')", "counter(\\}, upper-alpha)", "-moz-alt-content" ],
+		invalid_values: [ 'counters(foo)', 'counter(foo, ".")', 'attr("title")', "attr('title')", "attr(2)", "attr(-2)", "counter(2)", "counters(-2, '.')", "-moz-alt-content 'foo'", "'foo' -moz-alt-content" ]
 	},
 	"counter-increment": {
 		domProp: "counterIncrement",
 		inherited: false,
 		type: CSS_TYPE_LONGHAND,
 		initial_values: [ "none" ],
 		other_values: [ "foo 1", "bar", "foo 3 bar baz 2", "\\32  1", "-\\32  1", "-c 1", "\\32 1", "-\\32 1", "\\2  1", "-\\2  1", "-c 1", "\\2 1", "-\\2 1" ],
 		invalid_values: []
