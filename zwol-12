From: Zack Weinberg <zweinberg@mozilla.com>

Bug 576044 (12/12): fix assertions in nsStyleAnimation triggered by part 3.  r=dbaron  a2.0=dbaron

diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -119,68 +119,67 @@ lcm(PRUint32 a, PRUint32 b)
 PRBool
 nsStyleAnimation::ComputeDistance(nsCSSProperty aProperty,
                                   const Value& aStartValue,
                                   const Value& aEndValue,
                                   double& aDistance)
 {
   Unit commonUnit = GetCommonUnit(aStartValue.GetUnit(), aEndValue.GetUnit());
 
-  PRBool success = PR_TRUE;
   switch (commonUnit) {
     case eUnit_Null:
+    case eUnit_Auto:
     case eUnit_None:
+    case eUnit_Normal:
     case eUnit_UnparsedString:
-      success = PR_FALSE;
-      break;
+      return PR_FALSE;
+
     case eUnit_Enumerated:
       switch (aProperty) {
         case eCSSProperty_font_stretch: {
           // just like eUnit_Integer.
           PRInt32 startInt = aStartValue.GetIntValue();
           PRInt32 endInt = aEndValue.GetIntValue();
           aDistance = PR_ABS(endInt - startInt);
-          break;
+          return PR_TRUE;
         }
         default:
-          success = PR_FALSE;
-          break;
+          return PR_FALSE;
       }
-      break;
    case eUnit_Visibility: {
       PRInt32 startVal =
         aStartValue.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
       PRInt32 endVal =
         aEndValue.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
       aDistance = PR_ABS(startVal - endVal);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Integer: {
       PRInt32 startInt = aStartValue.GetIntValue();
       PRInt32 endInt = aEndValue.GetIntValue();
       aDistance = PR_ABS(endInt - startInt);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Coord: {
       nscoord startCoord = aStartValue.GetCoordValue();
       nscoord endCoord = aEndValue.GetCoordValue();
       aDistance = fabs(double(endCoord - startCoord));
-      break;
+      return PR_TRUE;
     }
     case eUnit_Percent: {
       float startPct = aStartValue.GetPercentValue();
       float endPct = aEndValue.GetPercentValue();
       aDistance = fabs(double(endPct - startPct));
-      break;
+      return PR_TRUE;
     }
     case eUnit_Float: {
       float startFloat = aStartValue.GetFloatValue();
       float endFloat = aEndValue.GetFloatValue();
       aDistance = fabs(double(endFloat - startFloat));
-      break;
+      return PR_TRUE;
     }
     case eUnit_Color: {
       // http://www.w3.org/TR/smil-animation/#animateColorElement says
       // that we should use Euclidean RGB cube distance.  However, we
       // have to extend that to RGBA.  For now, we'll just use the
       // Euclidean distance in the (part of the) 4-cube of premultiplied
       // colors.
       // FIXME (spec): The CSS transitions spec doesn't say whether
@@ -207,17 +206,17 @@ nsStyleAnimation::ComputeDistance(nsCSSP
       #undef GET_COMPONENT
 
       double diffA = startA - endA;
       double diffR = startR - endR;
       double diffG = startG - endG;
       double diffB = startB - endB;
       aDistance = sqrt(diffA * diffA + diffR * diffR +
                        diffG * diffG + diffB * diffB);
-      break;
+      return PR_TRUE;
     }
     case eUnit_CSSValuePair: {
       const nsCSSValuePair *pair1 = aStartValue.GetCSSValuePairValue();
       const nsCSSValuePair *pair2 = aEndValue.GetCSSValuePairValue();
       if (pair1->mXValue.GetUnit() != pair2->mXValue.GetUnit() ||
           pair1->mYValue.GetUnit() != pair2->mYValue.GetUnit()) {
         // At least until we have calc()
         return PR_FALSE;
@@ -245,17 +244,17 @@ nsStyleAnimation::ComputeDistance(nsCSSP
           default:
             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
             return PR_FALSE;
         }
         squareDistance += diff * diff;
       }
 
       aDistance = sqrt(squareDistance);
-      break;
+      return PR_TRUE;
     }
     case eUnit_CSSRect: {
       const nsCSSRect *rect1 = aStartValue.GetCSSRectValue();
       const nsCSSRect *rect2 = aEndValue.GetCSSRectValue();
       if (rect1->mTop.GetUnit() != rect2->mTop.GetUnit() ||
           rect1->mRight.GetUnit() != rect2->mRight.GetUnit() ||
           rect1->mBottom.GetUnit() != rect2->mBottom.GetUnit() ||
           rect1->mLeft.GetUnit() != rect2->mLeft.GetUnit()) {
@@ -281,32 +280,31 @@ nsStyleAnimation::ComputeDistance(nsCSSP
           default:
             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
             return PR_FALSE;
         }
         squareDistance += diff * diff;
       }
 
       aDistance = sqrt(squareDistance);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Dasharray: {
       // NOTE: This produces results on substantially different scales
       // for length values and percentage values, which might even be
       // mixed in the same property value.  This means the result isn't
       // particularly useful for paced animation.
 
       // Call AddWeighted to make us lists of the same length.
       Value normValue1, normValue2;
       if (!AddWeighted(aProperty, 1.0, aStartValue, 0.0, aEndValue,
                        normValue1) ||
           !AddWeighted(aProperty, 0.0, aStartValue, 1.0, aEndValue,
                        normValue2)) {
-        success = PR_FALSE;
-        break;
+        return PR_FALSE;
       }
 
       double squareDistance = 0.0;
       const nsCSSValueList *list1 = normValue1.GetCSSValueListValue();
       const nsCSSValueList *list2 = normValue2.GetCSSValueListValue();
 
       NS_ABORT_IF_FALSE(!list1 == !list2, "lists should be same length");
       while (list1) {
@@ -330,27 +328,26 @@ nsStyleAnimation::ComputeDistance(nsCSSP
         squareDistance += diff * diff;
 
         list1 = list1->mNext;
         list2 = list2->mNext;
         NS_ABORT_IF_FALSE(!list1 == !list2, "lists should be same length");
       }
 
       aDistance = sqrt(squareDistance);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Shadow: {
       // Call AddWeighted to make us lists of the same length.
       Value normValue1, normValue2;
       if (!AddWeighted(aProperty, 1.0, aStartValue, 0.0, aEndValue,
                        normValue1) ||
           !AddWeighted(aProperty, 0.0, aStartValue, 1.0, aEndValue,
                        normValue2)) {
-        success = PR_FALSE;
-        break;
+        return PR_FALSE;
       }
 
       const nsCSSValueList *shadow1 = normValue1.GetCSSValueListValue();
       const nsCSSValueList *shadow2 = normValue2.GetCSSValueListValue();
 
       double squareDistance = 0.0;
       NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
       while (shadow1) {
@@ -399,17 +396,17 @@ nsStyleAnimation::ComputeDistance(nsCSSP
           squareDistance += colorDistance * colorDistance;
         }
 
         shadow1 = shadow1->mNext;
         shadow2 = shadow2->mNext;
         NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
       }
       aDistance = sqrt(squareDistance);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Transform: {
       const nsCSSValueList *list1 = aStartValue.GetCSSValueListValue();
       const nsCSSValueList *list2 = aEndValue.GetCSSValueListValue();
 
       nsStyleTransformMatrix matrix1, matrix2; // initialized to identity
 
       PRBool dummy;
@@ -443,72 +440,63 @@ nsStyleAnimation::ComputeDistance(nsCSSP
       diff = matrix1.GetHeightRelativeXTranslation() -
              matrix2.GetHeightRelativeXTranslation();
       squareDistance += diff * diff;
       diff = matrix1.GetHeightRelativeYTranslation() -
              matrix2.GetHeightRelativeYTranslation();
       squareDistance += diff * diff;
 
       aDistance = sqrt(squareDistance);
-      break;
+      return PR_TRUE;
     }
     case eUnit_CSSValuePairList: {
       const nsCSSValuePairList *list1 = aStartValue.GetCSSValuePairListValue();
       const nsCSSValuePairList *list2 = aEndValue.GetCSSValuePairListValue();
       double squareDistance = 0.0;
       do {
         static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
           &nsCSSValuePairList::mXValue,
           &nsCSSValuePairList::mYValue,
         };
         for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairListValues); ++i) {
           const nsCSSValue &v1 = list1->*(pairListValues[i]);
           const nsCSSValue &v2 = list2->*(pairListValues[i]);
           if (v1.GetUnit() != v2.GetUnit()) {
-            success = PR_FALSE;
-            break; // to failure case
+            return PR_FALSE;
           }
           double diff = 0.0;
           switch (v1.GetUnit()) {
             case eCSSUnit_Pixel:
               diff = v1.GetFloatValue() - v2.GetFloatValue();
               break;
             case eCSSUnit_Percent:
               diff = v1.GetPercentValue() - v2.GetPercentValue();
               break;
             default:
               if (v1 != v2) {
-                success = PR_FALSE;
+                return PR_FALSE;
               }
               break;
           }
           squareDistance += diff * diff;
         }
-        if (!success) {
-          break; // to failure case
-        }
-
         list1 = list1->mNext;
         list2 = list2->mNext;
       } while (list1 && list2);
       if (list1 || list2) {
-        // We can't interpolate lists of different lengths.  (Also,
-        // failure cases above break to here.)
-        success = PR_FALSE;
-      } else {
-        aDistance = sqrt(squareDistance);
+        // We can't interpolate lists of different lengths.
+        return PR_FALSE;
       }
-      break;
+      aDistance = sqrt(squareDistance);
+      return PR_TRUE;
     }
-    default:
-      NS_NOTREACHED("Can't compute distance using the given common unit");
-      success = PR_FALSE;
-      break;
   }
-  return success;
+
+  NS_ABORT_IF_FALSE(false, "Can't compute distance using the given common unit");
+  return PR_FALSE;
 }
 
 inline void
 nscoordToCSSValue(nscoord aCoord, nsCSSValue& aCSSValue)
 {
   aCSSValue.SetFloatValue(nsPresContext::AppUnitsToFloatCSSPixels(aCoord),
                           eCSSUnit_Pixel);
 }
@@ -1178,75 +1166,74 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
                               Value& aResultValue)
 {
   Unit commonUnit = GetCommonUnit(aValue1.GetUnit(), aValue2.GetUnit());
   // Maybe need a followup method to convert the inputs into the common
   // unit-type, if they don't already match it. (Or would it make sense to do
   // that in GetCommonUnit? in which case maybe ConvertToCommonUnit would be
   // better.)
 
-  PRBool success = PR_TRUE;
   switch (commonUnit) {
     case eUnit_Null:
+    case eUnit_Auto:
     case eUnit_None:
+    case eUnit_Normal:
     case eUnit_UnparsedString:
-      success = PR_FALSE;
-      break;
+      return PR_FALSE;
+
     case eUnit_Enumerated:
       switch (aProperty) {
         case eCSSProperty_font_stretch: {
           // Animate just like eUnit_Integer.
           PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
                                     aCoeff2 * double(aValue2.GetIntValue()));
           aResultValue.SetIntValue(result, eUnit_Enumerated);
-          break;
+          return PR_TRUE;
         }
         default:
-          success = PR_FALSE;
-          break;
+          return PR_FALSE;
       }
-      break;
     case eUnit_Visibility: {
       PRInt32 val1 = aValue1.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
       PRInt32 val2 = aValue2.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
       double interp = aCoeff1 * val1 + aCoeff2 * val2;
       PRInt32 result = interp > 0.0 ? NS_STYLE_VISIBILITY_VISIBLE
                                     : NS_STYLE_VISIBILITY_HIDDEN;
       aResultValue.SetIntValue(result, eUnit_Visibility);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Integer: {
       // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
       // says we should use floor
       PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
                                 aCoeff2 * double(aValue2.GetIntValue()));
       if (aProperty == eCSSProperty_font_weight) {
         NS_ASSERTION(result > 0, "unexpected value");
         result -= result % 100;
       }
       aResultValue.SetIntValue(result, eUnit_Integer);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Coord: {
       aResultValue.SetCoordValue(NSToCoordRound(
         aCoeff1 * aValue1.GetCoordValue() +
         aCoeff2 * aValue2.GetCoordValue()));
-      break;
+      return PR_TRUE;
     }
     case eUnit_Percent: {
       aResultValue.SetPercentValue(
         aCoeff1 * aValue1.GetPercentValue() +
         aCoeff2 * aValue2.GetPercentValue());
-      break;
+      return PR_TRUE;
     }
     case eUnit_Float: {
       aResultValue.SetFloatValue(
         aCoeff1 * aValue1.GetFloatValue() +
         aCoeff2 * aValue2.GetFloatValue());
-      break;
+      return PR_TRUE;
     }
     case eUnit_Color: {
       nscolor color1 = aValue1.GetColorValue();
       nscolor color2 = aValue2.GetColorValue();
       // FIXME (spec): The CSS transitions spec doesn't say whether
       // colors are premultiplied, but things work better when they are,
       // so use premultiplication.  Spec issue is still open per
       // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
@@ -1272,17 +1259,17 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
         double factor = 1.0 / Aresf;
         PRUint8 Ares = NSToIntRound(Aresf * 255.0);
         PRUint8 Rres = ClampColor((R1 * aCoeff1 + R2 * aCoeff2) * factor);
         PRUint8 Gres = ClampColor((G1 * aCoeff1 + G2 * aCoeff2) * factor);
         PRUint8 Bres = ClampColor((B1 * aCoeff1 + B2 * aCoeff2) * factor);
         resultColor = NS_RGBA(Rres, Gres, Bres, Ares);
       }
       aResultValue.SetColorValue(resultColor);
-      break;
+      return PR_TRUE;
     }
     case eUnit_CSSValuePair: {
       const nsCSSValuePair *pair1 = aValue1.GetCSSValuePairValue();
       const nsCSSValuePair *pair2 = aValue2.GetCSSValuePairValue();
       if (pair1->mXValue.GetUnit() != pair2->mXValue.GetUnit() ||
           pair1->mYValue.GetUnit() != pair2->mYValue.GetUnit()) {
         // At least until we have calc()
         return PR_FALSE;
@@ -1310,17 +1297,17 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
           default:
             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
             return PR_FALSE;
         }
       }
 
       aResultValue.SetAndAdoptCSSValuePairValue(result.forget(),
                                                 eUnit_CSSValuePair);
-      break;
+      return PR_TRUE;
     }
     case eUnit_CSSRect: {
       const nsCSSRect *rect1 = aValue1.GetCSSRectValue();
       const nsCSSRect *rect2 = aValue2.GetCSSRectValue();
       if (rect1->mTop.GetUnit() != rect2->mTop.GetUnit() ||
           rect1->mRight.GetUnit() != rect2->mRight.GetUnit() ||
           rect1->mBottom.GetUnit() != rect2->mBottom.GetUnit() ||
           rect1->mLeft.GetUnit() != rect2->mLeft.GetUnit()) {
@@ -1349,17 +1336,17 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
             break;
           default:
             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
             return PR_FALSE;
         }
       }
 
       aResultValue.SetAndAdoptCSSRectValue(result.forget(), eUnit_CSSRect);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Dasharray: {
       const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
       const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
 
       PRUint32 len1 = 0, len2 = 0;
       for (const nsCSSValueList *v = list1; v; v = v->mNext) {
         ++len1;
@@ -1412,17 +1399,17 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
         list2 = list2->mNext;
         if (!list2) {
           list2 = aValue2.GetCSSValueListValue();
         }
       }
 
       aResultValue.SetAndAdoptCSSValueListValue(result.forget(),
                                                 eUnit_Dasharray);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Shadow: {
       // This is implemented according to:
       // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
       // and the third item in the summary of:
       // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
       const nsCSSValueList *shadow1 = aValue1.GetCSSValueListValue();
       const nsCSSValueList *shadow2 = aValue2.GetCSSValueListValue();
@@ -1451,24 +1438,23 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
         while (longShadow) {
           // Passing coefficients that add to less than 1 produces the
           // desired result of interpolating "0 0 0 transparent" with
           // the current shadow.
           if (!AddShadowItems(longCoeff, longShadow->mValue,
                               0.0, longShadow->mValue,
                               resultTail)) {
             return PR_FALSE;
-            break;
           }
 
           longShadow = longShadow->mNext;
         }
       }
       aResultValue.SetAndAdoptCSSValueListValue(result.forget(), eUnit_Shadow);
-      break;
+      return PR_TRUE;
     }
     case eUnit_Transform: {
       const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
       const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
 
       // We want to avoid the matrix decomposition when we can, since
       // avoiding it can produce better results both for compound
       // transforms and for skew and skewY (see below).  We can do this
@@ -1534,71 +1520,62 @@ nsStyleAnimation::AddWeighted(nsCSSPrope
     case eUnit_CSSValuePairList: {
       const nsCSSValuePairList *list1 = aValue1.GetCSSValuePairListValue();
       const nsCSSValuePairList *list2 = aValue2.GetCSSValuePairListValue();
       nsAutoPtr<nsCSSValuePairList> result;
       nsCSSValuePairList **resultTail = getter_Transfers(result);
       do {
         nsCSSValuePairList *item = new nsCSSValuePairList;
         if (!item) {
-          break; // to failure case
+          return PR_FALSE;
         }
         *resultTail = item;
         resultTail = &item->mNext;
 
         static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
           &nsCSSValuePairList::mXValue,
           &nsCSSValuePairList::mYValue,
         };
         for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairListValues); ++i) {
           const nsCSSValue &v1 = list1->*(pairListValues[i]);
           const nsCSSValue &v2 = list2->*(pairListValues[i]);
           nsCSSValue &vr = item->*(pairListValues[i]);
           if (v1.GetUnit() != v2.GetUnit()) {
-            success = PR_FALSE;
-            break; // to failure case
+            return PR_FALSE;
           }
           switch (v1.GetUnit()) {
             case eCSSUnit_Pixel:
               AddCSSValuePixel(aCoeff1, v1, aCoeff2, v2, vr);
               break;
             case eCSSUnit_Percent:
               AddCSSValuePercent(aCoeff1, v1, aCoeff2, v2, vr);
               break;
             default:
-              if (v1 == v2) {
-                vr = v1;
-              } else {
-                success = PR_FALSE;
+              if (v1 != v2) {
+                return PR_FALSE;
               }
+              vr = v1;
               break;
           }
         }
-        if (!success) {
-          break; // to failure case
-        }
-
         list1 = list1->mNext;
         list2 = list2->mNext;
       } while (list1 && list2);
       if (list1 || list2) {
-        // We can't interpolate lists of different lengths.  (Also,
-        // failure cases above break to here.)
-        success = PR_FALSE;
-      } else {
-        aResultValue.SetAndAdoptCSSValuePairListValue(result.forget());
+        // We can't interpolate lists of different lengths.
+        return PR_FALSE;
       }
-      break;
+
+      aResultValue.SetAndAdoptCSSValuePairListValue(result.forget());
+      return PR_TRUE;
     }
-    default:
-      NS_NOTREACHED("Can't interpolate using the given common unit");
-      success = PR_FALSE;
-      break;
   }
-  return success;
+
+  NS_ABORT_IF_FALSE(false, "Can't interpolate using the given common unit");
+  return PR_FALSE;
 }
 
 already_AddRefed<nsICSSStyleRule>
 BuildStyleRule(nsCSSProperty aProperty,
                nsIContent* aTargetElement,
                const nsAString& aSpecifiedValue,
                PRBool aUseSVGMode)
 {
