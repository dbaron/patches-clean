From: Zack Weinberg <zweinberg@mozilla.com>

Bug 576044 (2/12): eliminate ValuePair as a storage type.  r=dbaron  a2.0=dbaron

diff --git a/content/html/content/src/nsHTMLHRElement.cpp b/content/html/content/src/nsHTMLHRElement.cpp
--- a/content/html/content/src/nsHTMLHRElement.cpp
+++ b/content/html/content/src/nsHTMLHRElement.cpp
@@ -278,18 +278,18 @@ MapAttributesIntoRule(const nsMappedAttr
         borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID,
                                       eCSSUnit_Enumerated);
       }
 
       // If it would be noticeable, set the border radius to
       // 100% on all corners
       nsCSSCornerSizes& corners = aData->mMarginData->mBorderRadius;
 
-      NS_FOR_CSS_HALF_CORNERS(hc) {
-        nsCSSValue& dimen = corners.GetHalfCorner(hc);
+      NS_FOR_CSS_FULL_CORNERS(c) {
+        nsCSSValue& dimen = corners.GetCorner(c);
         if (dimen.GetUnit() == eCSSUnit_Null) {
           dimen.SetPercentValue(1.0f);
         }
       }
     }
   }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
     // color: a color
diff --git a/content/html/content/src/nsHTMLTableElement.cpp b/content/html/content/src/nsHTMLTableElement.cpp
--- a/content/html/content/src/nsHTMLTableElement.cpp
+++ b/content/html/content/src/nsHTMLTableElement.cpp
@@ -1056,33 +1056,32 @@ MapAttributesIntoRule(const nsMappedAttr
   // when the display type is changed).
 
   nsPresContext* presContext = aData->mPresContext;
   nsCompatibility mode = presContext->CompatibilityMode();
 
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(TableBorder)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL) {
-      // cellspacing 
+      // cellspacing
       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::cellspacing);
       if (value && value->Type() == nsAttrValue::eInteger) {
-        if (aData->mTableData->mBorderSpacing.mXValue.GetUnit() == eCSSUnit_Null)
-          aData->mTableData->mBorderSpacing.mXValue.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
-        if (aData->mTableData->mBorderSpacing.mYValue.GetUnit() == eCSSUnit_Null)
-          aData->mTableData->mBorderSpacing.mYValue.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
+        if (aData->mTableData->mBorderSpacing.GetUnit() == eCSSUnit_Null)
+          aData->mTableData->mBorderSpacing.
+            SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
       }
-      else if (value && value->Type() == nsAttrValue::ePercent && eCompatibility_NavQuirks == mode) {
+      else if (value && value->Type() == nsAttrValue::ePercent &&
+               eCompatibility_NavQuirks == mode) {
         // in quirks mode, treat a % cellspacing value a pixel value.
-        if (aData->mTableData->mBorderSpacing.mXValue.GetUnit() == eCSSUnit_Null)
-          aData->mTableData->mBorderSpacing.mXValue.SetFloatValue(100.0f * value->GetPercentValue(), eCSSUnit_Pixel);
-        if (aData->mTableData->mBorderSpacing.mYValue.GetUnit() == eCSSUnit_Null)
-          aData->mTableData->mBorderSpacing.mYValue.SetFloatValue(100.0f * value->GetPercentValue(), eCSSUnit_Pixel);
+        if (aData->mTableData->mBorderSpacing.GetUnit() == eCSSUnit_Null)
+          aData->mTableData->mBorderSpacing.
+            SetFloatValue(100.0f * value->GetPercentValue(), eCSSUnit_Pixel);
       }
     }
-  } 
+  }
   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Table)) {
     const nsStyleDisplay* readDisplay = aData->mStyleContext->GetStyleDisplay();
     if (readDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CELL) {
       const nsAttrValue* value;
       // layout
       if (aData->mTableData->mLayout.GetUnit() == eCSSUnit_Null) {
         value = aAttributes->GetAttr(nsGkAtoms::layout);
         if (value && value->Type() == nsAttrValue::eEnum)
diff --git a/layout/style/Declaration.cpp b/layout/style/Declaration.cpp
--- a/layout/style/Declaration.cpp
+++ b/layout/style/Declaration.cpp
@@ -137,20 +137,16 @@ PRBool Declaration::AppendValueToString(
     case eCSSType_Value:
       static_cast<const nsCSSValue*>(storage)->
         AppendToString(aProperty, aResult);
       break;
     case eCSSType_Rect:
       static_cast<const nsCSSRect*>(storage)->
         AppendToString(aProperty, aResult);
       break;
-    case eCSSType_ValuePair:
-      static_cast<const nsCSSValuePair*>(storage)->
-        AppendToString(aProperty, aResult);
-      break;
     case eCSSType_ValueList:
       (*static_cast<nsCSSValueList*const*>(storage))->
         AppendToString(aProperty, aResult);
       break;
     case eCSSType_ValuePairList:
       (*static_cast<nsCSSValuePairList*const*>(storage))->
         AppendToString(aProperty, aResult);
       break;
@@ -215,20 +211,16 @@ Declaration::GetValue(nsCSSProperty aPro
       case eCSSType_Value: {
         const nsCSSValue *val = static_cast<const nsCSSValue*>(storage);
         unit = val->GetUnit();
       } break;
       case eCSSType_Rect: {
         const nsCSSRect *rect = static_cast<const nsCSSRect*>(storage);
         unit = rect->mTop.GetUnit();
       } break;
-      case eCSSType_ValuePair: {
-        const nsCSSValuePair *pair = static_cast<const nsCSSValuePair*>(storage);
-        unit = pair->mXValue.GetUnit();
-      } break;
       case eCSSType_ValueList: {
         const nsCSSValueList* item =
             *static_cast<nsCSSValueList*const*>(storage);
         NS_ABORT_IF_FALSE(item, "null not allowed in compressed block");
         unit = item->mValue.GetUnit();
       } break;
       case eCSSType_ValuePairList: {
         const nsCSSValuePairList* item =
@@ -304,54 +296,52 @@ Declaration::GetValue(nsCSSProperty aPro
             aValue.Append(PRUnichar(' '));
             NS_ASSERTION(leftValue.GetUnit() != eCSSUnit_Null, "null left");
             leftValue.AppendToString(subprops[3], aValue);
           }
         }
       }
       break;
     }
-    case eCSSProperty__moz_border_radius: 
+    case eCSSProperty__moz_border_radius:
     case eCSSProperty__moz_outline_radius: {
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
-      NS_ASSERTION(nsCSSProps::kTypeTable[subprops[0]] == eCSSType_ValuePair &&
-                   nsCSSProps::kTypeTable[subprops[1]] == eCSSType_ValuePair &&
-                   nsCSSProps::kTypeTable[subprops[2]] == eCSSType_ValuePair &&
-                   nsCSSProps::kTypeTable[subprops[3]] == eCSSType_ValuePair,
-                   "type mismatch");
-      const nsCSSValuePair* vals[4] = {
-        data->ValuePairStorageFor(subprops[0]),
-        data->ValuePairStorageFor(subprops[1]),
-        data->ValuePairStorageFor(subprops[2]),
-        data->ValuePairStorageFor(subprops[3])
+      const nsCSSValue* vals[4] = {
+        data->ValueStorageFor(subprops[0]),
+        data->ValueStorageFor(subprops[1]),
+        data->ValueStorageFor(subprops[2]),
+        data->ValueStorageFor(subprops[3])
       };
 
-      vals[0]->mXValue.AppendToString(subprops[0], aValue);
-      aValue.Append(PRUnichar(' '));
-      vals[1]->mXValue.AppendToString(subprops[1], aValue);
-      aValue.Append(PRUnichar(' '));
-      vals[2]->mXValue.AppendToString(subprops[2], aValue);
-      aValue.Append(PRUnichar(' '));
-      vals[3]->mXValue.AppendToString(subprops[3], aValue);
-
       // For compatibility, only write a slash and the y-values
       // if they're not identical to the x-values.
-      if (vals[0]->mXValue != vals[0]->mYValue ||
-          vals[1]->mXValue != vals[1]->mYValue ||
-          vals[2]->mXValue != vals[2]->mYValue ||
-          vals[3]->mXValue != vals[3]->mYValue) {
+      PRBool needY = PR_FALSE;
+      for (int i = 0; i < 4; i++) {
+        if (vals[i]->GetUnit() == eCSSUnit_Pair) {
+          needY = PR_TRUE;
+          vals[i]->GetPairValue().mXValue.AppendToString(subprops[i], aValue);
+        } else {
+          vals[i]->AppendToString(subprops[i], aValue);
+        }
+        if (i < 3)
+          aValue.Append(PRUnichar(' '));
+      }
+
+      if (needY) {
         aValue.AppendLiteral(" / ");
-        vals[0]->mYValue.AppendToString(subprops[0], aValue);
-        aValue.Append(PRUnichar(' '));
-        vals[1]->mYValue.AppendToString(subprops[1], aValue);
-        aValue.Append(PRUnichar(' '));
-        vals[2]->mYValue.AppendToString(subprops[2], aValue);
-        aValue.Append(PRUnichar(' '));
-        vals[3]->mYValue.AppendToString(subprops[3], aValue);
+        for (int i = 0; i < 4; i++) {
+          if (vals[i]->GetUnit() == eCSSUnit_Pair) {
+            vals[i]->GetPairValue().mYValue.AppendToString(subprops[i], aValue);
+          } else {
+            vals[i]->AppendToString(subprops[i], aValue);
+          }
+          if (i < 3)
+            aValue.Append(PRUnichar(' '));
+        }
       }
       break;
     }
     case eCSSProperty_border: {
       const nsCSSProperty* subproptables[3] = {
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_style),
         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_width)
diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -46,20 +46,20 @@
 #include "nsRuleData.h"
 #include "nsRuleNode.h"
 #include "nsStyleSet.h"
 #include "nsStyleContext.h"
 
 namespace css = mozilla::css;
 
 /*
- * nsCSSCompressedDataBlock holds property-value pairs corresponding to
- * CSS declaration blocks.  The value is stored in one of the five CSS
- * data types: nsCSSValue, nsCSSRect, nsCSSValueList, nsCSSValuePair,
- * and nsCSSValuePairList, which each correspond to a value of the
+ * nsCSSCompressedDataBlock holds property-value pairs corresponding
+ * to CSS declaration blocks.  The value is stored in one of the four
+ * CSS data types: nsCSSValue, nsCSSRect, nsCSSValueList, and
+ * nsCSSValuePairList, which each correspond to a value of the
  * nsCSSType enumeration.
  *
  * The storage strategy uses the CDB*Storage structs below to help
  * ensure that all the types remain properly aligned.  nsCSSValue's
  * alignment requirements cannot be weaker than any others, since it
  * contains a pointer and an enumeration.
  *
  * The simple types, nsCSSValue and nsCSSRect have the nsCSSValue or
@@ -73,30 +73,24 @@ struct CDBValueStorage {
 };
 
 struct CDBRectStorage {
     nsCSSProperty property;
     nsCSSRect value;
 
 };
 
-struct CDBValuePairStorage {
-    nsCSSProperty property;
-    nsCSSValuePair value;
-};
-
 struct CDBPointerStorage {
     nsCSSProperty property;
     void *value;
 };
 
 enum {
     CDBValueStorage_advance = sizeof(CDBValueStorage),
     CDBRectStorage_advance = sizeof(CDBRectStorage),
-    CDBValuePairStorage_advance = sizeof(CDBValuePairStorage),
     // round up using the closest estimate we can get of the alignment
     // requirements of nsCSSValue:
     CDBPointerStorage_advance = PR_ROUNDUP(sizeof(CDBPointerStorage),
                                 sizeof(CDBValueStorage) - sizeof(nsCSSValue))
 };
 
 /*
  * Define a bunch of utility functions for getting the property or any
@@ -125,24 +119,16 @@ inline const nsCSSValue* ValueAtCursor(c
 inline nsCSSRect* RectAtCursor(char *aCursor) {
     return & reinterpret_cast<CDBRectStorage*>(aCursor)->value;
 }
 
 inline const nsCSSRect* RectAtCursor(const char *aCursor) {
     return & reinterpret_cast<const CDBRectStorage*>(aCursor)->value;
 }
 
-inline nsCSSValuePair* ValuePairAtCursor(char *aCursor) {
-  return & reinterpret_cast<CDBValuePairStorage*>(aCursor)->value;
-}
-
-inline const nsCSSValuePair* ValuePairAtCursor(const char *aCursor) {
-  return & reinterpret_cast<const CDBValuePairStorage*>(aCursor)->value;
-}
-
 inline void*& PointerAtCursor(char *aCursor) {
     return reinterpret_cast<CDBPointerStorage*>(aCursor)->value;
 }
 
 inline void* PointerAtCursor(const char *aCursor) {
     return reinterpret_cast<const CDBPointerStorage*>(aCursor)->value;
 }
 
@@ -290,34 +276,16 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                         target->mRight = val->mRight;
                     if (target->mBottom.GetUnit() == eCSSUnit_Null)
                         target->mBottom = val->mBottom;
                     if (target->mLeft.GetUnit() == eCSSUnit_Null)
                         target->mLeft = val->mLeft;
                     cursor += CDBRectStorage_advance;
                 } break;
 
-                case eCSSType_ValuePair: {
-                    NS_ABORT_IF_FALSE(!nsCSSProps::PropHasFlags(iProp,
-                        CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED),
-                        "this case needs to handle color properties");
-                    const nsCSSValuePair* val = ValuePairAtCursor(cursor);
-                    NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
-                                 val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
-                    nsCSSValuePair* target = static_cast<nsCSSValuePair*>(prop);
-                    NS_ASSERTION((target->mXValue.GetUnit() == eCSSUnit_Null)
-                              == (target->mYValue.GetUnit() == eCSSUnit_Null),
-                                 "half a property?");
-                    if (target->mXValue.GetUnit() == eCSSUnit_Null) {
-                        target->mXValue = val->mXValue;
-                        target->mYValue = val->mYValue;
-                    }
-                    cursor += CDBValuePairStorage_advance;
-                } break;
-
                 case eCSSType_ValueList:
                 case eCSSType_ValuePairList: {
                     void** target = static_cast<void**>(prop);
                     if (!*target) {
                         if (ShouldStartImageLoads(aRuleData, iProp)) {
                             for (nsCSSValueList* l = ValueListAtCursor(cursor);
                                  l; l = l->mNext) {
                                 TryToStartImageLoad(l->mValue, doc, iProp);
@@ -343,20 +311,16 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                 case eCSSType_Value: {
                     cursor += CDBValueStorage_advance;
                 } break;
 
                 case eCSSType_Rect: {
                     cursor += CDBRectStorage_advance;
                 } break;
 
-                case eCSSType_ValuePair: {
-                    cursor += CDBValuePairStorage_advance;
-                } break;
-
                 case eCSSType_ValueList:
                 case eCSSType_ValuePairList: {
                     cursor += CDBPointerStorage_advance;
                 } break;
             }
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
@@ -385,38 +349,31 @@ nsCSSCompressedDataBlock::StorageFor(nsC
         if (iProp == aProperty) {
             switch (nsCSSProps::kTypeTable[iProp]) {
                 case eCSSType_Value: {
                     return ValueAtCursor(cursor);
                 }
                 case eCSSType_Rect: {
                     return RectAtCursor(cursor);
                 }
-                case eCSSType_ValuePair: {
-                    return ValuePairAtCursor(cursor);
-                }
                 case eCSSType_ValueList:
                 case eCSSType_ValuePairList: {
                     return &PointerAtCursor(const_cast<char*>(cursor));
                 }
             }
         }
         switch (nsCSSProps::kTypeTable[iProp]) {
             case eCSSType_Value: {
                 cursor += CDBValueStorage_advance;
             } break;
 
             case eCSSType_Rect: {
                 cursor += CDBRectStorage_advance;
             } break;
 
-            case eCSSType_ValuePair: {
-                cursor += CDBValuePairStorage_advance;
-            } break;
-
             case eCSSType_ValueList:
             case eCSSType_ValuePairList: {
                 cursor += CDBPointerStorage_advance;
             } break;
         }
     }
     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
 
@@ -455,26 +412,16 @@ nsCSSCompressedDataBlock::Clone() const
                 const nsCSSRect* val = RectAtCursor(cursor);
                 NS_ASSERTION(val->HasValue(), "oops");
                 nsCSSRect* result_val = RectAtCursor(result_cursor);
                 new (result_val) nsCSSRect(*val);
                 cursor += CDBRectStorage_advance;
                 result_cursor += CDBRectStorage_advance;
             } break;
 
-            case eCSSType_ValuePair: {
-                const nsCSSValuePair* val = ValuePairAtCursor(cursor);
-                NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
-                             val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
-                nsCSSValuePair* result_val = ValuePairAtCursor(result_cursor);
-                new (result_val) nsCSSValuePair(*val);
-                cursor += CDBValuePairStorage_advance;
-                result_cursor += CDBValuePairStorage_advance;
-            } break;
-
             case eCSSType_ValueList:
             case eCSSType_ValuePairList: {
                 void *copy;
                 NS_ASSERTION(PointerAtCursor(cursor), "oops");
                 switch (nsCSSProps::kTypeTable[iProp]) {
                     default:
                         NS_NOTREACHED("unreachable");
                         // fall through to keep gcc's uninitialized
@@ -525,24 +472,16 @@ nsCSSCompressedDataBlock::~nsCSSCompress
 
             case eCSSType_Rect: {
                 const nsCSSRect* val = RectAtCursor(cursor);
                 NS_ASSERTION(val->HasValue(), "oops");
                 val->~nsCSSRect();
                 cursor += CDBRectStorage_advance;
             } break;
 
-            case eCSSType_ValuePair: {
-                const nsCSSValuePair* val = ValuePairAtCursor(cursor);
-                NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
-                             val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
-                val->~nsCSSValuePair();
-                cursor += CDBValuePairStorage_advance;
-            } break;
-
             case eCSSType_ValueList: {
                 nsCSSValueList* val = ValueListAtCursor(cursor);
                 NS_ASSERTION(val, "oops");
                 delete val;
                 cursor += CDBPointerStorage_advance;
             } break;
 
             case eCSSType_ValuePairList: {
@@ -585,26 +524,16 @@ nsCSSCompressedDataBlock::MoveValue(void
       nsCSSRect *dest = static_cast<nsCSSRect*>(aDest);
       if (*source != *dest)
         *aChanged = PR_TRUE;
       dest->~nsCSSRect();
       memcpy(dest, source, sizeof(nsCSSRect));
       new (source) nsCSSRect();
     } break;
 
-    case eCSSType_ValuePair: {
-      nsCSSValuePair *source = static_cast<nsCSSValuePair*>(aSource);
-      nsCSSValuePair *dest = static_cast<nsCSSValuePair*>(aDest);
-      if (*source != *dest)
-        *aChanged = PR_TRUE;
-      dest->~nsCSSValuePair();
-      memcpy(dest, source, sizeof(nsCSSValuePair));
-      new (source) nsCSSValuePair();
-    } break;
-
     case eCSSType_ValueList: {
       nsCSSValueList **source = static_cast<nsCSSValueList**>(aSource);
       nsCSSValueList **dest = static_cast<nsCSSValueList**>(aDest);
       if (**source != **dest)
         *aChanged = PR_TRUE;
       delete *dest;
       *dest = *source;
       *source = nsnull;
@@ -688,31 +617,16 @@ nsCSSExpandedDataBlock::DoExpand(nsCSSCo
                              "expanding into non-empty block");
 #ifdef NS_BUILD_REFCNT_LOGGING
                 dest->~nsCSSRect();
 #endif
                 memcpy(dest, val, sizeof(nsCSSRect));
                 cursor += CDBRectStorage_advance;
             } break;
 
-            case eCSSType_ValuePair: {
-                const nsCSSValuePair* val = ValuePairAtCursor(cursor);
-                nsCSSValuePair* dest = static_cast<nsCSSValuePair*>(prop);
-                NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
-                             val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
-                NS_ASSERTION(dest->mXValue.GetUnit() == eCSSUnit_Null &&
-                             dest->mYValue.GetUnit() == eCSSUnit_Null,
-                             "expanding into non-empty block");
-#ifdef NS_BUILD_REFCNT_LOGGING
-                dest->~nsCSSValuePair();
-#endif
-                memcpy(dest, val, sizeof(nsCSSValuePair));
-                cursor += CDBValuePairStorage_advance;
-            } break;
-
             case eCSSType_ValueList:
             case eCSSType_ValuePairList: {
                 void* val = PointerAtCursor(cursor);
                 void** dest = static_cast<void**>(prop);
                 NS_ASSERTION(val, "oops");
                 NS_ASSERTION(!*dest, "expanding into non-empty block");
                 *dest = val;
                 cursor += CDBPointerStorage_advance;
@@ -770,26 +684,16 @@ nsCSSExpandedDataBlock::ComputeSize()
 #ifdef DEBUG
                     nsCSSRect* val = static_cast<nsCSSRect*>(prop);
                     NS_ASSERTION(val->HasValue(),
                                  "Valueless rect while computing size");
 #endif
                     increment = CDBRectStorage_advance;
                 } break;
 
-                case eCSSType_ValuePair: {
-#ifdef DEBUG
-                    nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
-                    NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
-                                 val->mYValue.GetUnit() != eCSSUnit_Null,
-                                 "Valueless pair while computing size");
-#endif
-                    increment = CDBValuePairStorage_advance;
-                } break;
-
                 case eCSSType_ValueList:
                 case eCSSType_ValuePairList: {
 #ifdef DEBUG
                     void* val = *static_cast<void**>(prop);
                     NS_ASSERTION(val, "Null pointer while computing size");
 #endif
                     increment = CDBPointerStorage_advance;
                 } break;
@@ -872,29 +776,16 @@ nsCSSExpandedDataBlock::Compress(nsCSSCo
                     CDBRectStorage *storage =
                         reinterpret_cast<CDBRectStorage*>(cursor);
                     storage->property = iProp;
                     memcpy(&storage->value, val, sizeof(nsCSSRect));
                     new (val) nsCSSRect();
                     cursor += CDBRectStorage_advance;
                 } break;
 
-                case eCSSType_ValuePair: {
-                    nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
-                    NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
-                                 val->mYValue.GetUnit() != eCSSUnit_Null,
-                                 "Valueless pair while compressing");
-                    CDBValuePairStorage *storage =
-                        reinterpret_cast<CDBValuePairStorage*>(cursor);
-                    storage->property = iProp;
-                    memcpy(&storage->value, val, sizeof(nsCSSValuePair));
-                    new (val) nsCSSValuePair();
-                    cursor += CDBValuePairStorage_advance;
-                } break;
-
                 case eCSSType_ValueList:
                 case eCSSType_ValuePairList: {
                     void*& val = *static_cast<void**>(prop);
                     NS_ASSERTION(val, "Null pointer while compressing");
                     CDBPointerStorage *storage =
                         reinterpret_cast<CDBPointerStorage*>(cursor);
                     storage->property = iProp;
                     storage->value = val;
@@ -968,22 +859,16 @@ nsCSSExpandedDataBlock::ClearLonghandPro
             val->Reset();
         } break;
 
         case eCSSType_Rect: {
             nsCSSRect* val = static_cast<nsCSSRect*>(prop);
             val->Reset();
         } break;
 
-        case eCSSType_ValuePair: {
-            nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
-            val->mXValue.Reset();
-            val->mYValue.Reset();
-        } break;
-
         case eCSSType_ValueList: {
             nsCSSValueList*& val = *static_cast<nsCSSValueList**>(prop);
             if (val) {
                 delete val;
                 val = nsnull;
             }
         } break;
 
@@ -1088,24 +973,16 @@ nsCSSExpandedDataBlock::DoAssertInitialS
                 NS_ASSERTION(val->mRight.GetUnit() == eCSSUnit_Null,
                              "not initial state");
                 NS_ASSERTION(val->mBottom.GetUnit() == eCSSUnit_Null,
                              "not initial state");
                 NS_ASSERTION(val->mLeft.GetUnit() == eCSSUnit_Null,
                              "not initial state");
             } break;
 
-            case eCSSType_ValuePair: {
-                nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
-                NS_ASSERTION(val->mXValue.GetUnit() == eCSSUnit_Null,
-                             "not initial state");
-                NS_ASSERTION(val->mYValue.GetUnit() == eCSSUnit_Null,
-                             "not initial state");
-            } break;
-
             case eCSSType_ValueList: {
                 nsCSSValueList* val = *static_cast<nsCSSValueList**>(prop);
                 NS_ASSERTION(val == nsnull, "not initial state");
             } break;
 
             case eCSSType_ValuePairList: {
                 nsCSSValuePairList* val =
                   *static_cast<nsCSSValuePairList**>(prop);
diff --git a/layout/style/nsCSSDataBlock.h b/layout/style/nsCSSDataBlock.h
--- a/layout/style/nsCSSDataBlock.h
+++ b/layout/style/nsCSSDataBlock.h
@@ -107,22 +107,16 @@ public:
                         "type mismatch");
       return static_cast<const nsCSSValue*>(StorageFor(aProperty));
     }
     const nsCSSRect* RectStorageFor(nsCSSProperty aProperty) const {
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Rect,
                         "type mismatch");
       return static_cast<const nsCSSRect*>(StorageFor(aProperty));
     }
-    const nsCSSValuePair* ValuePairStorageFor(nsCSSProperty aProperty) const {
-      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                          eCSSType_ValuePair,
-                        "type mismatch");
-      return static_cast<const nsCSSValuePair*>(StorageFor(aProperty));
-    }
     const nsCSSValueList*const*
     ValueListStorageFor(nsCSSProperty aProperty) const {
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_ValueList,
                         "type mismatch");
       return static_cast<const nsCSSValueList*const*>(StorageFor(aProperty));
     }
     const nsCSSValuePairList*const*
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -517,18 +517,17 @@ protected:
   PRBool ParseTransitionTimingFunctionValues(nsCSSValue& aValue);
   PRBool ParseTransitionTimingFunctionValueComponent(float& aComponent,
                                                      char aStop,
                                                      PRBool aCheckRange);
   PRBool AppendValueToList(nsCSSValueList**& aListTail,
                            const nsCSSValue& aValue);
 
 #ifdef MOZ_SVG
-  PRBool ParsePaint(nsCSSValuePair* aResult,
-                    nsCSSProperty aPropID);
+  PRBool ParsePaint(nsCSSProperty aPropID);
   PRBool ParseDasharray();
   PRBool ParseMarker();
 #endif
 
   // Reused utility parsing routines
   void AppendValue(nsCSSProperty aPropID, const nsCSSValue& aValue);
   PRBool ParseBoxProperties(nsCSSRect& aResult,
                             const nsCSSProperty aPropIDs[]);
@@ -5091,31 +5090,30 @@ CSSParserImpl::ParseDirectionalBoxProper
 
 PRBool
 CSSParserImpl::ParseBoxCornerRadius(nsCSSProperty aPropID)
 {
   nsCSSValue dimenX, dimenY;
   // required first value
   if (! ParseNonNegativeVariant(dimenX, VARIANT_HLP, nsnull))
     return PR_FALSE;
+
   // optional second value (forbidden if first value is inherit/initial)
-  if (dimenX.GetUnit() == eCSSUnit_Inherit ||
-      dimenX.GetUnit() == eCSSUnit_Initial ||
-      ! ParseNonNegativeVariant(dimenY, VARIANT_LP, nsnull))
-    dimenY = dimenX;
-
-  NS_ASSERTION(nsCSSProps::kTypeTable[aPropID] == eCSSType_ValuePair,
-               nsPrintfCString(64, "type error (property='%s')",
-                               nsCSSProps::GetStringValue(aPropID).get())
-               .get());
-  nsCSSValuePair& storage =
-    *static_cast<nsCSSValuePair*>(mTempData.PropertyAt(aPropID));
-  storage.mXValue = dimenX;
-  storage.mYValue = dimenY;
-  mTempData.SetPropertyBit(aPropID);
+  if (dimenX.GetUnit() != eCSSUnit_Inherit &&
+      dimenX.GetUnit() != eCSSUnit_Initial) {
+    ParseNonNegativeVariant(dimenY, VARIANT_LP, nsnull);
+  }
+
+  if (dimenX == dimenY || dimenY.GetUnit() == eCSSUnit_Null) {
+    AppendValue(aPropID, dimenX);
+  } else {
+    nsCSSValue value;
+    value.SetPairValue(dimenX, dimenY);
+    AppendValue(aPropID, value);
+  }
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseBoxCornerRadii(nsCSSCornerSizes& aRadii,
                                    const nsCSSProperty aPropIDs[])
 {
   // Rectangles are used as scratch storage.
@@ -5168,20 +5166,26 @@ CSSParserImpl::ParseBoxCornerRadii(nsCSS
 
   switch (countY) {
     case 1: dimenY.mRight = dimenY.mTop;  // top-right same as top-left, and
     case 2: dimenY.mBottom = dimenY.mTop; // bottom-right same as top-left, and 
     case 3: dimenY.mLeft = dimenY.mRight; // bottom-left same as top-right
   }
 
   NS_FOR_CSS_SIDES(side) {
-    nsCSSValuePair& corner =
-      aRadii.GetFullCorner(NS_SIDE_TO_FULL_CORNER(side, PR_FALSE));
-    corner.mXValue = dimenX.*nsCSSRect::sides[side];
-    corner.mYValue = dimenY.*nsCSSRect::sides[side];
+    nsCSSValue& corner =
+      aRadii.GetCorner(NS_SIDE_TO_FULL_CORNER(side, PR_FALSE));
+    nsCSSValue& x = dimenX.*nsCSSRect::sides[side];
+    nsCSSValue& y = dimenY.*nsCSSRect::sides[side];
+
+    if (x == y) {
+      corner = x;
+    } else {
+      corner.SetPairValue(x, y);
+    }
     mTempData.SetPropertyBit(aPropIDs[side]);
   }
   return PR_TRUE;
 }
 
 // These must be in CSS order (top,right,bottom,left) for indexing to work
 static const nsCSSProperty kBorderStyleIDs[] = {
   eCSSProperty_border_top_style,
@@ -5401,19 +5405,18 @@ CSSParserImpl::ParseProperty(nsCSSProper
   case eCSSProperty_transition_timing_function:
     return ParseTransitionTimingFunction();
   case eCSSProperty_transition_duration:
   case eCSSProperty_transition_delay:
     return ParseTransitionTime(aPropID);
 
 #ifdef MOZ_SVG
   case eCSSProperty_fill:
-    return ParsePaint(&mTempData.mSVG.mFill, eCSSProperty_fill);
   case eCSSProperty_stroke:
-    return ParsePaint(&mTempData.mSVG.mStroke, eCSSProperty_stroke);
+    return ParsePaint(aPropID);
   case eCSSProperty_stroke_dasharray:
     return ParseDasharray();
   case eCSSProperty_marker:
     return ParseMarker();
 #endif
 
   // Strip out properties we use internally.
   case eCSSProperty__x_system_font:
@@ -6794,43 +6797,38 @@ CSSParserImpl::ParseBorderImage()
   mTempData.SetPropertyBit(eCSSProperty_border_image);
 
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseBorderSpacing()
 {
-  nsCSSValue  xValue;
-  if (ParseNonNegativeVariant(xValue, VARIANT_HL | VARIANT_CALC, nsnull)) {
-    if (xValue.IsLengthUnit() || xValue.IsCalcUnit()) {
-      // We have one length. Get the optional second length.
-      nsCSSValue yValue;
-      if (ParseNonNegativeVariant(yValue, VARIANT_LENGTH | VARIANT_CALC,
-                                  nsnull)) {
-        // We have two numbers
-        if (ExpectEndProperty()) {
-          mTempData.mTable.mBorderSpacing.mXValue = xValue;
-          mTempData.mTable.mBorderSpacing.mYValue = yValue;
-          mTempData.SetPropertyBit(eCSSProperty_border_spacing);
-          return PR_TRUE;
-        }
-        return PR_FALSE;
-      }
-    }
-
-    // We have one length which is the horizontal spacing. Create a value for
-    // the vertical spacing which is equal
-    if (ExpectEndProperty()) {
-      mTempData.mTable.mBorderSpacing.SetBothValuesTo(xValue);
-      mTempData.SetPropertyBit(eCSSProperty_border_spacing);
-      return PR_TRUE;
-    }
-  }
-  return PR_FALSE;
+  nsCSSValue xValue, yValue;
+  if (!ParseNonNegativeVariant(xValue, VARIANT_HL | VARIANT_CALC, nsnull)) {
+    return PR_FALSE;
+  }
+
+  // If we have one length, get the optional second length.
+  // set the second value equal to the first.
+  if (xValue.IsLengthUnit() || xValue.IsCalcUnit()) {
+    ParseNonNegativeVariant(yValue, VARIANT_LENGTH | VARIANT_CALC, nsnull);
+  }
+
+  if (!ExpectEndProperty()) {
+    return PR_FALSE;
+  }
+
+  if (yValue == xValue || yValue.GetUnit() == eCSSUnit_Null) {
+    mTempData.mTable.mBorderSpacing = xValue;
+  } else {
+    mTempData.mTable.mBorderSpacing.SetPairValue(xValue, yValue);
+  }
+  mTempData.SetPropertyBit(eCSSProperty_border_spacing);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseBorderSide(const nsCSSProperty aPropIDs[],
                                PRBool aSetAllSides)
 {
   const PRInt32 numProps = 3;
   nsCSSValue  values[numProps];
@@ -8187,22 +8185,32 @@ PRBool CSSParserImpl::ParseMozTransform(
   mTempData.SetPropertyBit(eCSSProperty__moz_transform);
   mTempData.mDisplay.mTransform = transformList;
 
   return PR_TRUE;
 }
 
 PRBool CSSParserImpl::ParseMozTransformOrigin()
 {
-  /* Read in a box position, fail if we can't. */
-  if (!ParseBoxPositionValues(mTempData.mDisplay.mTransformOrigin, PR_TRUE) ||
-      !ExpectEndProperty())
-    return PR_FALSE;
-
-  /* Set the property bit and return. */
+  nsCSSValuePair position;
+  if (!ParseBoxPositionValues(position, PR_TRUE) || !ExpectEndProperty())
+    return PR_FALSE;
+
+  // Unlike many other uses of pairs, this position should always be stored
+  // as a pair, even if the values are the same, so it always serializes as
+  // a pair, and to keep the computation code simple.
+  if (position.mXValue.GetUnit() == eCSSUnit_Inherit ||
+      position.mXValue.GetUnit() == eCSSUnit_Initial) {
+    NS_ABORT_IF_FALSE(position.mXValue == position.mYValue,
+                      "inherit/initial only half?");
+    mTempData.mDisplay.mTransformOrigin = position.mXValue;
+  } else {
+    mTempData.mDisplay.mTransformOrigin.SetPairValue(position.mXValue,
+                                                     position.mYValue);
+  }
   mTempData.SetPropertyBit(eCSSProperty__moz_transform_origin);
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseFamily(nsCSSValue& aValue)
 {
   if (!GetToken(PR_TRUE))
@@ -8672,37 +8680,34 @@ CSSParserImpl::ParseQuotes()
     }
   }
   return PR_FALSE;
 }
 
 PRBool
 CSSParserImpl::ParseSize()
 {
-  nsCSSValue width;
-  if (ParseVariant(width, VARIANT_AHKL, nsCSSProps::kPageSizeKTable)) {
-    if (width.IsLengthUnit()) {
-      nsCSSValue  height;
-      if (ParseVariant(height, VARIANT_LENGTH, nsnull)) {
-        if (ExpectEndProperty()) {
-          mTempData.mPage.mSize.mXValue = width;
-          mTempData.mPage.mSize.mYValue = height;
-          mTempData.SetPropertyBit(eCSSProperty_size);
-          return PR_TRUE;
-        }
-        return PR_FALSE;
-      }
-    }
-    if (ExpectEndProperty()) {
-      mTempData.mPage.mSize.SetBothValuesTo(width);
-      mTempData.SetPropertyBit(eCSSProperty_size);
-      return PR_TRUE;
-    }
-  }
-  return PR_FALSE;
+  nsCSSValue width, height;
+  if (!ParseVariant(width, VARIANT_AHKL, nsCSSProps::kPageSizeKTable)) {
+    return PR_FALSE;
+  }
+  if (width.IsLengthUnit()) {
+    ParseVariant(height, VARIANT_LENGTH, nsnull);
+  }
+  if (!ExpectEndProperty()) {
+    return PR_FALSE;
+  }
+
+  if (width == height || height.GetUnit() == eCSSUnit_Null) {
+    mTempData.mPage.mSize = width;
+  } else {
+    mTempData.mPage.mSize.SetPairValue(width, height);
+  }
+  mTempData.SetPropertyBit(eCSSProperty_size);
+  return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseTextDecoration(nsCSSValue& aValue)
 {
   if (ParseVariant(aValue, VARIANT_HK, nsCSSProps::kTextDecorationKTable)) {
     if (eCSSUnit_Enumerated == aValue.GetUnit()) {
       PRInt32 intValue = aValue.GetIntValue();
@@ -9316,36 +9321,35 @@ CSSParserImpl::SetDefaultNamespaceOnSele
     aSelector.SetNameSpace(mNameSpaceMap->FindNameSpaceID(nsnull));
   } else {
     aSelector.SetNameSpace(kNameSpaceID_Unknown); // wildcard
   }
 }
 
 #ifdef MOZ_SVG
 PRBool
-CSSParserImpl::ParsePaint(nsCSSValuePair* aResult,
-                          nsCSSProperty aPropID)
-{
-  if (!ParseVariant(aResult->mXValue,
-                    VARIANT_HC | VARIANT_NONE | VARIANT_URL,
-                    nsnull))
-    return PR_FALSE;
-
-  if (aResult->mXValue.GetUnit() == eCSSUnit_URL) {
-    if (!ParseVariant(aResult->mYValue, VARIANT_COLOR | VARIANT_NONE,
-                     nsnull))
-      aResult->mYValue.SetColorValue(NS_RGB(0, 0, 0));
+CSSParserImpl::ParsePaint(nsCSSProperty aPropID)
+{
+  nsCSSValue x, y;
+  if (!ParseVariant(x, VARIANT_HC | VARIANT_NONE | VARIANT_URL, nsnull))
+    return PR_FALSE;
+  if (x.GetUnit() == eCSSUnit_URL) {
+    if (!ParseVariant(y, VARIANT_COLOR | VARIANT_NONE, nsnull))
+      y.SetColorValue(NS_RGB(0, 0, 0));
+  }
+  if (!ExpectEndProperty())
+    return PR_FALSE;
+
+  if (x.GetUnit() != eCSSUnit_URL) {
+    AppendValue(aPropID, x);
   } else {
-    aResult->mYValue = aResult->mXValue;
-  }
-
-  if (!ExpectEndProperty())
-    return PR_FALSE;
-
-  mTempData.SetPropertyBit(aPropID);
+    nsCSSValue val;
+    val.SetPairValue(x, y);
+    AppendValue(aPropID, val);
+  }
   return PR_TRUE;
 }
 
 PRBool
 CSSParserImpl::ParseDasharray()
 {
   nsCSSValue value;
   if (ParseVariant(value, VARIANT_HLPN | VARIANT_NONE, nsnull)) {
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -308,99 +308,99 @@ CSS_PROP_SHORTHAND(
     0)
 CSS_PROP_BORDER(
     -moz-border-radius-topleft,
     _moz_border_radius_topLeft,
     MozBorderRadiusTopleft,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mTopLeft,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleBorder, mBorderRadius),
     eStyleAnimType_Corner_TopLeft)
 CSS_PROP_BORDER(
     -moz-border-radius-topright,
     _moz_border_radius_topRight,
     MozBorderRadiusTopright,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mTopRight,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleBorder, mBorderRadius),
     eStyleAnimType_Corner_TopRight)
 CSS_PROP_BORDER(
     -moz-border-radius-bottomright,
     _moz_border_radius_bottomRight,
     MozBorderRadiusBottomright,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mBottomRight,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleBorder, mBorderRadius),
     eStyleAnimType_Corner_BottomRight)
 CSS_PROP_BORDER(
     -moz-border-radius-bottomleft,
     _moz_border_radius_bottomLeft,
     MozBorderRadiusBottomleft,
     CSS_PROPERTY_APPLIES_TO_FIRST_LETTER,
     Margin,
     mBorderRadius.mBottomLeft,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleBorder, mBorderRadius),
     eStyleAnimType_Corner_BottomLeft)
 CSS_PROP_SHORTHAND(
     -moz-outline-radius,
     _moz_outline_radius,
     MozOutlineRadius,
     0)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-topleft,
     _moz_outline_radius_topLeft,
     MozOutlineRadiusTopleft,
     0,
     Margin,
     mOutlineRadius.mTopLeft,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleOutline, mOutlineRadius),
     eStyleAnimType_Corner_TopLeft)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-topright,
     _moz_outline_radius_topRight,
     MozOutlineRadiusTopright,
     0,
     Margin,
     mOutlineRadius.mTopRight,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleOutline, mOutlineRadius),
     eStyleAnimType_Corner_TopRight)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-bottomright,
     _moz_outline_radius_bottomRight,
     MozOutlineRadiusBottomright,
     0,
     Margin,
     mOutlineRadius.mBottomRight,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleOutline, mOutlineRadius),
     eStyleAnimType_Corner_BottomRight)
 CSS_PROP_OUTLINE(
     -moz-outline-radius-bottomleft,
     _moz_outline_radius_bottomLeft,
     MozOutlineRadiusBottomleft,
     0,
     Margin,
     mOutlineRadius.mBottomLeft,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleOutline, mOutlineRadius),
     eStyleAnimType_Corner_BottomLeft)
 CSS_PROP_TEXT(
     -moz-tab-size,
     _moz_tab_size,
     MozTabSize,
     0,
@@ -1001,17 +1001,17 @@ CSS_PROP_BORDER(
 #endif
 CSS_PROP_TABLEBORDER(
     border-spacing,
     border_spacing,
     BorderSpacing,
     0,
     Table,
     mBorderSpacing,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_Custom) // XXX bug 3935
 CSS_PROP_SHORTHAND(
     -moz-border-start,
     border_start,
     MozBorderStart,
     0)
@@ -2240,17 +2240,17 @@ CSS_PROP_POSITION(
     eStyleAnimType_Sides_Right)
 CSS_PROP_BACKENDONLY(
     size,
     size,
     Size,
     0,
     Page,
     mSize,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     kPageSizeKTable)
 CSS_PROP_BACKENDONLY(
     speak,
     speak,
     Speak,
     0,
     Aural,
     mSpeak,
@@ -2382,17 +2382,17 @@ CSS_PROP_DISPLAY(
     eStyleAnimType_Custom)
 CSS_PROP_DISPLAY(
     -moz-transform-origin,
     _moz_transform_origin,
     MozTransformOrigin,
     0,
     Display,
     mTransformOrigin,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     kBackgroundPositionKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_Custom)
 CSS_PROP_POSITION(
     top,
     top,
     Top,
     0,
@@ -2797,17 +2797,17 @@ CSS_PROP_SVGRESET(
     eStyleAnimType_EnumU8)
 CSS_PROP_SVG(
     fill,
     fill,
     Fill,
     0,
     SVG,
     mFill,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleSVG, mFill),
     eStyleAnimType_PaintServer)
 CSS_PROP_SVG(
     fill-opacity,
     fill_opacity,
     FillOpacity,
     0,
@@ -2967,17 +2967,17 @@ CSS_PROP_SVGRESET(
     eStyleAnimType_float)
 CSS_PROP_SVG(
     stroke,
     stroke,
     Stroke,
     0,
     SVG,
     mStroke,
-    eCSSType_ValuePair,
+    eCSSType_Value,
     nsnull,
     offsetof(nsStyleSVG, mStroke),
     eStyleAnimType_PaintServer)
 CSS_PROP_SVG(
     stroke-dasharray,
     stroke_dasharray,
     StrokeDasharray,
     CSS_PROPERTY_VALUE_LIST_USES_COMMAS,
diff --git a/layout/style/nsCSSProperty.h b/layout/style/nsCSSProperty.h
--- a/layout/style/nsCSSProperty.h
+++ b/layout/style/nsCSSProperty.h
@@ -79,17 +79,16 @@ enum nsCSSProperty {
   eCSSPropertyExtra_x_none_value
 };
 
 // The types of values that can be in the nsCSS*/nsRuleData* structs.
 // See nsCSSPropList.h for uses.
 enum nsCSSType {
   eCSSType_Value,
   eCSSType_Rect,
-  eCSSType_ValuePair,
   eCSSType_ValueList,
   eCSSType_ValuePairList
 };
 
 // The "descriptors" that can appear in a @font-face rule.
 // They have the syntax of properties but different value rules.
 // Keep in sync with kCSSRawFontDescs in nsCSSProps.cpp and
 // nsCSSFontFaceStyleDecl::Fields in nsCSSRules.cpp.
diff --git a/layout/style/nsCSSStruct.cpp b/layout/style/nsCSSStruct.cpp
--- a/layout/style/nsCSSStruct.cpp
+++ b/layout/style/nsCSSStruct.cpp
@@ -119,17 +119,17 @@ nsCSSCornerSizes::~nsCSSCornerSizes()
 {
   MOZ_COUNT_DTOR(nsCSSCornerSizes);
 }
 
 void
 nsCSSCornerSizes::Reset()
 {
   NS_FOR_CSS_FULL_CORNERS(corner) {
-    this->GetFullCorner(corner).Reset();
+    this->GetCorner(corner).Reset();
   }
 }
 
 PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT == 0 && NS_CORNER_TOP_RIGHT == 1 && \
     NS_CORNER_BOTTOM_RIGHT == 2 && NS_CORNER_BOTTOM_LEFT == 3);
 
 /* static */ const nsCSSCornerSizes::corner_type
 nsCSSCornerSizes::corners[4] = {
diff --git a/layout/style/nsCSSStruct.h b/layout/style/nsCSSStruct.h
--- a/layout/style/nsCSSStruct.h
+++ b/layout/style/nsCSSStruct.h
@@ -49,66 +49,56 @@
 #include "nsStyleConsts.h"
 
 struct nsCSSCornerSizes {
   nsCSSCornerSizes(void);
   nsCSSCornerSizes(const nsCSSCornerSizes& aCopy);
   ~nsCSSCornerSizes();
 
   // argument is a "full corner" constant from nsStyleConsts.h
-  nsCSSValuePair const & GetFullCorner(PRUint32 aCorner) const {
-    return (this->*corners[aCorner]);
+  nsCSSValue const & GetCorner(PRUint32 aCorner) const {
+    return this->*corners[aCorner];
   }
-  nsCSSValuePair & GetFullCorner(PRUint32 aCorner) {
-    return (this->*corners[aCorner]);
-  }
-
-  // argument is a "half corner" constant from nsStyleConsts.h
-  const nsCSSValue& GetHalfCorner(PRUint32 hc) const {
-    nsCSSValuePair const & fc = this->*corners[NS_HALF_TO_FULL_CORNER(hc)];
-    return NS_HALF_CORNER_IS_X(hc) ? fc.mXValue : fc.mYValue;
-  }
-  nsCSSValue & GetHalfCorner(PRUint32 hc) {
-    nsCSSValuePair& fc = this->*corners[NS_HALF_TO_FULL_CORNER(hc)];
-    return NS_HALF_CORNER_IS_X(hc) ? fc.mXValue : fc.mYValue;
+  nsCSSValue & GetCorner(PRUint32 aCorner) {
+    return this->*corners[aCorner];
   }
 
   PRBool operator==(const nsCSSCornerSizes& aOther) const {
     NS_FOR_CSS_FULL_CORNERS(corner) {
-      if (this->GetFullCorner(corner) != aOther.GetFullCorner(corner))
+      if (this->GetCorner(corner) != aOther.GetCorner(corner))
         return PR_FALSE;
     }
     return PR_TRUE;
   }
 
   PRBool operator!=(const nsCSSCornerSizes& aOther) const {
     NS_FOR_CSS_FULL_CORNERS(corner) {
-      if (this->GetFullCorner(corner) != aOther.GetFullCorner(corner))
+      if (this->GetCorner(corner) != aOther.GetCorner(corner))
         return PR_TRUE;
     }
     return PR_FALSE;
   }
 
   PRBool HasValue() const {
     NS_FOR_CSS_FULL_CORNERS(corner) {
-      if (this->GetFullCorner(corner).HasValue())
+      if (this->GetCorner(corner).GetUnit() != eCSSUnit_Null)
         return PR_TRUE;
     }
     return PR_FALSE;
   }
 
   void Reset();
 
-  nsCSSValuePair mTopLeft;
-  nsCSSValuePair mTopRight;
-  nsCSSValuePair mBottomRight;
-  nsCSSValuePair mBottomLeft;
+  nsCSSValue mTopLeft;
+  nsCSSValue mTopRight;
+  nsCSSValue mBottomRight;
+  nsCSSValue mBottomLeft;
 
 protected:
-  typedef nsCSSValuePair nsCSSCornerSizes::*corner_type;
+  typedef nsCSSValue nsCSSCornerSizes::*corner_type;
   static const corner_type corners[4];
 };
 
 struct nsCSSValueListRect {
   nsCSSValueListRect(void);
   nsCSSValueListRect(const nsCSSValueListRect& aCopy);
   ~nsCSSValueListRect();
 
@@ -240,17 +230,17 @@ struct nsCSSDisplay : public nsCSSStruct
   nsCSSRect  mClip;
   nsCSSValue mOverflowX;
   nsCSSValue mOverflowY;
   nsCSSValue mResize;
   nsCSSValue mPointerEvents;
   nsCSSValue mVisibility;
   nsCSSValue mOpacity;
   nsCSSValueList *mTransform; // List of Arrays containing transform information
-  nsCSSValuePair mTransformOrigin;
+  nsCSSValue mTransformOrigin;
   nsCSSValueList* mTransitionProperty;
   nsCSSValueList* mTransitionDuration;
   nsCSSValueList* mTransitionTimingFunction;
   nsCSSValueList* mTransitionDelay;
 
   // temp fix for bug 24000 
   nsCSSValue mBreakBefore;
   nsCSSValue mBreakAfter;
@@ -366,17 +356,17 @@ private:
   nsRuleDataList(const nsRuleDataList& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSTable : public nsCSSStruct  { // NEW
   nsCSSTable(void);
   ~nsCSSTable(void);
 
   nsCSSValue mBorderCollapse;
-  nsCSSValuePair mBorderSpacing;
+  nsCSSValue mBorderSpacing;
   nsCSSValue mCaptionSide;
   nsCSSValue mEmptyCells;
   
   nsCSSValue mLayout;
   nsCSSValue mSpan; // Not mappable via CSS, only using HTML4 table attrs.
   nsCSSValue mCols; // Not mappable via CSS, only using HTML4 table attrs.
 private:
   nsCSSTable(const nsCSSTable& aOther); // NOT IMPLEMENTED
@@ -409,17 +399,17 @@ private:
   nsRuleDataBreaks(const nsRuleDataBreaks& aOther); // NOT IMPLEMENTED
 };
 
 struct nsCSSPage : public nsCSSStruct  { // NEW
   nsCSSPage(void);
   ~nsCSSPage(void);
 
   nsCSSValue mMarks;
-  nsCSSValuePair mSize;
+  nsCSSValue mSize;
 private:
   nsCSSPage(const nsCSSPage& aOther); // NOT IMPLEMENTED
 };
 
 struct nsRuleDataPage : public nsCSSPage {
   nsRuleDataPage() {}
 private:
   nsRuleDataPage(const nsRuleDataPage& aOther); // NOT IMPLEMENTED
@@ -543,32 +533,32 @@ struct nsCSSSVG : public nsCSSStruct {
   nsCSSSVG(void);
   ~nsCSSSVG(void);
 
   nsCSSValue mClipPath;
   nsCSSValue mClipRule;
   nsCSSValue mColorInterpolation;
   nsCSSValue mColorInterpolationFilters;
   nsCSSValue mDominantBaseline;
-  nsCSSValuePair mFill;
+  nsCSSValue mFill;
   nsCSSValue mFillOpacity;
   nsCSSValue mFillRule;
   nsCSSValue mFilter;
   nsCSSValue mFloodColor;
   nsCSSValue mFloodOpacity;
   nsCSSValue mImageRendering;
   nsCSSValue mLightingColor;
   nsCSSValue mMarkerEnd;
   nsCSSValue mMarkerMid;
   nsCSSValue mMarkerStart;
   nsCSSValue mMask;
   nsCSSValue mShapeRendering;
   nsCSSValue mStopColor;
   nsCSSValue mStopOpacity;
-  nsCSSValuePair mStroke;
+  nsCSSValue mStroke;
   nsCSSValueList *mStrokeDasharray;
   nsCSSValue mStrokeDashoffset;
   nsCSSValue mStrokeLinecap;
   nsCSSValue mStrokeLinejoin;
   nsCSSValue mStrokeMiterlimit;
   nsCSSValue mStrokeOpacity;
   nsCSSValue mStrokeWidth;
   nsCSSValue mTextAnchor;
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -153,16 +153,20 @@ nsCSSValue::nsCSSValue(const nsCSSValue&
   else if (eCSSUnit_Image == mUnit) {
     mValue.mImage = aCopy.mValue.mImage;
     mValue.mImage->AddRef();
   }
   else if (eCSSUnit_Gradient == mUnit) {
     mValue.mGradient = aCopy.mValue.mGradient;
     mValue.mGradient->AddRef();
   }
+  else if (eCSSUnit_Pair == mUnit) {
+    mValue.mPair = aCopy.mValue.mPair;
+    mValue.mPair->AddRef();
+  }
   else {
     NS_NOTREACHED("unknown unit");
   }
 }
 
 nsCSSValue& nsCSSValue::operator=(const nsCSSValue& aCopy)
 {
   if (this != &aCopy) {
@@ -195,16 +199,19 @@ PRBool nsCSSValue::operator==(const nsCS
       return *mValue.mURL == *aOther.mValue.mURL;
     }
     else if (eCSSUnit_Image == mUnit) {
       return *mValue.mImage == *aOther.mValue.mImage;
     }
     else if (eCSSUnit_Gradient == mUnit) {
       return *mValue.mGradient == *aOther.mValue.mGradient;
     }
+    else if (eCSSUnit_Pair == mUnit) {
+      return *mValue.mPair == *aOther.mValue.mPair;
+    }
     else {
       return mValue.mFloat == aOther.mValue.mFloat;
     }
   }
   return PR_FALSE;
 }
 
 double nsCSSValue::GetAngleValueInRadians() const
@@ -262,16 +269,18 @@ void nsCSSValue::DoReset()
   } else if (UnitHasArrayValue()) {
     mValue.mArray->Release();
   } else if (eCSSUnit_URL == mUnit) {
     mValue.mURL->Release();
   } else if (eCSSUnit_Image == mUnit) {
     mValue.mImage->Release();
   } else if (eCSSUnit_Gradient == mUnit) {
     mValue.mGradient->Release();
+  } else if (eCSSUnit_Pair == mUnit) {
+    mValue.mPair->Release();
   }
   mUnit = eCSSUnit_Null;
 }
 
 void nsCSSValue::SetIntValue(PRInt32 aValue, nsCSSUnit aUnit)
 {
   NS_ASSERTION(aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
                aUnit == eCSSUnit_EnumColor, "not an int value");
@@ -352,16 +361,49 @@ void nsCSSValue::SetImageValue(nsCSSValu
 void nsCSSValue::SetGradientValue(nsCSSValueGradient* aValue)
 {
   Reset();
   mUnit = eCSSUnit_Gradient;
   mValue.mGradient = aValue;
   mValue.mGradient->AddRef();
 }
 
+void nsCSSValue::SetPairValue(const nsCSSValuePair* aValue)
+{
+  // pairs should not be used for null/inherit/initial values
+  NS_ABORT_IF_FALSE(aValue &&
+                    aValue->mXValue.GetUnit() != eCSSUnit_Null &&
+                    aValue->mYValue.GetUnit() != eCSSUnit_Null &&
+                    aValue->mXValue.GetUnit() != eCSSUnit_Inherit &&
+                    aValue->mYValue.GetUnit() != eCSSUnit_Inherit &&
+                    aValue->mXValue.GetUnit() != eCSSUnit_Initial &&
+                    aValue->mYValue.GetUnit() != eCSSUnit_Initial,
+                    "missing or inappropriate pair value");
+  Reset();
+  mUnit = eCSSUnit_Pair;
+  mValue.mPair = new nsCSSValuePair_heap(aValue->mXValue, aValue->mYValue);
+  mValue.mPair->AddRef();
+}
+
+void nsCSSValue::SetPairValue(const nsCSSValue& xValue,
+                              const nsCSSValue& yValue)
+{
+  NS_ABORT_IF_FALSE(xValue.GetUnit() != eCSSUnit_Null &&
+                    yValue.GetUnit() != eCSSUnit_Null &&
+                    xValue.GetUnit() != eCSSUnit_Inherit &&
+                    yValue.GetUnit() != eCSSUnit_Inherit &&
+                    xValue.GetUnit() != eCSSUnit_Initial &&
+                    yValue.GetUnit() != eCSSUnit_Initial,
+                    "inappropriate pair value");
+  Reset();
+  mUnit = eCSSUnit_Pair;
+  mValue.mPair = new nsCSSValuePair_heap(xValue, yValue);
+  mValue.mPair->AddRef();
+}
+
 void nsCSSValue::SetAutoValue()
 {
   Reset();
   mUnit = eCSSUnit_Auto;
 }
 
 void nsCSSValue::SetInheritValue()
 {
@@ -823,16 +865,18 @@ nsCSSValue::AppendToString(nsCSSProperty
       }
       if (++i == gradient->mStops.Length()) {
         break;
       }
       aResult.AppendLiteral(", ");
     }
 
     aResult.AppendLiteral(")");
+  } else if (eCSSUnit_Pair == unit) {
+    GetPairValue().AppendToString(aProperty, aResult);
   }
 
   switch (unit) {
     case eCSSUnit_Null:         break;
     case eCSSUnit_Auto:         aResult.AppendLiteral("auto");     break;
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
     case eCSSUnit_Initial:      aResult.AppendLiteral("-moz-initial"); break;
     case eCSSUnit_None:         aResult.AppendLiteral("none");     break;
@@ -869,16 +913,17 @@ nsCSSValue::AppendToString(nsCSSProperty
     case eCSSUnit_Calc_Maximum: break;
     case eCSSUnit_Integer:      break;
     case eCSSUnit_Enumerated:   break;
     case eCSSUnit_EnumColor:    break;
     case eCSSUnit_Color:        break;
     case eCSSUnit_Percent:      aResult.Append(PRUnichar('%'));    break;
     case eCSSUnit_Number:       break;
     case eCSSUnit_Gradient:     break;
+    case eCSSUnit_Pair:         break;
 
     case eCSSUnit_Inch:         aResult.AppendLiteral("in");   break;
     case eCSSUnit_Millimeter:   aResult.AppendLiteral("mm");   break;
     case eCSSUnit_PhysicalMillimeter: aResult.AppendLiteral("mozmm");   break;
     case eCSSUnit_Centimeter:   aResult.AppendLiteral("cm");   break;
     case eCSSUnit_Point:        aResult.AppendLiteral("pt");   break;
     case eCSSUnit_Pica:         aResult.AppendLiteral("pc");   break;
 
@@ -1019,33 +1064,21 @@ PR_STATIC_ASSERT((NS_SIDE_TOP == 0) && (
   &nsCSSRect::mRight,
   &nsCSSRect::mBottom,
   &nsCSSRect::mLeft,
 };
 
 // --- nsCSSValuePair -----------------
 
 void
-nsCSSValuePair::AppendToString(nsCSSProperty aProperty, nsAString& aResult) const
+nsCSSValuePair::AppendToString(nsCSSProperty aProperty,
+                               nsAString& aResult) const
 {
   mXValue.AppendToString(aProperty, aResult);
-  // Only output a Y value if it's different from the X value,
-  // or if it's a background-position value other than 'initial'
-  // or 'inherit', or if it's a -moz-transform-origin value other
-  // than 'initial' or 'inherit', or if it's a background-size
-  // value other than 'initial' or 'inherit' or 'contain' or 'cover'.
-  if (mYValue != mXValue ||
-      ((aProperty == eCSSProperty_background_position ||
-        aProperty == eCSSProperty__moz_transform_origin) &&
-       mXValue.GetUnit() != eCSSUnit_Inherit &&
-       mXValue.GetUnit() != eCSSUnit_Initial) ||
-      (aProperty == eCSSProperty_background_size &&
-       mXValue.GetUnit() != eCSSUnit_Inherit &&
-       mXValue.GetUnit() != eCSSUnit_Initial &&
-       mXValue.GetUnit() != eCSSUnit_Enumerated)) {
+  if (mYValue.GetUnit() != eCSSUnit_Null) {
     aResult.Append(PRUnichar(' '));
     mYValue.AppendToString(aProperty, aResult);
   }
 }
 
 // --- nsCSSValuePairList -----------------
 
 nsCSSValuePairList::~nsCSSValuePairList()
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -96,28 +96,31 @@ enum nsCSSUnit {
   eCSSUnit_Normal       = 5,      // (n/a) value is normal (algorithmic, different than auto)
   eCSSUnit_System_Font  = 6,      // (n/a) value is -moz-use-system-font
   eCSSUnit_All          = 7,      // (n/a) value is all
   eCSSUnit_Dummy        = 8,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
   eCSSUnit_DummyInherit = 9,      // (n/a) a fake but specified value, used
                                   //       only in temporary values
   eCSSUnit_RectIsAuto   = 10,     // (n/a) 'auto' for an entire rect()
+
   eCSSUnit_String       = 11,     // (PRUnichar*) a string value
   eCSSUnit_Ident        = 12,     // (PRUnichar*) a string value
   eCSSUnit_Families     = 13,     // (PRUnichar*) a string value
   eCSSUnit_Attr         = 14,     // (PRUnichar*) a attr(string) value
   eCSSUnit_Local_Font   = 15,     // (PRUnichar*) a local font name
   eCSSUnit_Font_Format  = 16,     // (PRUnichar*) a font format name
   eCSSUnit_Element      = 17,     // (PRUnichar*) an element id
+
   eCSSUnit_Array        = 20,     // (nsCSSValue::Array*) a list of values
   eCSSUnit_Counter      = 21,     // (nsCSSValue::Array*) a counter(string,[string]) value
   eCSSUnit_Counters     = 22,     // (nsCSSValue::Array*) a counters(string,string[,string]) value
   eCSSUnit_Cubic_Bezier = 23,     // (nsCSSValue::Array*) a list of float values
-  eCSSUnit_Function     = 24,     // (nsCSSValue::Array*) a function with parameters.  First elem of array is name,
+  eCSSUnit_Function     = 24,     // (nsCSSValue::Array*) a function with
+                                  //  parameters.  First elem of array is name,
                                   //  the rest of the values are arguments.
 
   // The top level of a calc() expression is either -moz-calc()
   // (eCSSUnit_Calc), -moz-min() (eCSSUnit_Calc_Minimum), or -moz-max()
   // (eCSSUnit_Calc_Maximum).  All remaining eCSSUnit_Calc_* units only
   // occur inside these toplevel calc values.
 
   // eCSSUnit_Calc has an array with exactly 1 element.  eCSSUnit_Calc
@@ -134,20 +137,25 @@ enum nsCSSUnit {
   eCSSUnit_Calc_Divided = 30,     // (nsCSSValue::Array*) / within calc
   // Minimum and Maximum have arrays with 1 or more elements
   eCSSUnit_Calc_Minimum = 31,     // (nsCSSValue::Array*) min() within calc
   eCSSUnit_Calc_Maximum = 32,     // (nsCSSValue::Array*) max() within calc
 
   eCSSUnit_URL          = 40,     // (nsCSSValue::URL*) value
   eCSSUnit_Image        = 41,     // (nsCSSValue::Image*) value
   eCSSUnit_Gradient     = 42,     // (nsCSSValueGradient*) value
-  eCSSUnit_Integer      = 50,     // (int) simple value
-  eCSSUnit_Enumerated   = 51,     // (int) value has enumerated meaning
+
+  eCSSUnit_Pair         = 50,     // (nsCSSValuePair*) pair of values
+
+  eCSSUnit_Integer      = 70,     // (int) simple value
+  eCSSUnit_Enumerated   = 71,     // (int) value has enumerated meaning
+
   eCSSUnit_EnumColor    = 80,     // (int) enumerated color (kColorKTable)
   eCSSUnit_Color        = 81,     // (nscolor) an RGBA value
+
   eCSSUnit_Percent      = 90,     // (float) 1.0 == 100%) value is percentage of something
   eCSSUnit_Number       = 91,     // (float) value is numeric (usually multiplier, different behavior that percent)
 
   // Physical length units
   eCSSUnit_PhysicalMillimeter = 200,   // (float) 1/25.4 inch
 
   // Length units - relative
   // Font relative measure
@@ -174,16 +182,18 @@ enum nsCSSUnit {
   eCSSUnit_Kilohertz    = 2001,    // (float) 1000 Hertz
 
   // Time units
   eCSSUnit_Seconds      = 3000,    // (float) Standard time
   eCSSUnit_Milliseconds = 3001     // (float) 1/1000 second
 };
 
 struct nsCSSValueGradient;
+struct nsCSSValuePair;
+struct nsCSSValuePair_heap;
 
 class nsCSSValue {
 public:
   struct Array;
   friend struct Array;
 
   struct URL;
   friend struct URL;
@@ -330,16 +340,19 @@ public:
   }
 
   nsCSSValueGradient* GetGradientValue() const
   {
     NS_ASSERTION(mUnit == eCSSUnit_Gradient, "not a gradient value");
     return mValue.mGradient;
   }
 
+  inline nsCSSValuePair& GetPairValue(); // body below
+  inline const nsCSSValuePair& GetPairValue() const; // body below
+
   URL* GetURLStructValue() const
   {
     // Not allowing this for Image values, because if the caller takes
     // a ref to them they won't be able to delete them properly.
     NS_ASSERTION(mUnit == eCSSUnit_URL, "not a URL value");
     return mValue.mURL;
   }
 
@@ -373,16 +386,18 @@ public:
   void SetPercentValue(float aValue);
   void SetFloatValue(float aValue, nsCSSUnit aUnit);
   void SetStringValue(const nsString& aValue, nsCSSUnit aUnit);
   void SetColorValue(nscolor aValue);
   void SetArrayValue(nsCSSValue::Array* aArray, nsCSSUnit aUnit);
   void SetURLValue(nsCSSValue::URL* aURI);
   void SetImageValue(nsCSSValue::Image* aImage);
   void SetGradientValue(nsCSSValueGradient* aGradient);
+  void SetPairValue(const nsCSSValuePair* aPair);
+  void SetPairValue(const nsCSSValue& xValue, const nsCSSValue& yValue);
   void SetAutoValue();
   void SetInheritValue();
   void SetInitialValue();
   void SetNoneValue();
   void SetAllValue();
   void SetNormalValue();
   void SetSystemFontValue();
   void SetDummyValue();
@@ -464,16 +479,17 @@ protected:
     // Note: the capacity of the buffer may exceed the length of the string.
     // If we're of a string type, mString is not null.
     nsStringBuffer* mString;
     nscolor    mColor;
     Array*     mArray;
     URL*       mURL;
     Image*     mImage;
     nsCSSValueGradient* mGradient;
+    nsCSSValuePair_heap* mPair;
   }         mValue;
 };
 
 struct nsCSSValue::Array {
 
   // return |Array| with reference count of zero
   static Array* Create(size_t aItemCount) {
     return new (aItemCount) Array(aItemCount);
@@ -696,16 +712,44 @@ struct nsCSSValuePair {
   }
 
   void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
 
   nsCSSValue mXValue;
   nsCSSValue mYValue;
 };
 
+// nsCSSValuePair_heap differs from nsCSSValuePair only in being
+// refcounted.  It should not be necessary to use this class directly;
+// it's an implementation detail of nsCSSValue.
+struct nsCSSValuePair_heap : public nsCSSValuePair {
+  // forward constructor
+  nsCSSValuePair_heap(const nsCSSValue& aXValue, const nsCSSValue& aYValue)
+    : nsCSSValuePair(aXValue, aYValue)
+  {}
+
+  NS_INLINE_DECL_REFCOUNTING(nsCSSValuePair_heap)
+};
+
+// This has to be here so that the relationship between nsCSSValuePair
+// and nsCSSValuePair_heap is visible.
+inline nsCSSValuePair&
+nsCSSValue::GetPairValue()
+{
+  NS_ASSERTION(mUnit == eCSSUnit_Pair, "not a pair value");
+  return *mValue.mPair;
+}
+
+inline const nsCSSValuePair&
+nsCSSValue::GetPairValue() const
+{
+  NS_ASSERTION(mUnit == eCSSUnit_Pair, "not a pair value");
+  return *mValue.mPair;
+}
+
 // Maybe should be replaced with nsCSSValueList and nsCSSValue::Array?
 struct nsCSSValuePairList {
   nsCSSValuePairList() : mNext(nsnull) { MOZ_COUNT_CTOR(nsCSSValuePairList); }
   ~nsCSSValuePairList();
 
   nsCSSValuePairList* Clone() const; // makes a deep copy
   void AppendToString(nsCSSProperty aProperty, nsAString& aResult) const;
 
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -548,16 +548,41 @@ struct ComputeComputedCalcCalcOps : publ
 /* static */ nscoord
 nsRuleNode::ComputeComputedCalc(const nsStyleCoord& aValue,
                                 nscoord aPercentageBasis)
 {
   ComputeComputedCalcCalcOps ops(aPercentageBasis);
   return css::ComputeCalc(aValue, ops);
 }
 
+/* Given an enumerated value that represents a box position, converts it to
+ * a float representing the percentage of the box it corresponds to.  For
+ * example, "center" becomes 0.5f.
+ *
+ * @param aEnumValue The enumerated value.
+ * @return The float percent it corresponds to.
+ */
+static float
+GetFloatFromBoxPosition(PRInt32 aEnumValue)
+{
+  switch (aEnumValue) {
+  case NS_STYLE_BG_POSITION_LEFT:
+  case NS_STYLE_BG_POSITION_TOP:
+    return 0.0f;
+  case NS_STYLE_BG_POSITION_RIGHT:
+  case NS_STYLE_BG_POSITION_BOTTOM:
+    return 1.0f;
+  default:
+    NS_NOTREACHED("unexpected value");
+    // fall through
+  case NS_STYLE_BG_POSITION_CENTER:
+    return 0.5f;
+  }
+}
+
 #define SETCOORD_NORMAL                 0x01   // N
 #define SETCOORD_AUTO                   0x02   // A
 #define SETCOORD_INHERIT                0x04   // H
 #define SETCOORD_PERCENT                0x08   // P
 #define SETCOORD_FACTOR                 0x10   // F
 #define SETCOORD_LENGTH                 0x20   // L
 #define SETCOORD_INTEGER                0x40   // I
 #define SETCOORD_ENUMERATED             0x80   // E
@@ -565,16 +590,17 @@ nsRuleNode::ComputeComputedCalc(const ns
 #define SETCOORD_INITIAL_ZERO           0x200
 #define SETCOORD_INITIAL_AUTO           0x400
 #define SETCOORD_INITIAL_NONE           0x800
 #define SETCOORD_INITIAL_NORMAL         0x1000
 #define SETCOORD_INITIAL_HALF           0x2000
 #define SETCOORD_CALC_LENGTH_ONLY       0x4000
 #define SETCOORD_CALC_CLAMP_NONNEGATIVE 0x8000 // modifier for CALC_LENGTH_ONLY
 #define SETCOORD_STORE_CALC             0x00010000
+#define SETCOORD_BOX_POSITION           0x00020000 // exclusive with _ENUMERATED
 
 #define SETCOORD_LP     (SETCOORD_LENGTH | SETCOORD_PERCENT)
 #define SETCOORD_LH     (SETCOORD_LENGTH | SETCOORD_INHERIT)
 #define SETCOORD_AH     (SETCOORD_AUTO | SETCOORD_INHERIT)
 #define SETCOORD_LAH    (SETCOORD_AUTO | SETCOORD_LENGTH | SETCOORD_INHERIT)
 #define SETCOORD_LPH    (SETCOORD_LP | SETCOORD_INHERIT)
 #define SETCOORD_LPAH   (SETCOORD_LP | SETCOORD_AH)
 #define SETCOORD_LPEH   (SETCOORD_LP | SETCOORD_ENUMERATED | SETCOORD_INHERIT)
@@ -618,16 +644,20 @@ static PRBool SetCoord(const nsCSSValue&
   else if (((aMask & SETCOORD_INTEGER) != 0) &&
            (aValue.GetUnit() == eCSSUnit_Integer)) {
     aCoord.SetIntValue(aValue.GetIntValue(), eStyleUnit_Integer);
   }
   else if (((aMask & SETCOORD_ENUMERATED) != 0) &&
            (aValue.GetUnit() == eCSSUnit_Enumerated)) {
     aCoord.SetIntValue(aValue.GetIntValue(), eStyleUnit_Enumerated);
   }
+  else if (((aMask & SETCOORD_BOX_POSITION) != 0) &&
+           (aValue.GetUnit() == eCSSUnit_Enumerated)) {
+    aCoord.SetPercentValue(GetFloatFromBoxPosition(aValue.GetIntValue()));
+  }
   else if (((aMask & SETCOORD_AUTO) != 0) &&
            (aValue.GetUnit() == eCSSUnit_Auto)) {
     aCoord.SetAutoValue();
   }
   else if (((aMask & SETCOORD_INHERIT) != 0) &&
            (aValue.GetUnit() == eCSSUnit_Inherit)) {
     aCoord = aParentCoord;  // just inherit value from parent
     aCanStoreInRuleTree = PR_FALSE;
@@ -703,38 +733,37 @@ static inline PRBool SetAbsCoord(const n
                        dummyStyleContext, dummyPresContext,
                        dummyCanStoreInRuleTree);
   NS_ABORT_IF_FALSE(dummyCanStoreInRuleTree,
                     "SetCoord() should not modify dummyCanStoreInRuleTree.");
 
   return rv;
 }
 
-/* Given an enumerated value that represents a box position, converts it to
- * a float representing the percentage of the box it corresponds to.  For
- * example, "center" becomes 0.5f.
- *
- * @param aEnumValue The enumerated value.
- * @return The float percent it corresponds to.
+/* Given a specified value that might be a pair value, call SetCoord twice,
+ * either using each member of the pair, or using the unpaired value twice.
  */
-static float GetFloatFromBoxPosition(PRInt32 aEnumValue)
+static PRBool
+SetPairCoords(const nsCSSValue& aValue,
+              nsStyleCoord& aCoordX, nsStyleCoord& aCoordY,
+              const nsStyleCoord& aParentX, const nsStyleCoord& aParentY,
+              PRInt32 aMask, nsStyleContext* aStyleContext,
+              nsPresContext* aPresContext, PRBool& aCanStoreInRuleTree)
 {
-  switch (aEnumValue) {
-  case NS_STYLE_BG_POSITION_LEFT:
-  case NS_STYLE_BG_POSITION_TOP:
-    return 0.0f;
-  case NS_STYLE_BG_POSITION_RIGHT:
-  case NS_STYLE_BG_POSITION_BOTTOM:
-    return 1.0f;
-  default:
-    NS_NOTREACHED("unexpected value");
-    // fall through
-  case NS_STYLE_BG_POSITION_CENTER:
-    return 0.5f;
-  }
+  const nsCSSValue& valX =
+    aValue.GetUnit() == eCSSUnit_Pair ? aValue.GetPairValue().mXValue : aValue;
+  const nsCSSValue& valY =
+    aValue.GetUnit() == eCSSUnit_Pair ? aValue.GetPairValue().mYValue : aValue;
+
+  PRBool cX = SetCoord(valX, aCoordX, aParentX, aMask, aStyleContext,
+                       aPresContext, aCanStoreInRuleTree);
+  PRBool cY = SetCoord(valY, aCoordY, aParentY, aMask, aStyleContext,
+                       aPresContext, aCanStoreInRuleTree);
+  NS_ABORT_IF_FALSE(cX == cY, "changed one but not the other");
+  return cX;
 }
 
 static PRBool SetColor(const nsCSSValue& aValue, const nscolor aParentColor,
                        nsPresContext* aPresContext, nsStyleContext *aContext,
                        nscolor& aResult, PRBool& aCanStoreInRuleTree)
 {
   PRBool  result = PR_FALSE;
   nsCSSUnit unit = aValue.GetUnit();
@@ -792,24 +821,19 @@ static PRBool SetColor(const nsCSSValue&
   }
   return result;
 }
 
 static void SetGradientCoord(const nsCSSValue& aValue, nsPresContext* aPresContext,
                              nsStyleContext* aContext, nsStyleCoord& aResult,
                              PRBool& aCanStoreInRuleTree)
 {
-  // If coordinate is an enumerated type, handle it explicitly.
-  if (aValue.GetUnit() == eCSSUnit_Enumerated) {
-    aResult.SetPercentValue(GetFloatFromBoxPosition(aValue.GetIntValue()));
-    return;
-  }
-
   // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
-  if (!SetCoord(aValue, aResult, nsStyleCoord(), SETCOORD_LPO,
+  if (!SetCoord(aValue, aResult, nsStyleCoord(),
+                SETCOORD_LPO | SETCOORD_BOX_POSITION,
                 aContext, aPresContext, aCanStoreInRuleTree)) {
     NS_NOTREACHED("unexpected unit for gradient anchor point");
     aResult.SetNoneValue();
   }
 }
 
 static void SetGradient(const nsCSSValue& aValue, nsPresContext* aPresContext,
                         nsStyleContext* aContext, nsStyleGradient& aResult,
@@ -1377,26 +1401,16 @@ ExamineCSSValue(const nsCSSValue& aValue
     ++aSpecifiedCount;
     if (aValue.GetUnit() == eCSSUnit_Inherit) {
       ++aInheritedCount;
     }
   }
 }
 
 static void
-ExamineCSSValuePair(const nsCSSValuePair* aValuePair,
-                    PRUint32& aSpecifiedCount, PRUint32& aInheritedCount)
-{
-  NS_PRECONDITION(aValuePair, "Must have a value pair");
-
-  ExamineCSSValue(aValuePair->mXValue, aSpecifiedCount, aInheritedCount);
-  ExamineCSSValue(aValuePair->mYValue, aSpecifiedCount, aInheritedCount);
-}
-
-static void
 ExamineCSSRect(const nsCSSRect* aRect,
                PRUint32& aSpecifiedCount, PRUint32& aInheritedCount)
 {
   NS_PRECONDITION(aRect, "Must have a rect");
 
   NS_FOR_CSS_SIDES(side) {
     ExamineCSSValue(aRect->*(nsCSSRect::sides[side]),
                     aSpecifiedCount, aInheritedCount);
@@ -1674,30 +1688,16 @@ RectAtOffset(nsRuleDataStruct& aRuleData
 
 inline const nsCSSRect*
 RectAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
 {
   return reinterpret_cast<const nsCSSRect*>
                          (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
 }
 
-inline nsCSSValuePair*
-ValuePairAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
-{
-  return reinterpret_cast<nsCSSValuePair*>
-                         (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
-}
-
-inline const nsCSSValuePair*
-ValuePairAtOffset(const nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
-{
-  return reinterpret_cast<const nsCSSValuePair*>
-                         (reinterpret_cast<const char*>(&aRuleDataStruct) + aOffset);
-}
-
 inline nsCSSValueList*&
 ValueListAtOffset(nsRuleDataStruct& aRuleDataStruct, size_t aOffset)
 {
   return * reinterpret_cast<nsCSSValueList**>
                            (reinterpret_cast<char*>(&aRuleDataStruct) + aOffset);
 }
 
 inline const nsCSSValueList*
@@ -1756,22 +1756,16 @@ nsRuleNode::CheckSpecifiedProperties(con
         break;
 
       case eCSSType_Rect:
         total += 4;
         ExamineCSSRect(RectAtOffset(aRuleDataStruct, prop->offset),
                        specified, inherited);
         break;
 
-      case eCSSType_ValuePair:
-        total += 2;
-        ExamineCSSValuePair(ValuePairAtOffset(aRuleDataStruct, prop->offset),
-                            specified, inherited);
-        break;
-
       case eCSSType_ValueList:
         {
           ++total;
           const nsCSSValueList* valueList =
               ValueListAtOffset(aRuleDataStruct, prop->offset);
           if (valueList) {
             ++specified;
             if (eCSSUnit_Inherit == valueList->mValue.GetUnit()) {
@@ -2154,19 +2148,16 @@ UnsetPropertiesWithoutFlags(const nsStyl
 
     switch (prop->type) {
       case eCSSType_Value:
         ValueAtOffset(aRuleDataStruct, prop->offset).Reset();
         break;
       case eCSSType_Rect:
         RectAtOffset(aRuleDataStruct, prop->offset)->Reset();
         break;
-      case eCSSType_ValuePair:
-        ValuePairAtOffset(aRuleDataStruct, prop->offset)->Reset();
-        break;
       case eCSSType_ValueList:
         ValueListAtOffset(aRuleDataStruct, prop->offset) = nsnull;
         break;
       case eCSSType_ValuePairList:
         ValuePairListAtOffset(aRuleDataStruct, prop->offset) = nsnull;
         break;
       default:
         NS_NOTREACHED("unknown type");
@@ -4455,54 +4446,29 @@ nsRuleNode::ComputeDisplayData(void* aSt
     else {
       display->mSpecifiedTransform = head; // weak pointer, owned by rule
       display->mTransform = nsStyleTransformMatrix::ReadTransforms(head,
                               aContext, mPresContext, canStoreInRuleTree);
     }
   }
 
   /* Convert -moz-transform-origin. */
-  if (displayData.mTransformOrigin.mXValue.GetUnit() != eCSSUnit_Null ||
-      displayData.mTransformOrigin.mXValue.GetUnit() != eCSSUnit_Null) {
-
-    /* If X coordinate is an enumerated type, handle it explicitly. */
-    if (eCSSUnit_Enumerated == displayData.mTransformOrigin.mXValue.GetUnit())
-      display->mTransformOrigin[0].SetPercentValue
-        (GetFloatFromBoxPosition
-         (displayData.mTransformOrigin.mXValue.GetIntValue()));
-    else {
-      /* Convert lengths, percents, and inherit.  Default value is 50%. */
+  if (displayData.mTransformOrigin.GetUnit() != eCSSUnit_Null) {
 #ifdef DEBUG
-      PRBool result =
+    PRBool result =
 #endif
-        SetCoord(displayData.mTransformOrigin.mXValue,
-                 display->mTransformOrigin[0],
-                 parentDisplay->mTransformOrigin[0],
-                 SETCOORD_LPH | SETCOORD_INITIAL_HALF,
-                 aContext, mPresContext, canStoreInRuleTree);
-      NS_ASSERTION(result, "Malformed -moz-transform-origin parse!");
-    }
-
-    /* If Y coordinate is an enumerated type, handle it explicitly. */
-    if (eCSSUnit_Enumerated == displayData.mTransformOrigin.mYValue.GetUnit())
-      display->mTransformOrigin[1].SetPercentValue
-        (GetFloatFromBoxPosition
-         (displayData.mTransformOrigin.mYValue.GetIntValue()));
-    else {
-      /* Convert lengths, percents, initial, inherit. */
-#ifdef DEBUG
-      PRBool result =
-#endif
-        SetCoord(displayData.mTransformOrigin.mYValue,
-                 display->mTransformOrigin[1],
-                 parentDisplay->mTransformOrigin[1],
-                 SETCOORD_LPH | SETCOORD_INITIAL_HALF,
-                 aContext, mPresContext, canStoreInRuleTree);
-      NS_ASSERTION(result, "Malformed -moz-transform-origin parse!");
-    }
+      SetPairCoords(displayData.mTransformOrigin,
+                    display->mTransformOrigin[0],
+                    display->mTransformOrigin[1],
+                    parentDisplay->mTransformOrigin[0],
+                    parentDisplay->mTransformOrigin[1],
+                    SETCOORD_LPH | SETCOORD_INITIAL_HALF |
+                    SETCOORD_BOX_POSITION,
+                    aContext, mPresContext, canStoreInRuleTree);
+    NS_ASSERTION(result, "Malformed -moz-transform-origin parse!");
   }
 
   COMPUTE_END_RESET(Display, display)
 }
 
 const void*
 nsRuleNode::ComputeVisibilityData(void* aStartStruct,
                                   const nsRuleDataStruct& aData,
@@ -5199,22 +5165,30 @@ nsRuleNode::ComputeBorderData(void* aSta
         border->SetBorderToForeground(side);
       }
     }
   }
 
   // -moz-border-radius: length, percent, inherit
   {
     const nsCSSCornerSizes& borderRadius = marginData.mBorderRadius;
-    NS_FOR_CSS_HALF_CORNERS(corner) {
-      nsStyleCoord parentCoord = parentBorder->mBorderRadius.Get(corner);
-      if (SetCoord(borderRadius.GetHalfCorner(corner),
-                   coord, parentCoord, SETCOORD_LPH | SETCOORD_INITIAL_ZERO,
-                   aContext, mPresContext, canStoreInRuleTree))
-        border->mBorderRadius.Set(corner, coord);
+    NS_FOR_CSS_FULL_CORNERS(corner) {
+      int cx = NS_FULL_TO_HALF_CORNER(corner, false);
+      int cy = NS_FULL_TO_HALF_CORNER(corner, true);
+      const nsCSSValue& radius = borderRadius.GetCorner(corner);
+      nsStyleCoord parentX = parentBorder->mBorderRadius.Get(cx);
+      nsStyleCoord parentY = parentBorder->mBorderRadius.Get(cy);
+      nsStyleCoord coordX, coordY;
+
+      if (SetPairCoords(radius, coordX, coordY, parentX, parentY,
+                        SETCOORD_LPH | SETCOORD_INITIAL_ZERO,
+                        aContext, mPresContext, canStoreInRuleTree)) {
+        border->mBorderRadius.Set(cx, coordX);
+        border->mBorderRadius.Set(cy, coordY);
+      }
     }
   }
 
   // float-edge: enum, inherit, initial
   SetDiscrete(marginData.mFloatEdge, border->mFloatEdge, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentBorder->mFloatEdge,
               NS_STYLE_FLOAT_EDGE_CONTENT, 0, 0, 0, 0);
 
@@ -5398,22 +5372,30 @@ nsRuleNode::ComputeOutlineData(void* aSt
            eCSSUnit_Initial == marginData.mOutlineColor.GetUnit()) {
     outline->SetOutlineInitialColor();
   }
 
   // -moz-outline-radius: length, percent, inherit
   {
     nsStyleCoord coord;
     const nsCSSCornerSizes& outlineRadius = marginData.mOutlineRadius;
-    NS_FOR_CSS_HALF_CORNERS(corner) {
-      nsStyleCoord parentCoord = parentOutline->mOutlineRadius.Get(corner);
-      if (SetCoord(outlineRadius.GetHalfCorner(corner),
-                   coord, parentCoord, SETCOORD_LPH | SETCOORD_INITIAL_ZERO,
-                   aContext, mPresContext, canStoreInRuleTree))
-        outline->mOutlineRadius.Set(corner, coord);
+    NS_FOR_CSS_FULL_CORNERS(corner) {
+      int cx = NS_FULL_TO_HALF_CORNER(corner, false);
+      int cy = NS_FULL_TO_HALF_CORNER(corner, true);
+      const nsCSSValue& radius = outlineRadius.GetCorner(corner);
+      nsStyleCoord parentX = parentOutline->mOutlineRadius.Get(cx);
+      nsStyleCoord parentY = parentOutline->mOutlineRadius.Get(cy);
+      nsStyleCoord coordX, coordY;
+
+      if (SetPairCoords(radius, coordX, coordY, parentX, parentY,
+                        SETCOORD_LPH | SETCOORD_INITIAL_ZERO,
+                        aContext, mPresContext, canStoreInRuleTree)) {
+        outline->mOutlineRadius.Set(cx, coordX);
+        outline->mOutlineRadius.Set(cy, coordY);
+      }
     }
   }
 
   // outline-style: enum, inherit, initial
   // cannot use SetDiscrete because of SetOutlineStyle
   nsCSSUnit unit = marginData.mOutlineStyle.GetUnit();
   NS_ABORT_IF_FALSE(eCSSUnit_None != unit && eCSSUnit_Auto != unit,
                     "'none' and 'auto' should be handled as enumerated values");
@@ -5612,41 +5594,36 @@ nsRuleNode::ComputeTableBorderData(void*
                           Table, tableData)
 
   // border-collapse: enum, inherit, initial
   SetDiscrete(tableData.mBorderCollapse, table->mBorderCollapse,
               canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mBorderCollapse,
               NS_STYLE_BORDER_SEPARATE, 0, 0, 0, 0);
 
-  // border-spacing-x: length, inherit
-  nsStyleCoord tempCoord;
-  if (SetCoord(tableData.mBorderSpacing.mXValue, tempCoord,
-               nsStyleCoord(parentTable->mBorderSpacingX,
-                            nsStyleCoord::CoordConstructor),
-               SETCOORD_LH | SETCOORD_INITIAL_ZERO |
-               SETCOORD_CALC_LENGTH_ONLY | SETCOORD_CALC_CLAMP_NONNEGATIVE,
-               aContext, mPresContext, canStoreInRuleTree)) {
-    table->mBorderSpacingX = tempCoord.GetCoordValue();
-  } else {
-    NS_ASSERTION(tableData.mBorderSpacing.mXValue.GetUnit() == eCSSUnit_Null,
-                 "unexpected unit");
-  }
-
-  // border-spacing-y: length, inherit
-  if (SetCoord(tableData.mBorderSpacing.mYValue, tempCoord,
-               nsStyleCoord(parentTable->mBorderSpacingY,
-                            nsStyleCoord::CoordConstructor),
-               SETCOORD_LH | SETCOORD_INITIAL_ZERO |
-               SETCOORD_CALC_LENGTH_ONLY | SETCOORD_CALC_CLAMP_NONNEGATIVE,
-               aContext, mPresContext, canStoreInRuleTree)) {
-    table->mBorderSpacingY = tempCoord.GetCoordValue();
-  } else {
-    NS_ASSERTION(tableData.mBorderSpacing.mYValue.GetUnit() == eCSSUnit_Null,
-                 "unexpected unit");
+  if (tableData.mBorderSpacing.GetUnit() != eCSSUnit_Null) {
+    // border-spacing-x/y: length, inherit
+    nsStyleCoord parentX(parentTable->mBorderSpacingX,
+                         nsStyleCoord::CoordConstructor);
+    nsStyleCoord parentY(parentTable->mBorderSpacingY,
+                         nsStyleCoord::CoordConstructor);
+    nsStyleCoord coordX, coordY;
+
+#ifdef DEBUG
+    PRBool result =
+#endif
+      SetPairCoords(tableData.mBorderSpacing,
+                    coordX, coordY, parentX, parentY,
+                    SETCOORD_LH | SETCOORD_INITIAL_ZERO |
+                    SETCOORD_CALC_LENGTH_ONLY |
+                    SETCOORD_CALC_CLAMP_NONNEGATIVE,
+                    aContext, mPresContext, canStoreInRuleTree);
+    NS_ASSERTION(result, "malformed table border value");
+    table->mBorderSpacingX = coordX.GetCoordValue();
+    table->mBorderSpacingY = coordY.GetCoordValue();
   }
 
   // caption-side: enum, inherit, initial
   SetDiscrete(tableData.mCaptionSide, table->mCaptionSide, canStoreInRuleTree,
               SETDSC_ENUMERATED, parentTable->mCaptionSide,
               NS_STYLE_CAPTION_SIDE_TOP, 0, 0, 0, 0);
 
   // empty-cells: enum, inherit, initial
@@ -6049,47 +6026,56 @@ nsRuleNode::ComputeColumnData(void* aSta
                     column->mColumnRuleColor, canStoreInRuleTree)) {
     column->mColumnRuleColorIsForeground = PR_FALSE;
   }
 
   COMPUTE_END_RESET(Column, column)
 }
 
 static void
-SetSVGPaint(const nsCSSValuePair& aValue, const nsStyleSVGPaint& parentPaint,
+SetSVGPaint(const nsCSSValue& aValue, const nsStyleSVGPaint& parentPaint,
             nsPresContext* aPresContext, nsStyleContext *aContext,
             nsStyleSVGPaint& aResult, nsStyleSVGPaintType aInitialPaintType,
             PRBool& aCanStoreInRuleTree)
 {
   nscolor color;
 
-  if (aValue.mXValue.GetUnit() == eCSSUnit_Inherit) {
+  if (aValue.GetUnit() == eCSSUnit_Inherit) {
     aResult = parentPaint;
     aCanStoreInRuleTree = PR_FALSE;
-  } else if (aValue.mXValue.GetUnit() == eCSSUnit_None) {
+  } else if (aValue.GetUnit() == eCSSUnit_None) {
     aResult.SetType(eStyleSVGPaintType_None);
-  } else if (aValue.mXValue.GetUnit() == eCSSUnit_Initial) {
+  } else if (aValue.GetUnit() == eCSSUnit_Initial) {
     aResult.SetType(aInitialPaintType);
     aResult.mPaint.mColor = NS_RGB(0, 0, 0);
     aResult.mFallbackColor = NS_RGB(0, 0, 0);
-  } else if (aValue.mXValue.GetUnit() == eCSSUnit_URL) {
+  } else if (SetColor(aValue, NS_RGB(0, 0, 0), aPresContext, aContext,
+                      color, aCanStoreInRuleTree)) {
+    aResult.SetType(eStyleSVGPaintType_Color);
+    aResult.mPaint.mColor = color;
+  } else if (aValue.GetUnit() == eCSSUnit_Pair) {
+    const nsCSSValuePair& pair = aValue.GetPairValue();
+    NS_ABORT_IF_FALSE(pair.mXValue.GetUnit() == eCSSUnit_URL,
+                      "malformed paint server value");
+
     aResult.SetType(eStyleSVGPaintType_Server);
-    aResult.mPaint.mPaintServer = aValue.mXValue.GetURLValue();
+    aResult.mPaint.mPaintServer = pair.mXValue.GetURLValue();
     NS_IF_ADDREF(aResult.mPaint.mPaintServer);
-    if (aValue.mYValue.GetUnit() == eCSSUnit_None) {
+
+    if (pair.mYValue.GetUnit() == eCSSUnit_None) {
       aResult.mFallbackColor = NS_RGBA(0, 0, 0, 0);
     } else {
-      NS_ASSERTION(aValue.mYValue.GetUnit() != eCSSUnit_Inherit, "cannot inherit fallback colour");
-      SetColor(aValue.mYValue, NS_RGB(0, 0, 0), aPresContext, aContext,
+      NS_ABORT_IF_FALSE(pair.mYValue.GetUnit() != eCSSUnit_Inherit,
+                        "cannot inherit fallback colour");
+      SetColor(pair.mYValue, NS_RGB(0, 0, 0), aPresContext, aContext,
                aResult.mFallbackColor, aCanStoreInRuleTree);
     }
-  } else if (SetColor(aValue.mXValue, parentPaint.mPaint.mColor, aPresContext,
-                      aContext, color, aCanStoreInRuleTree)) {
-    aResult.SetType(eStyleSVGPaintType_Color);
-    aResult.mPaint.mColor = color;
+  } else {
+    NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Null,
+                      "malformed paint server value");
   }
 }
 
 const void*
 nsRuleNode::ComputeSVGData(void* aStartStruct,
                            const nsRuleDataStruct& aData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
diff --git a/layout/style/nsStyleAnimation.cpp b/layout/style/nsStyleAnimation.cpp
--- a/layout/style/nsStyleAnimation.cpp
+++ b/layout/style/nsStyleAnimation.cpp
@@ -1755,26 +1755,19 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
       static_cast<nsCSSValue*>(aSpecifiedValue)->SetNormalValue();
       break;
     case eUnit_Auto:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                         "type mismatch");
       static_cast<nsCSSValue*>(aSpecifiedValue)->SetAutoValue();
       break;
     case eUnit_None:
-      if (nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_PaintServer) {
-        NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                            eCSSType_ValuePair, "type mismatch");
-        static_cast<nsCSSValuePair*>(aSpecifiedValue)->
-          SetBothValuesTo(nsCSSValue(eCSSUnit_None));
-      } else {
-        NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
-                          "type mismatch");
-        static_cast<nsCSSValue*>(aSpecifiedValue)->SetNoneValue();
-      }
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                        "type mismatch");
+      static_cast<nsCSSValue*>(aSpecifiedValue)->SetNoneValue();
       break;
     case eUnit_Enumerated:
     case eUnit_Visibility:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                         "type mismatch");
       static_cast<nsCSSValue*>(aSpecifiedValue)->
         SetIntValue(aComputedValue.GetIntValue(), eCSSUnit_Enumerated);
       break;
@@ -1800,36 +1793,36 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
     case eUnit_Float:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
                         "type mismatch");
       static_cast<nsCSSValue*>(aSpecifiedValue)->
         SetFloatValue(aComputedValue.GetFloatValue(), eCSSUnit_Number);
       break;
     case eUnit_Color:
       // colors can be alone, or part of a paint server
-      if (nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_PaintServer) {
-        NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                            eCSSType_ValuePair, "type mismatch");
-        nsCSSValue val;
-        val.SetColorValue(aComputedValue.GetColorValue());
-        static_cast<nsCSSValuePair*>(aSpecifiedValue)->
-          SetBothValuesTo(val);
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                        "type mismatch");
+      static_cast<nsCSSValue*>(aSpecifiedValue)->
+        SetColorValue(aComputedValue.GetColorValue());
+      break;
+    case eUnit_CSSValuePair: {
+      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
+                        "type mismatch");
+      // Rule node processing expects pair values to be collapsed to a
+      // single value if both halves would be equal, for most but not
+      // all properties.  At present, all animatable properties that
+      // use pairs do expect collapsing.
+      const nsCSSValuePair* pair = aComputedValue.GetCSSValuePairValue();
+      if (pair->mXValue == pair->mYValue) {
+        *static_cast<nsCSSValue*>(aSpecifiedValue) = pair->mXValue;
       } else {
-        NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] == eCSSType_Value,
-                          "type mismatch");
         static_cast<nsCSSValue*>(aSpecifiedValue)->
-          SetColorValue(aComputedValue.GetColorValue());
+          SetPairValue(pair);
       }
-      break;
-    case eUnit_CSSValuePair:
-      NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
-                          eCSSType_ValuePair, "type mismatch");
-      *static_cast<nsCSSValuePair*>(aSpecifiedValue) =
-        *aComputedValue.GetCSSValuePairValue();
-      break;
+    } break;
     case eUnit_CSSRect:
       NS_ABORT_IF_FALSE(nsCSSProps::kTypeTable[aProperty] ==
                           eCSSType_Rect, "type mismatch");
       *static_cast<nsCSSRect*>(aSpecifiedValue) =
         *aComputedValue.GetCSSRectValue();
       break;
     case eUnit_Dasharray:
     case eUnit_Shadow:
@@ -1859,31 +1852,28 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
 {
   NS_ABORT_IF_FALSE(aPresContext, "null pres context");
   aSpecifiedValue.Truncate(); // Clear outparam, if it's not already empty
 
   if (aComputedValue.GetUnit() == eUnit_UnparsedString) {
     aComputedValue.GetStringValue(aSpecifiedValue);
     return PR_TRUE;
   }
-  nsCSSValuePair vp;
+  nsCSSValue val;
   nsCSSRect rect;
   nsCSSValueList* vl = nsnull;
   nsCSSValuePairList* vpl = nsnull;
   void *storage;
   switch (nsCSSProps::kTypeTable[aProperty]) {
     case eCSSType_Value:
-      storage = &vp.mXValue;
+      storage = &val;
       break;
     case eCSSType_Rect:
       storage = &rect;
       break;
-    case eCSSType_ValuePair:
-      storage = &vp;
-      break;
     case eCSSType_ValueList:
       storage = &vl;
       break;
     case eCSSType_ValuePairList:
       storage = &vpl;
       break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected case");
@@ -1893,24 +1883,21 @@ nsStyleAnimation::UncomputeValue(nsCSSPr
 
   if (!nsStyleAnimation::UncomputeValue(aProperty, aPresContext,
                                         aComputedValue, storage)) {
     return PR_FALSE;
   }
 
   switch (nsCSSProps::kTypeTable[aProperty]) {
     case eCSSType_Value:
-      vp.mXValue.AppendToString(aProperty, aSpecifiedValue);
+      val.AppendToString(aProperty, aSpecifiedValue);
       break;
     case eCSSType_Rect:
       rect.AppendToString(aProperty, aSpecifiedValue);
       break;
-    case eCSSType_ValuePair:
-      vp.AppendToString(aProperty, aSpecifiedValue);
-      break;
     case eCSSType_ValueList:
       vl->AppendToString(aProperty, aSpecifiedValue);
       break;
     case eCSSType_ValuePairList:
       vpl->AppendToString(aProperty, aSpecifiedValue);
       break;
     default:
       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected case");
diff --git a/layout/style/test/test_priority_preservation.html b/layout/style/test/test_priority_preservation.html
--- a/layout/style/test/test_priority_preservation.html
+++ b/layout/style/test/test_priority_preservation.html
@@ -110,12 +110,32 @@ is(s.getPropertyPriority("font-family"),
 is(s.getPropertyValue("text-decoration"), "line-through",
    "text-decoration still stored");
 is(s.getPropertyPriority("text-decoration"), "important",
    "text-decoration priority still stored");
 is(s.getPropertyValue("z-index"), "3",
    "z-index still stored");
 is(s.getPropertyPriority("z-index"), "",
    "z-index priority still stored");
+
+s.setProperty("-moz-border-radius", "2em", "");
+is(s.getPropertyValue("-moz-border-radius"), "2em 2em 2em 2em",
+   "-moz-border-radius serialization 1")
+
+s.setProperty("-moz-border-radius-topleft", "3em 4em", "");
+is(s.getPropertyValue("-moz-border-radius"),
+   "3em 2em 2em 2em / 4em 2em 2em 2em",
+   "-moz-border-radius serialization 2");
+
+s.setProperty("-moz-border-radius", "2em / 3em", "");
+is(s.getPropertyValue("-moz-border-radius"),
+   "2em 2em 2em 2em / 3em 3em 3em 3em",
+   "-moz-border-radius serialization 3")
+
+s.setProperty("-moz-border-radius-topleft", "4em", "");
+is(s.getPropertyValue("-moz-border-radius"),
+   "4em 2em 2em 2em / 4em 3em 3em 3em",
+   "-moz-border-radius serialization 3");
+
 </script>
 </pre>
 </body>
 </html>
