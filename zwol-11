From: Zack Weinberg <zweinberg@mozilla.com>

Bug 576044 (11/12): Make all assertions fatal in Declaration.h, Declaration.cpp, nsCSSDataBlock.h, nsCSSDataBlock.cpp, nsCSSValue.h, nsCSSValue.cpp, nsCSSProps.h, and nsCSSProps.cpp.  r=dbaron  a2.0=dbaron

diff --git a/layout/style/Declaration.cpp b/layout/style/Declaration.cpp
--- a/layout/style/Declaration.cpp
+++ b/layout/style/Declaration.cpp
@@ -87,17 +87,17 @@ Declaration::ValueAppended(nsCSSProperty
   mOrder.AppendElement(aProperty);
 }
 
 void
 Declaration::RemoveProperty(nsCSSProperty aProperty)
 {
   nsCSSExpandedDataBlock data;
   ExpandTo(&data);
-  NS_ASSERTION(!mData && !mImportantData, "Expand didn't null things out");
+  NS_ABORT_IF_FALSE(!mData && !mImportantData, "Expand didn't null things out");
 
   if (nsCSSProps::IsShorthand(aProperty)) {
     CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
       data.ClearLonghandProperty(*p);
       mOrder.RemoveElement(*p);
     }
   } else {
     data.ClearLonghandProperty(aProperty);
@@ -163,18 +163,18 @@ Declaration::GetValue(nsCSSProperty aPro
   CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(p, aProperty) {
     if (*p == eCSSProperty__x_system_font ||
          nsCSSProps::PropHasFlags(*p, CSS_PROPERTY_DIRECTIONAL_SOURCE)) {
       // The system-font subproperty and the *-source properties don't count.
       continue;
     }
     ++totalCount;
     const nsCSSValue *val = mData->ValueFor(*p);
-    NS_ASSERTION(!val || !mImportantData || !mImportantData->ValueFor(*p),
-                 "can't be in both blocks");
+    NS_ABORT_IF_FALSE(!val || !mImportantData || !mImportantData->ValueFor(*p),
+                      "can't be in both blocks");
     if (!val && mImportantData) {
       ++importantCount;
       val = mImportantData->ValueFor(*p);
     }
     if (!val) {
       // Case (1) above: some subproperties not specified.
       return;
     }
@@ -207,43 +207,43 @@ Declaration::GetValue(nsCSSProperty aPro
   switch (aProperty) {
     case eCSSProperty_margin: 
     case eCSSProperty_padding: 
     case eCSSProperty_border_color: 
     case eCSSProperty_border_style: 
     case eCSSProperty_border_width: {
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
-      NS_ASSERTION(nsCSSProps::GetStringValue(subprops[0]).Find("-top") !=
-                     kNotFound, "first subprop must be top");
-      NS_ASSERTION(nsCSSProps::GetStringValue(subprops[1]).Find("-right") !=
-                     kNotFound, "second subprop must be right");
-      NS_ASSERTION(nsCSSProps::GetStringValue(subprops[2]).Find("-bottom") !=
-                     kNotFound, "third subprop must be bottom");
-      NS_ASSERTION(nsCSSProps::GetStringValue(subprops[3]).Find("-left") !=
-                     kNotFound, "fourth subprop must be left");
+      NS_ABORT_IF_FALSE(nsCSSProps::GetStringValue(subprops[0]).Find("-top") !=
+                        kNotFound, "first subprop must be top");
+      NS_ABORT_IF_FALSE(nsCSSProps::GetStringValue(subprops[1]).Find("-right") !=
+                        kNotFound, "second subprop must be right");
+      NS_ABORT_IF_FALSE(nsCSSProps::GetStringValue(subprops[2]).Find("-bottom") !=
+                        kNotFound, "third subprop must be bottom");
+      NS_ABORT_IF_FALSE(nsCSSProps::GetStringValue(subprops[3]).Find("-left") !=
+                        kNotFound, "fourth subprop must be left");
       const nsCSSValue &topValue = *data->ValueFor(subprops[0]);
       const nsCSSValue &rightValue = *data->ValueFor(subprops[1]);
       const nsCSSValue &bottomValue = *data->ValueFor(subprops[2]);
       const nsCSSValue &leftValue = *data->ValueFor(subprops[3]);
 
-      NS_ASSERTION(topValue.GetUnit() != eCSSUnit_Null, "null top");
+      NS_ABORT_IF_FALSE(topValue.GetUnit() != eCSSUnit_Null, "null top");
       topValue.AppendToString(subprops[0], aValue);
       if (topValue != rightValue || topValue != leftValue ||
           topValue != bottomValue) {
         aValue.Append(PRUnichar(' '));
-        NS_ASSERTION(rightValue.GetUnit() != eCSSUnit_Null, "null right");
+        NS_ABORT_IF_FALSE(rightValue.GetUnit() != eCSSUnit_Null, "null right");
         rightValue.AppendToString(subprops[1], aValue);
         if (topValue != bottomValue || rightValue != leftValue) {
           aValue.Append(PRUnichar(' '));
-          NS_ASSERTION(bottomValue.GetUnit() != eCSSUnit_Null, "null bottom");
+          NS_ABORT_IF_FALSE(bottomValue.GetUnit() != eCSSUnit_Null, "null bottom");
           bottomValue.AppendToString(subprops[2], aValue);
           if (rightValue != leftValue) {
             aValue.Append(PRUnichar(' '));
-            NS_ASSERTION(leftValue.GetUnit() != eCSSUnit_Null, "null left");
+            NS_ABORT_IF_FALSE(leftValue.GetUnit() != eCSSUnit_Null, "null left");
             leftValue.AppendToString(subprops[3], aValue);
           }
         }
       }
       break;
     }
     case eCSSProperty__moz_border_radius:
     case eCSSProperty__moz_outline_radius: {
@@ -316,21 +316,21 @@ Declaration::GetValue(nsCSSProperty aPro
     case eCSSProperty_border_bottom:
     case eCSSProperty_border_left:
     case eCSSProperty_border_start:
     case eCSSProperty_border_end:
     case eCSSProperty__moz_column_rule:
     case eCSSProperty_outline: {
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
-      NS_ASSERTION(StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
-                                  NS_LITERAL_CSTRING("-color")) ||
-                   StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
-                                  NS_LITERAL_CSTRING("-color-value")),
-                   "third subprop must be the color property");
+      NS_ABORT_IF_FALSE(StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
+                                       NS_LITERAL_CSTRING("-color")) ||
+                        StringEndsWith(nsCSSProps::GetStringValue(subprops[2]),
+                                       NS_LITERAL_CSTRING("-color-value")),
+                        "third subprop must be the color property");
       const nsCSSValue *colorValue = data->ValueFor(subprops[2]);
       PRBool isMozUseTextColor =
         colorValue->GetUnit() == eCSSUnit_Enumerated &&
         colorValue->GetIntValue() == NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR;
       if (!AppendValueToString(subprops[0], aValue) ||
           !(aValue.Append(PRUnichar(' ')),
             AppendValueToString(subprops[1], aValue)) ||
           // Don't output a third value when it's -moz-use-text-color.
@@ -358,18 +358,18 @@ Declaration::GetValue(nsCSSProperty aPro
     case eCSSProperty_border_start_color:
     case eCSSProperty_border_start_style:
     case eCSSProperty_border_start_width:
     case eCSSProperty_border_end_color:
     case eCSSProperty_border_end_style:
     case eCSSProperty_border_end_width: {
       const nsCSSProperty* subprops =
         nsCSSProps::SubpropertyEntryFor(aProperty);
-      NS_ASSERTION(subprops[3] == eCSSProperty_UNKNOWN,
-                   "not box property with physical vs. logical cascading");
+      NS_ABORT_IF_FALSE(subprops[3] == eCSSProperty_UNKNOWN,
+                        "not box property with physical vs. logical cascading");
       AppendValueToString(subprops[0], aValue);
       break;
     }
     case eCSSProperty_background: {
       // We know from above that all subproperties were specified.
       // However, we still can't represent that in the shorthand unless
       // they're all lists of the same length.  So if they're different
       // lengths, we need to bail out.
@@ -411,20 +411,20 @@ Declaration::GetValue(nsCSSProperty aPro
         attachment->mValue.AppendToString(eCSSProperty_background_attachment,
                                           aValue);
         aValue.Append(PRUnichar(' '));
         position->mXValue.AppendToString(eCSSProperty_background_position,
                                          aValue);
         aValue.Append(PRUnichar(' '));
         position->mYValue.AppendToString(eCSSProperty_background_position,
                                          aValue);
-        NS_ASSERTION(clip->mValue.GetUnit() == eCSSUnit_Enumerated &&
-                     origin->mValue.GetUnit() == eCSSUnit_Enumerated,
-                     "should not be inherit/initial within list and "
-                     "should have returned early for real inherit/initial");
+        NS_ABORT_IF_FALSE(clip->mValue.GetUnit() == eCSSUnit_Enumerated &&
+                          origin->mValue.GetUnit() == eCSSUnit_Enumerated,
+                          "should not be inherit/initial within list and "
+                          "should have returned early for real inherit/initial");
         if (clip->mValue.GetIntValue() != NS_STYLE_BG_CLIP_BORDER ||
             origin->mValue.GetIntValue() != NS_STYLE_BG_ORIGIN_PADDING) {
           PR_STATIC_ASSERT(NS_STYLE_BG_CLIP_BORDER ==
                            NS_STYLE_BG_ORIGIN_BORDER);
           PR_STATIC_ASSERT(NS_STYLE_BG_CLIP_PADDING ==
                            NS_STYLE_BG_ORIGIN_PADDING);
           PR_STATIC_ASSERT(NS_STYLE_BG_CLIP_CONTENT ==
                            NS_STYLE_BG_ORIGIN_CONTENT);
@@ -669,17 +669,17 @@ Declaration::GetValue(nsCSSProperty aPro
         *data->ValueFor(eCSSProperty_marker_mid);
       const nsCSSValue &startValue =
         *data->ValueFor(eCSSProperty_marker_start);
       if (endValue == midValue && midValue == startValue)
         AppendValueToString(eCSSProperty_marker_end, aValue);
       break;
     }
     default:
-      NS_NOTREACHED("no other shorthands");
+      NS_ABORT_IF_FALSE(false, "no other shorthands");
       break;
   }
 }
 
 PRBool
 Declaration::GetValueIsImportant(const nsAString& aProperty) const
 {
   nsCSSProperty propID = nsCSSProps::LookupProperty(aProperty);
@@ -710,21 +710,21 @@ Declaration::GetValueIsImportant(nsCSSPr
   return PR_TRUE;
 }
 
 void
 Declaration::AppendPropertyAndValueToString(nsCSSProperty aProperty,
                                             nsAutoString& aValue,
                                             nsAString& aResult) const
 {
-  NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT,
-               "property enum out of range");
-  NS_ASSERTION((aProperty < eCSSProperty_COUNT_no_shorthands) ==
-                 aValue.IsEmpty(),
-               "aValue should be given for shorthands but not longhands");
+  NS_ABORT_IF_FALSE(0 <= aProperty && aProperty < eCSSProperty_COUNT,
+                    "property enum out of range");
+  NS_ABORT_IF_FALSE((aProperty < eCSSProperty_COUNT_no_shorthands) ==
+                    aValue.IsEmpty(),
+                    "aValue should be given for shorthands but not longhands");
   AppendASCIItoUTF16(nsCSSProps::GetStringValue(aProperty), aResult);
   aResult.AppendLiteral(": ");
   if (aValue.IsEmpty())
     AppendValueToString(aProperty, aResult);
   else
     aResult.Append(aValue);
   if (GetValueIsImportant(aProperty)) {
     aResult.AppendLiteral(" ! important");
@@ -784,19 +784,19 @@ Declaration::ToString(nsAString& aString
       GetValue(shorthand, value);
       if (!value.IsEmpty()) {
         AppendPropertyAndValueToString(shorthand, value, aString);
         shorthandsUsed.AppendElement(shorthand);
         doneProperty = PR_TRUE;
         break;
       }
 
-      NS_ASSERTION(shorthand != eCSSProperty_font ||
-                   *(shorthands + 1) == eCSSProperty_UNKNOWN,
-                   "font should always be the only containing shorthand");
+      NS_ABORT_IF_FALSE(shorthand != eCSSProperty_font ||
+                        *(shorthands + 1) == eCSSProperty_UNKNOWN,
+                        "font should always be the only containing shorthand");
       if (shorthand == eCSSProperty_font) {
         if (haveSystemFont && !didSystemFont) {
           // Output the shorthand font declaration that we will
           // partially override later.  But don't add it to
           // |shorthandsUsed|, since we will have to override it.
           systemFont->AppendToString(eCSSProperty__x_system_font, value);
           AppendPropertyAndValueToString(eCSSProperty_font, value, aString);
           value.Truncate();
@@ -814,17 +814,17 @@ Declaration::ToString(nsAString& aString
             (haveSystemFont && val && val->GetUnit() == eCSSUnit_System_Font)) {
           doneProperty = PR_TRUE;
         }
       }
     }
     if (doneProperty)
       continue;
 
-    NS_ASSERTION(value.IsEmpty(), "value should be empty now");
+    NS_ABORT_IF_FALSE(value.IsEmpty(), "value should be empty now");
     AppendPropertyAndValueToString(property, value, aString);
   }
   if (! aString.IsEmpty()) {
     // if the string is not empty, we have trailing whitespace we
     // should remove
     aString.Truncate(aString.Length() - 1);
   }
 }
@@ -853,24 +853,24 @@ Declaration::GetNthProperty(PRUint32 aIn
       AppendASCIItoUTF16(nsCSSProps::GetStringValue(property), aReturn);
     }
   }
 }
 
 void
 Declaration::InitializeEmpty()
 {
-  NS_ASSERTION(!mData && !mImportantData, "already initialized");
+  NS_ABORT_IF_FALSE(!mData && !mImportantData, "already initialized");
   mData = nsCSSCompressedDataBlock::CreateEmptyBlock();
 }
 
 Declaration*
 Declaration::EnsureMutable()
 {
-  NS_ASSERTION(mData, "should only be called when not expanded");
+  NS_ABORT_IF_FALSE(mData, "should only be called when not expanded");
   if (!IsMutable()) {
     return new Declaration(*this);
   } else {
     return this;
   }
 }
 
 } // namespace mozilla::css
diff --git a/layout/style/Declaration.h b/layout/style/Declaration.h
--- a/layout/style/Declaration.h
+++ b/layout/style/Declaration.h
@@ -111,35 +111,35 @@ public:
    */
   void InitializeEmpty();
 
   /**
    * Transfer all of the state from |aExpandedData| into this declaration.
    * After calling, |aExpandedData| should be in its initial state.
    */
   void CompressFrom(nsCSSExpandedDataBlock *aExpandedData) {
-    NS_ASSERTION(!mData, "oops");
-    NS_ASSERTION(!mImportantData, "oops");
+    NS_ABORT_IF_FALSE(!mData, "oops");
+    NS_ABORT_IF_FALSE(!mImportantData, "oops");
     aExpandedData->Compress(getter_Transfers(mData),
                             getter_Transfers(mImportantData));
     aExpandedData->AssertInitialState();
   }
 
   /**
    * Transfer all of the state from this declaration into
    * |aExpandedData| and put this declaration temporarily into an
    * invalid state (ended by |CompressFrom| or |InitializeEmpty|) that
    * should last only during parsing.  During this time only
    * |ValueAppended| should be called.
    */
   void ExpandTo(nsCSSExpandedDataBlock *aExpandedData) {
     AssertMutable();
     aExpandedData->AssertInitialState();
 
-    NS_ASSERTION(mData, "oops");
+    NS_ABORT_IF_FALSE(mData, "oops");
     aExpandedData->Expand(mData.forget(), mImportantData.forget());
   }
 
   /**
    * Do what |nsIStyleRule::MapRuleInfoInto| needs to do for a style
    * rule using this declaration for storage.
    */
   void MapNormalRuleInfoInto(nsRuleData *aRuleData) const {
diff --git a/layout/style/nsCSSDataBlock.cpp b/layout/style/nsCSSDataBlock.cpp
--- a/layout/style/nsCSSDataBlock.cpp
+++ b/layout/style/nsCSSDataBlock.cpp
@@ -174,24 +174,23 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
         return;
 
     nsIDocument* doc = aRuleData->mPresContext->Document();
 
     const char* cursor = Block();
     const char* cursor_end = BlockEnd();
     while (cursor < cursor_end) {
         nsCSSProperty iProp = PropertyAtCursor(cursor);
-        NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
-                     "out of range");
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(iProp), "out of range");
         if (nsCachedStyleData::GetBitForSID(nsCSSProps::kSIDTable[iProp]) &
             aRuleData->mSIDs) {
             nsCSSValue* target = aRuleData->ValueFor(iProp);
             if (target->GetUnit() == eCSSUnit_Null) {
                 const nsCSSValue *val = ValueAtCursor(cursor);
-                NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
+                NS_ABORT_IF_FALSE(val->GetUnit() != eCSSUnit_Null, "oops");
                 if (ShouldStartImageLoads(aRuleData, iProp)) {
                     TryToStartImageLoad(*val, doc, iProp);
                 }
                 *target = *val;
                 if (iProp == eCSSProperty_font_family) {
                     // XXX Are there other things like this?
                     aRuleData->mFontData->mFamilyFromHTML = PR_FALSE;
                 }
@@ -210,45 +209,44 @@ nsCSSCompressedDataBlock::MapRuleInfoInt
                         // Ignore 'color', 'border-*-color', etc.
                         *target = nsCSSValue();
                     }
                 }
             }
         }
         cursor += CDBValueStorage_advance;
     }
-    NS_ASSERTION(cursor == cursor_end, "inconsistent data");
+    NS_ABORT_IF_FALSE(cursor == cursor_end, "inconsistent data");
 }
 
 const nsCSSValue*
 nsCSSCompressedDataBlock::ValueFor(nsCSSProperty aProperty) const
 {
-    NS_PRECONDITION(!nsCSSProps::IsShorthand(aProperty),
-                    "Don't call for shorthands");
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
+                      "Don't call for shorthands");
 
     // If we have no data for this struct, then return immediately.
     // This optimization should make us return most of the time, so we
     // have to worry much less (although still some) about the speed of
     // the rest of the function.
     if (!(nsCachedStyleData::GetBitForSID(nsCSSProps::kSIDTable[aProperty]) &
           mStyleBits))
         return nsnull;
 
     const char* cursor = Block();
     const char* cursor_end = BlockEnd();
     while (cursor < cursor_end) {
         nsCSSProperty iProp = PropertyAtCursor(cursor);
-        NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
-                     "out of range");
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(iProp), "out of range");
         if (iProp == aProperty) {
             return ValueAtCursor(cursor);
         }
         cursor += CDBValueStorage_advance;
     }
-    NS_ASSERTION(cursor == cursor_end, "inconsistent data");
+    NS_ABORT_IF_FALSE(cursor == cursor_end, "inconsistent data");
 
     return nsnull;
 }
 
 PRBool
 nsCSSCompressedDataBlock::TryReplaceValue(nsCSSProperty aProperty,
                                           nsCSSExpandedDataBlock& aFromBlock,
                                           PRBool *aChanged)
@@ -277,50 +275,48 @@ nsCSSCompressedDataBlock::Clone() const
     nsAutoPtr<nsCSSCompressedDataBlock> result
         (new(cursor_end - cursor) nsCSSCompressedDataBlock());
     if (!result)
         return nsnull;
     result_cursor = result->Block();
 
     while (cursor < cursor_end) {
         nsCSSProperty iProp = PropertyAtCursor(cursor);
-        NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
-                     "out of range");
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(iProp), "out of range");
         PropertyAtCursor(result_cursor) = iProp;
 
         const nsCSSValue* val = ValueAtCursor(cursor);
         nsCSSValue *result_val = ValueAtCursor(result_cursor);
         new (result_val) nsCSSValue(*val);
         cursor += CDBValueStorage_advance;
         result_cursor +=  CDBValueStorage_advance;
     }
-    NS_ASSERTION(cursor == cursor_end, "inconsistent data");
+    NS_ABORT_IF_FALSE(cursor == cursor_end, "inconsistent data");
 
     result->mBlockEnd = result_cursor;
     result->mStyleBits = mStyleBits;
-    NS_ASSERTION(result->DataSize() == DataSize(), "wrong size");
+    NS_ABORT_IF_FALSE(result->DataSize() == DataSize(), "wrong size");
 
     return result.forget();
 }
 
 nsCSSCompressedDataBlock::~nsCSSCompressedDataBlock()
 {
     const char* cursor = Block();
     const char* cursor_end = BlockEnd();
     while (cursor < cursor_end) {
         nsCSSProperty iProp = PropertyAtCursor(cursor);
-        NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
-                     "out of range");
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(iProp), "out of range");
 
         const nsCSSValue* val = ValueAtCursor(cursor);
-        NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
+        NS_ABORT_IF_FALSE(val->GetUnit() != eCSSUnit_Null, "oops");
         val->~nsCSSValue();
         cursor += CDBValueStorage_advance;
     }
-    NS_ASSERTION(cursor == cursor_end, "inconsistent data");
+    NS_ABORT_IF_FALSE(cursor == cursor_end, "inconsistent data");
 }
 
 /* static */ nsCSSCompressedDataBlock*
 nsCSSCompressedDataBlock::CreateEmptyBlock()
 {
     nsCSSCompressedDataBlock *result = new(0) nsCSSCompressedDataBlock();
     result->mBlockEnd = result->Block();
     return result;
@@ -354,47 +350,46 @@ nsCSSExpandedDataBlock::DoExpand(nsCSSCo
     /*
      * Save needless copying and allocation by copying the memory
      * corresponding to the stored data in the compressed block.
      */
     const char* cursor = aBlock->Block();
     const char* cursor_end = aBlock->BlockEnd();
     while (cursor < cursor_end) {
         nsCSSProperty iProp = PropertyAtCursor(cursor);
-        NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
-                     "out of range");
-        NS_ASSERTION(!HasPropertyBit(iProp),
-                     "compressed block has property multiple times");
+        NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(iProp), "out of range");
+        NS_ABORT_IF_FALSE(!HasPropertyBit(iProp),
+                          "compressed block has property multiple times");
         SetPropertyBit(iProp);
         if (aImportant)
             SetImportantBit(iProp);
 
         const nsCSSValue* val = ValueAtCursor(cursor);
         nsCSSValue* dest = PropertyAt(iProp);
-        NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
-        NS_ASSERTION(dest->GetUnit() == eCSSUnit_Null,
-                     "expanding into non-empty block");
+        NS_ABORT_IF_FALSE(val->GetUnit() != eCSSUnit_Null, "oops");
+        NS_ABORT_IF_FALSE(dest->GetUnit() == eCSSUnit_Null,
+                          "expanding into non-empty block");
 #ifdef NS_BUILD_REFCNT_LOGGING
         dest->~nsCSSValue();
 #endif
         memcpy(dest, val, sizeof(nsCSSValue));
         cursor += CDBValueStorage_advance;
     }
-    NS_ASSERTION(cursor == cursor_end, "inconsistent data");
+    NS_ABORT_IF_FALSE(cursor == cursor_end, "inconsistent data");
 
     // Don't destroy remnants of what we just copied
     aBlock->mBlockEnd = aBlock->Block();
     delete aBlock;
 }
 
 void
 nsCSSExpandedDataBlock::Expand(nsCSSCompressedDataBlock *aNormalBlock,
                                nsCSSCompressedDataBlock *aImportantBlock)
 {
-    NS_PRECONDITION(aNormalBlock, "unexpected null block");
+    NS_ABORT_IF_FALSE(aNormalBlock, "unexpected null block");
     AssertInitialState();
 
     DoExpand(aNormalBlock, PR_FALSE);
     if (aImportantBlock) {
         DoExpand(aImportantBlock, PR_TRUE);
     }
 }
 
@@ -404,20 +399,19 @@ nsCSSExpandedDataBlock::ComputeSize()
     ComputeSizeResult result = {0, 0};
     for (size_t iHigh = 0; iHigh < nsCSSPropertySet::kChunkCount; ++iHigh) {
         if (!mPropertiesSet.HasPropertyInChunk(iHigh))
             continue;
         for (size_t iLow = 0; iLow < nsCSSPropertySet::kBitsInChunk; ++iLow) {
             if (!mPropertiesSet.HasPropertyAt(iHigh, iLow))
                 continue;
             nsCSSProperty iProp = nsCSSPropertySet::CSSPropertyAt(iHigh, iLow);
-            NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
-                         "out of range");
-            NS_ASSERTION(PropertyAt(iProp)->GetUnit() != eCSSUnit_Null,
-                         "null value while computing size");
+            NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(iProp), "out of range");
+            NS_ABORT_IF_FALSE(PropertyAt(iProp)->GetUnit() != eCSSUnit_Null,
+                              "null value while computing size");
             if (mPropertiesImportant.HasPropertyAt(iHigh, iLow))
                 result.important += CDBValueStorage_advance;
             else
                 result.normal += CDBValueStorage_advance;
         }
     }
     return result;
 }
@@ -449,58 +443,59 @@ nsCSSExpandedDataBlock::Compress(nsCSSCo
      */
     for (size_t iHigh = 0; iHigh < nsCSSPropertySet::kChunkCount; ++iHigh) {
         if (!mPropertiesSet.HasPropertyInChunk(iHigh))
             continue;
         for (size_t iLow = 0; iLow < nsCSSPropertySet::kBitsInChunk; ++iLow) {
             if (!mPropertiesSet.HasPropertyAt(iHigh, iLow))
                 continue;
             nsCSSProperty iProp = nsCSSPropertySet::CSSPropertyAt(iHigh, iLow);
-            NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
-                         "out of range");
+            NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(iProp), "out of range");
             PRBool important =
                 mPropertiesImportant.HasPropertyAt(iHigh, iLow);
             char *&cursor = important ? cursor_important : cursor_normal;
             nsCSSCompressedDataBlock *result =
                 important ? result_important : result_normal;
             nsCSSValue* val = PropertyAt(iProp);
-            NS_ASSERTION(val->GetUnit() != eCSSUnit_Null,
-                         "Null value while compressing");
+            NS_ABORT_IF_FALSE(val->GetUnit() != eCSSUnit_Null,
+                              "Null value while compressing");
             CDBValueStorage *storage =
                 reinterpret_cast<CDBValueStorage*>(cursor);
             storage->property = iProp;
             memcpy(&storage->value, val, sizeof(nsCSSValue));
             new (val) nsCSSValue();
             cursor += CDBValueStorage_advance;
             result->mStyleBits |=
                 nsCachedStyleData::GetBitForSID(nsCSSProps::kSIDTable[iProp]);
         }
     }
 
     result_normal->mBlockEnd = cursor_normal;
-    NS_ASSERTION(result_normal->DataSize() == ptrdiff_t(size.normal),
-                 "size miscalculation");
+    NS_ABORT_IF_FALSE(result_normal->DataSize() == ptrdiff_t(size.normal),
+                      "size miscalculation");
 
     if (result_important) {
         result_important->mBlockEnd = cursor_important;
-        NS_ASSERTION(result_important->DataSize() == ptrdiff_t(size.important),
-                     "size miscalculation");
+        NS_ABORT_IF_FALSE(result_important->DataSize() ==
+                          ptrdiff_t(size.important),
+                          "size miscalculation");
     }
 
     ClearSets();
     AssertInitialState();
     *aNormalBlock = result_normal.forget();
     *aImportantBlock = result_important.forget();
 }
 
 void
 nsCSSExpandedDataBlock::AddLonghandProperty(nsCSSProperty aProperty,
                                             const nsCSSValue& aValue)
 {
-    NS_ASSERTION(!nsCSSProps::IsShorthand(aProperty), "property out of range");
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
+                      "property out of range");
     nsCSSValue& storage = *static_cast<nsCSSValue*>(PropertyAt(aProperty));
     storage = aValue;
     SetPropertyBit(aProperty);
 }
 
 void
 nsCSSExpandedDataBlock::Clear()
 {
@@ -528,19 +523,17 @@ nsCSSExpandedDataBlock::ClearProperty(ns
   } else {
     ClearLonghandProperty(aPropID);
   }
 }
 
 void
 nsCSSExpandedDataBlock::ClearLonghandProperty(nsCSSProperty aPropID)
 {
-    NS_ABORT_IF_FALSE(0 <= aPropID &&
-                      aPropID < eCSSProperty_COUNT_no_shorthands,
-                      "out of range");
+    NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aPropID), "out of range");
 
     ClearPropertyBit(aPropID);
     ClearImportantBit(aPropID);
     PropertyAt(aPropID)->Reset();
 }
 
 PRBool
 nsCSSExpandedDataBlock::TransferFromBlock(nsCSSExpandedDataBlock& aFromBlock,
@@ -569,17 +562,17 @@ PRBool
 nsCSSExpandedDataBlock::DoTransferFromBlock(nsCSSExpandedDataBlock& aFromBlock,
                                             nsCSSProperty aPropID,
                                             PRBool aIsImportant,
                                             PRBool aOverrideImportant,
                                             PRBool aMustCallValueAppended,
                                             css::Declaration* aDeclaration)
 {
   PRBool changed = PR_FALSE;
-  NS_ASSERTION(aFromBlock.HasPropertyBit(aPropID), "oops");
+  NS_ABORT_IF_FALSE(aFromBlock.HasPropertyBit(aPropID), "oops");
   if (aIsImportant) {
     if (!HasImportantBit(aPropID))
       changed = PR_TRUE;
     SetImportantBit(aPropID);
   } else {
     if (HasImportantBit(aPropID)) {
       // When parsing a declaration block, an !important declaration
       // is not overwritten by an ordinary declaration of the same
@@ -614,13 +607,13 @@ nsCSSExpandedDataBlock::DoTransferFromBl
 #ifdef DEBUG
 void
 nsCSSExpandedDataBlock::DoAssertInitialState()
 {
     mPropertiesSet.AssertIsEmpty("not initial state");
     mPropertiesImportant.AssertIsEmpty("not initial state");
 
     for (PRUint32 i = 0; i < eCSSProperty_COUNT_no_shorthands; ++i) {
-        NS_ASSERTION(PropertyAt(nsCSSProperty(i))->GetUnit() == eCSSUnit_Null,
-                     "not initial state");
+        NS_ABORT_IF_FALSE(PropertyAt(nsCSSProperty(i))->GetUnit() ==
+                          eCSSUnit_Null, "not initial state");
     }
 }
 #endif
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -107,47 +107,49 @@ SortPropertyAndCount(const void* s1, con
   // Secondary sort by property index (highest to lowest)
   return pc2->property - pc1->property;
 }
 
 void
 nsCSSProps::AddRefTable(void)
 {
   if (0 == gTableRefCount++) {
-    NS_ASSERTION(!gPropertyTable, "pre existing array!");
-    NS_ASSERTION(!gFontDescTable, "pre existing array!");
+    NS_ABORT_IF_FALSE(!gPropertyTable, "pre existing array!");
+    NS_ABORT_IF_FALSE(!gFontDescTable, "pre existing array!");
 
     gPropertyTable = new nsStaticCaseInsensitiveNameTable();
     if (gPropertyTable) {
 #ifdef DEBUG
     {
       // let's verify the table...
       for (PRInt32 index = 0; index < eCSSProperty_COUNT; ++index) {
         nsCAutoString temp1(kCSSRawProperties[index]);
         nsCAutoString temp2(kCSSRawProperties[index]);
         ToLowerCase(temp1);
-        NS_ASSERTION(temp1.Equals(temp2), "upper case char in prop table");
-        NS_ASSERTION(-1 == temp1.FindChar('_'), "underscore char in prop table");
+        NS_ABORT_IF_FALSE(temp1.Equals(temp2), "upper case char in prop table");
+        NS_ABORT_IF_FALSE(-1 == temp1.FindChar('_'),
+                          "underscore char in prop table");
       }
     }
 #endif
       gPropertyTable->Init(kCSSRawProperties, eCSSProperty_COUNT);
     }
 
     gFontDescTable = new nsStaticCaseInsensitiveNameTable();
     if (gFontDescTable) {
 #ifdef DEBUG
     {
       // let's verify the table...
       for (PRInt32 index = 0; index < eCSSFontDesc_COUNT; ++index) {
         nsCAutoString temp1(kCSSRawFontDescs[index]);
         nsCAutoString temp2(kCSSRawFontDescs[index]);
         ToLowerCase(temp1);
-        NS_ASSERTION(temp1.Equals(temp2), "upper case char in desc table");
-        NS_ASSERTION(-1 == temp1.FindChar('_'), "underscore char in desc table");
+        NS_ABORT_IF_FALSE(temp1.Equals(temp2), "upper case char in desc table");
+        NS_ABORT_IF_FALSE(-1 == temp1.FindChar('_'),
+                          "underscore char in desc table");
       }
     }
 #endif
       gFontDescTable->Init(kCSSRawFontDescs, eCSSFontDesc_COUNT);
     }
 
     BuildShorthandsContainingTable();
   }
@@ -171,19 +173,19 @@ nsCSSProps::BuildShorthandsContainingTab
 #endif
     PropertyAndCount &subpropCountsEntry =
       subpropCounts[shorthand - eCSSProperty_COUNT_no_shorthands];
     subpropCountsEntry.property = shorthand;
     subpropCountsEntry.count = 0;
     for (const nsCSSProperty* subprops = SubpropertyEntryFor(shorthand);
          *subprops != eCSSProperty_UNKNOWN;
          ++subprops) {
-      NS_ASSERTION(0 < *subprops &&
-                   *subprops < eCSSProperty_COUNT_no_shorthands,
-                   "subproperty must be a longhand");
+      NS_ABORT_IF_FALSE(0 < *subprops &&
+                        *subprops < eCSSProperty_COUNT_no_shorthands,
+                        "subproperty must be a longhand");
       ++occurrenceCounts[*subprops];
       ++subpropCountsEntry.count;
     }
   }
 
   PRUint32 poolEntries = 0;
   for (nsCSSProperty longhand = nsCSSProperty(0);
        longhand < eCSSProperty_COUNT_no_shorthands;
@@ -210,17 +212,17 @@ nsCSSProps::BuildShorthandsContainingTab
       if (count > 0) {
         poolCursor += count + 1;
         gShorthandsContainingTable[longhand] = poolCursor;
         *poolCursor = eCSSProperty_UNKNOWN;
       } else {
         gShorthandsContainingTable[longhand] = lastTerminator;
       }
     }
-    NS_ASSERTION(poolCursor == lastTerminator, "miscalculation");
+    NS_ABORT_IF_FALSE(poolCursor == lastTerminator, "miscalculation");
   }
 
   // Sort with lowest count at the start and highest at the end, and
   // within counts sort in reverse property index order.
   NS_QuickSort(&subpropCounts, NS_ARRAY_LENGTH(subpropCounts),
                sizeof(subpropCounts[0]), SortPropertyAndCount, nsnull);
 
   // Fill in all the entries in gShorthandsContainingTable
@@ -267,18 +269,19 @@ nsCSSProps::BuildShorthandsContainingTab
          ++subprops) {
       PRUint32 count = 0;
       for (const nsCSSProperty *shcont = ShorthandsContaining(*subprops);
            *shcont != eCSSProperty_UNKNOWN;
            ++shcont) {
         if (*shcont == shorthand)
           ++count;
       }
-      NS_ASSERTION(count == 1, "subproperty of shorthand should have shorthand"
-                               " in its ShorthandsContaining() table");
+      NS_ABORT_IF_FALSE(count == 1,
+                        "subproperty of shorthand should have shorthand"
+                        " in its ShorthandsContaining() table");
     }
   }
 
   // Verify that there are no extra values
   for (nsCSSProperty longhand = nsCSSProperty(0);
        longhand < eCSSProperty_COUNT_no_shorthands;
        longhand = nsCSSProperty(longhand + 1)) {
     for (const nsCSSProperty *shorthands = ShorthandsContaining(longhand);
@@ -286,18 +289,19 @@ nsCSSProps::BuildShorthandsContainingTab
          ++shorthands) {
       PRUint32 count = 0;
       for (const nsCSSProperty* subprops = SubpropertyEntryFor(*shorthands);
            *subprops != eCSSProperty_UNKNOWN;
            ++subprops) {
         if (*subprops == longhand)
           ++count;
       }
-      NS_ASSERTION(count == 1, "longhand should be in subproperty table of "
-                               "property in its ShorthandsContaining() table");
+      NS_ABORT_IF_FALSE(count == 1,
+                        "longhand should be in subproperty table of "
+                        "property in its ShorthandsContaining() table");
     }
   }
 #endif
 
   return PR_TRUE;
 }
 
 void
@@ -313,63 +317,63 @@ nsCSSProps::ReleaseTable(void)
     delete [] gShorthandsContainingPool;
     gShorthandsContainingPool = nsnull;
   }
 }
 
 nsCSSProperty
 nsCSSProps::LookupProperty(const nsACString& aProperty)
 {
-  NS_ASSERTION(gPropertyTable, "no lookup table, needs addref");
+  NS_ABORT_IF_FALSE(gPropertyTable, "no lookup table, needs addref");
 
   nsCSSProperty res = nsCSSProperty(gPropertyTable->Lookup(aProperty));
   return res;
 }
 
 nsCSSProperty
 nsCSSProps::LookupProperty(const nsAString& aProperty)
 {
   // This is faster than converting and calling
   // LookupProperty(nsACString&).  The table will do its own
   // converting and avoid a PromiseFlatCString() call.
-  NS_ASSERTION(gPropertyTable, "no lookup table, needs addref");
+  NS_ABORT_IF_FALSE(gPropertyTable, "no lookup table, needs addref");
   nsCSSProperty res = nsCSSProperty(gPropertyTable->Lookup(aProperty));
   return res;
 }
 
 nsCSSFontDesc
 nsCSSProps::LookupFontDesc(const nsACString& aFontDesc)
 {
-  NS_ASSERTION(gFontDescTable, "no lookup table, needs addref");
+  NS_ABORT_IF_FALSE(gFontDescTable, "no lookup table, needs addref");
   return nsCSSFontDesc(gFontDescTable->Lookup(aFontDesc));
 }
 
 nsCSSFontDesc
 nsCSSProps::LookupFontDesc(const nsAString& aFontDesc)
 {
-  NS_ASSERTION(gFontDescTable, "no lookup table, needs addref");
+  NS_ABORT_IF_FALSE(gFontDescTable, "no lookup table, needs addref");
   return nsCSSFontDesc(gFontDescTable->Lookup(aFontDesc));
 }
 
 const nsAFlatCString&
 nsCSSProps::GetStringValue(nsCSSProperty aProperty)
 {
-  NS_ASSERTION(gPropertyTable, "no lookup table, needs addref");
+  NS_ABORT_IF_FALSE(gPropertyTable, "no lookup table, needs addref");
   if (gPropertyTable) {
     return gPropertyTable->GetStringValue(PRInt32(aProperty));
   } else {
     static nsDependentCString sNullStr("");
     return sNullStr;
   }
 }
 
 const nsAFlatCString&
 nsCSSProps::GetStringValue(nsCSSFontDesc aFontDescID)
 {
-  NS_ASSERTION(gFontDescTable, "no lookup table, needs addref");
+  NS_ABORT_IF_FALSE(gFontDescTable, "no lookup table, needs addref");
   if (gFontDescTable) {
     return gFontDescTable->GetStringValue(PRInt32(aFontDescID));
   } else {
     static nsDependentCString sNullStr("");
     return sNullStr;
   }
 }
 
@@ -1485,17 +1489,18 @@ nsCSSProps::kKeywordTableTable[eCSSPrope
     kwtable_,
   #include "nsCSSPropList.h"
   #undef CSS_PROP
 };
 
 const nsAFlatCString&
 nsCSSProps::LookupPropertyValue(nsCSSProperty aProp, PRInt32 aValue)
 {
-  NS_ASSERTION(aProp >= 0 && aProp < eCSSProperty_COUNT, "property out of range");
+  NS_ABORT_IF_FALSE(aProp >= 0 && aProp < eCSSProperty_COUNT,
+                    "property out of range");
 
   const PRInt32* kwtable = nsnull;
   if (aProp < eCSSProperty_COUNT_no_shorthands)
     kwtable = kKeywordTableTable[aProp];
 
   if (kwtable)
     return ValueToKeyword(aValue, kwtable);
 
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -143,17 +143,17 @@ public:
   static void AddRefTable(void);
   static void ReleaseTable(void);
 
   // Given a property string, return the enum value
   static nsCSSProperty LookupProperty(const nsAString& aProperty);
   static nsCSSProperty LookupProperty(const nsACString& aProperty);
 
   static inline PRBool IsShorthand(nsCSSProperty aProperty) {
-    NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT,
+    NS_ABORT_IF_FALSE(0 <= aProperty && aProperty < eCSSProperty_COUNT,
                  "out of range");
     return (aProperty >= eCSSProperty_COUNT_no_shorthands);
   }
 
   // Same but for @font-face descriptors
   static nsCSSFontDesc LookupFontDesc(const nsAString& aProperty);
   static nsCSSFontDesc LookupFontDesc(const nsACString& aProperty);
 
@@ -191,44 +191,45 @@ public:
     kStyleStructOffsetTable[eCSSProperty_COUNT_no_shorthands];
 
 private:
   static const PRUint32        kFlagsTable[eCSSProperty_COUNT];
 
 public:
   static inline PRBool PropHasFlags(nsCSSProperty aProperty, PRUint32 aFlags)
   {
-    NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT,
-                 "out of range");
+    NS_ABORT_IF_FALSE(0 <= aProperty && aProperty < eCSSProperty_COUNT,
+                      "out of range");
     return (nsCSSProps::kFlagsTable[aProperty] & aFlags) == aFlags;
   }
 
 private:
   // A table for shorthand properties.  The appropriate index is the
   // property ID minus eCSSProperty_COUNT_no_shorthands.
   static const nsCSSProperty *const
     kSubpropertyTable[eCSSProperty_COUNT - eCSSProperty_COUNT_no_shorthands];
 
 public:
   static inline
   const nsCSSProperty * SubpropertyEntryFor(nsCSSProperty aProperty) {
-    NS_ASSERTION(eCSSProperty_COUNT_no_shorthands <= aProperty &&
-                 aProperty < eCSSProperty_COUNT,
-                 "out of range");
+    NS_ABORT_IF_FALSE(eCSSProperty_COUNT_no_shorthands <= aProperty &&
+                      aProperty < eCSSProperty_COUNT,
+                      "out of range");
     return nsCSSProps::kSubpropertyTable[aProperty -
                                          eCSSProperty_COUNT_no_shorthands];
   }
 
   // Returns an eCSSProperty_UNKNOWN-terminated array of the shorthand
   // properties containing |aProperty|, sorted from those that contain
   // the most properties to those that contain the least.
   static const nsCSSProperty * ShorthandsContaining(nsCSSProperty aProperty) {
-    NS_ASSERTION(gShorthandsContainingPool, "uninitialized");
-    NS_ASSERTION(0 <= aProperty && aProperty < eCSSProperty_COUNT_no_shorthands,
-                 "out of range");
+    NS_ABORT_IF_FALSE(gShorthandsContainingPool, "uninitialized");
+    NS_ABORT_IF_FALSE(0 <= aProperty &&
+                      aProperty < eCSSProperty_COUNT_no_shorthands,
+                      "out of range");
     return gShorthandsContainingTable[aProperty];
   }
 private:
   // gShorthandsContainingTable is an array of the return values for
   // ShorthandsContaining (arrays of nsCSSProperty terminated by
   // eCSSProperty_UNKNOWN) pointing into memory in
   // gShorthandsContainingPool (which contains all of those arrays in a
   // single allocation, and is the one pointer that should be |free|d).
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -46,45 +46,45 @@
 #include "nsStyleUtil.h"
 #include "CSSCalc.h"
 
 namespace css = mozilla::css;
 
 nsCSSValue::nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit)
   : mUnit(aUnit)
 {
-  NS_ASSERTION(aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
-               aUnit == eCSSUnit_EnumColor, "not an int value");
+  NS_ABORT_IF_FALSE(aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
+                    aUnit == eCSSUnit_EnumColor, "not an int value");
   if (aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
       aUnit == eCSSUnit_EnumColor) {
     mValue.mInt = aValue;
   }
   else {
     mUnit = eCSSUnit_Null;
     mValue.mInt = 0;
   }
 }
 
 nsCSSValue::nsCSSValue(float aValue, nsCSSUnit aUnit)
   : mUnit(aUnit)
 {
-  NS_ASSERTION(eCSSUnit_Percent <= aUnit, "not a float value");
+  NS_ABORT_IF_FALSE(eCSSUnit_Percent <= aUnit, "not a float value");
   if (eCSSUnit_Percent <= aUnit) {
     mValue.mFloat = aValue;
   }
   else {
     mUnit = eCSSUnit_Null;
     mValue.mInt = 0;
   }
 }
 
 nsCSSValue::nsCSSValue(const nsString& aValue, nsCSSUnit aUnit)
   : mUnit(aUnit)
 {
-  NS_ASSERTION(UnitHasStringValue(), "not a string value");
+  NS_ABORT_IF_FALSE(UnitHasStringValue(), "not a string value");
   if (UnitHasStringValue()) {
     mValue.mString = BufferFromString(aValue);
     if (NS_UNLIKELY(!mValue.mString)) {
       // XXXbz not much we can do here; just make sure that our promise of a
       // non-null mValue.mString holds for string units.
       mUnit = eCSSUnit_Null;
     }
   }
@@ -92,17 +92,17 @@ nsCSSValue::nsCSSValue(const nsString& a
     mUnit = eCSSUnit_Null;
     mValue.mInt = 0;
   }
 }
 
 nsCSSValue::nsCSSValue(nsCSSValue::Array* aValue, nsCSSUnit aUnit)
   : mUnit(aUnit)
 {
-  NS_ASSERTION(UnitHasArrayValue(), "bad unit");
+  NS_ABORT_IF_FALSE(UnitHasArrayValue(), "bad unit");
   mValue.mArray = aValue;
   mValue.mArray->AddRef();
 }
 
 nsCSSValue::nsCSSValue(nsCSSValue::URL* aValue)
   : mUnit(eCSSUnit_URL)
 {
   mValue.mURL = aValue;
@@ -176,17 +176,17 @@ nsCSSValue::nsCSSValue(const nsCSSValue&
   else if (eCSSUnit_PairList == mUnit) {
     mValue.mPairList = aCopy.mValue.mPairList;
     mValue.mPairList->AddRef();
   }
   else if (eCSSUnit_PairListDep == mUnit) {
     mValue.mPairListDependent = aCopy.mValue.mPairListDependent;
   }
   else {
-    NS_NOTREACHED("unknown unit");
+    NS_ABORT_IF_FALSE(false, "unknown unit");
   }
 }
 
 nsCSSValue& nsCSSValue::operator=(const nsCSSValue& aCopy)
 {
   if (this != &aCopy) {
     Reset();
     new (this) nsCSSValue(aCopy);
@@ -252,38 +252,39 @@ double nsCSSValue::GetAngleValueInRadian
   double angle = GetFloatValue();
 
   switch (GetUnit()) {
   case eCSSUnit_Radian: return angle;
   case eCSSUnit_Degree: return angle * M_PI / 180.0;
   case eCSSUnit_Grad:   return angle * M_PI / 200.0;
 
   default:
-    NS_NOTREACHED("unrecognized angular unit");
+    NS_ABORT_IF_FALSE(false, "unrecognized angular unit");
     return 0.0;
   }
 }
 
 imgIRequest* nsCSSValue::GetImageValue() const
 {
-  NS_ASSERTION(mUnit == eCSSUnit_Image, "not an Image value");
+  NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Image, "not an Image value");
   return mValue.mImage->mRequest;
 }
 
 nscoord nsCSSValue::GetFixedLength(nsPresContext* aPresContext) const
 {
-  NS_ASSERTION(mUnit == eCSSUnit_PhysicalMillimeter, "not a fixed length unit");
+  NS_ABORT_IF_FALSE(mUnit == eCSSUnit_PhysicalMillimeter,
+                    "not a fixed length unit");
 
   float inches = mValue.mFloat / MM_PER_INCH_FLOAT;
   return inches * aPresContext->DeviceContext()->AppUnitsPerPhysicalInch();
 }
 
 nscoord nsCSSValue::GetPixelLength() const
 {
-  NS_ASSERTION(IsPixelLengthUnit(), "not a fixed length unit");
+  NS_ABORT_IF_FALSE(IsPixelLengthUnit(), "not a fixed length unit");
 
   double scaleFactor;
   switch (mUnit) {
   case eCSSUnit_Pixel: return nsPresContext::CSSPixelsToAppUnits(mValue.mFloat);
   case eCSSUnit_Pica: scaleFactor = 16.0; break;
   case eCSSUnit_Point: scaleFactor = 4/3.0; break;
   case eCSSUnit_Inch: scaleFactor = 96.0; break;
   case eCSSUnit_Millimeter: scaleFactor = 96/25.4; break;
@@ -316,18 +317,18 @@ void nsCSSValue::DoReset()
   } else if (eCSSUnit_PairList == mUnit) {
     mValue.mPairList->Release();
   }
   mUnit = eCSSUnit_Null;
 }
 
 void nsCSSValue::SetIntValue(PRInt32 aValue, nsCSSUnit aUnit)
 {
-  NS_ASSERTION(aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
-               aUnit == eCSSUnit_EnumColor, "not an int value");
+  NS_ABORT_IF_FALSE(aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
+                    aUnit == eCSSUnit_EnumColor, "not an int value");
   Reset();
   if (aUnit == eCSSUnit_Integer || aUnit == eCSSUnit_Enumerated ||
       aUnit == eCSSUnit_EnumColor) {
     mUnit = aUnit;
     mValue.mInt = aValue;
   }
 }
 
@@ -335,30 +336,30 @@ void nsCSSValue::SetPercentValue(float a
 {
   Reset();
   mUnit = eCSSUnit_Percent;
   mValue.mFloat = aValue;
 }
 
 void nsCSSValue::SetFloatValue(float aValue, nsCSSUnit aUnit)
 {
-  NS_ASSERTION(eCSSUnit_Number <= aUnit, "not a float value");
+  NS_ABORT_IF_FALSE(eCSSUnit_Number <= aUnit, "not a float value");
   Reset();
   if (eCSSUnit_Number <= aUnit) {
     mUnit = aUnit;
     mValue.mFloat = aValue;
   }
 }
 
 void nsCSSValue::SetStringValue(const nsString& aValue,
                                 nsCSSUnit aUnit)
 {
   Reset();
   mUnit = aUnit;
-  NS_ASSERTION(UnitHasStringValue(), "not a string unit");
+  NS_ABORT_IF_FALSE(UnitHasStringValue(), "not a string unit");
   if (UnitHasStringValue()) {
     mValue.mString = BufferFromString(aValue);
     if (NS_UNLIKELY(!mValue.mString)) {
       // XXXbz not much we can do here; just make sure that our promise of a
       // non-null mValue.mString holds for string units.
       mUnit = eCSSUnit_Null;
     }
   } else
@@ -371,17 +372,17 @@ void nsCSSValue::SetColorValue(nscolor a
   mUnit = eCSSUnit_Color;
   mValue.mColor = aValue;
 }
 
 void nsCSSValue::SetArrayValue(nsCSSValue::Array* aValue, nsCSSUnit aUnit)
 {
   Reset();
   mUnit = aUnit;
-  NS_ASSERTION(UnitHasArrayValue(), "bad unit");
+  NS_ABORT_IF_FALSE(UnitHasArrayValue(), "bad unit");
   mValue.mArray = aValue;
   mValue.mArray->AddRef();
 }
 
 void nsCSSValue::SetURLValue(nsCSSValue::URL* aValue)
 {
   Reset();
   mUnit = eCSSUnit_URL;
@@ -534,17 +535,17 @@ void nsCSSValue::SetDummyValue()
 void nsCSSValue::SetDummyInheritValue()
 {
   Reset();
   mUnit = eCSSUnit_DummyInherit;
 }
 
 void nsCSSValue::StartImageLoad(nsIDocument* aDocument) const
 {
-  NS_PRECONDITION(eCSSUnit_URL == mUnit, "Not a URL value!");
+  NS_ABORT_IF_FALSE(eCSSUnit_URL == mUnit, "Not a URL value!");
   nsCSSValue::Image* image =
     new nsCSSValue::Image(mValue.mURL->mURI,
                           mValue.mURL->mString,
                           mValue.mURL->mReferrer,
                           mValue.mURL->mOriginPrincipal,
                           aDocument);
   if (image) {
     nsCSSValue* writable = const_cast<nsCSSValue*>(this);
@@ -728,17 +729,18 @@ nsCSSValue::AppendToString(nsCSSProperty
       aResult.AppendLiteral(")");
     }
   }
   /* Although Function is backed by an Array, we'll handle it separately
    * because it's a bit quirky.
    */
   else if (eCSSUnit_Function == unit) {
     const nsCSSValue::Array* array = GetArrayValue();
-    NS_ASSERTION(array->Count() >= 1, "Functions must have at least one element for the name.");
+    NS_ABORT_IF_FALSE(array->Count() >= 1,
+                      "Functions must have at least one element for the name.");
 
     /* Append the function name. */
     const nsCSSValue& functionName = array->Item(0);
     if (functionName.GetUnit() == eCSSUnit_Enumerated) {
       // We assume that the first argument is always of nsCSSKeyword type.
       const nsCSSKeyword functionId =
         static_cast<nsCSSKeyword>(functionName.GetIntValue());
       nsStyleUtil::AppendEscapedCSSIdent(
@@ -818,17 +820,17 @@ nsCSSValue::AppendToString(nsCSSProperty
   }
   else if (eCSSUnit_EnumColor == unit) {
     // we can lookup the property in the ColorTable and then
     // get a string mapping the name
     nsCAutoString str;
     if (nsCSSProps::GetColorName(GetIntValue(), str)){
       AppendASCIItoUTF16(str, aResult);
     } else {
-      NS_NOTREACHED("bad color value");
+      NS_ABORT_IF_FALSE(false, "bad color value");
     }
   }
   else if (eCSSUnit_Color == unit) {
     nscolor color = GetColorValue();
     if (color == NS_RGBA(0, 0, 0, 0)) {
       // Use the strictest match for 'transparent' so we do correct
       // round-tripping of all other rgba() values.
       aResult.AppendLiteral("transparent");
@@ -914,30 +916,32 @@ nsCSSValue::AppendToString(nsCSSProperty
       }
       aResult.AppendLiteral(", ");
     }
 
     if (gradient->mIsRadial &&
         (gradient->mRadialShape.GetUnit() != eCSSUnit_None ||
          gradient->mRadialSize.GetUnit() != eCSSUnit_None)) {
       if (gradient->mRadialShape.GetUnit() != eCSSUnit_None) {
-        NS_ASSERTION(gradient->mRadialShape.GetUnit() == eCSSUnit_Enumerated,
-                     "bad unit for radial gradient shape");
+        NS_ABORT_IF_FALSE(gradient->mRadialShape.GetUnit() ==
+                          eCSSUnit_Enumerated,
+                          "bad unit for radial gradient shape");
         PRInt32 intValue = gradient->mRadialShape.GetIntValue();
-        NS_ASSERTION(intValue != NS_STYLE_GRADIENT_SHAPE_LINEAR,
-                     "radial gradient with linear shape?!");
+        NS_ABORT_IF_FALSE(intValue != NS_STYLE_GRADIENT_SHAPE_LINEAR,
+                          "radial gradient with linear shape?!");
         AppendASCIItoUTF16(nsCSSProps::ValueToKeyword(intValue,
                                nsCSSProps::kRadialGradientShapeKTable),
                            aResult);
         aResult.AppendLiteral(" ");
       }
 
       if (gradient->mRadialSize.GetUnit() != eCSSUnit_None) {
-        NS_ASSERTION(gradient->mRadialSize.GetUnit() == eCSSUnit_Enumerated,
-                     "bad unit for radial gradient size");
+        NS_ABORT_IF_FALSE(gradient->mRadialSize.GetUnit() ==
+                          eCSSUnit_Enumerated,
+                          "bad unit for radial gradient size");
         PRInt32 intValue = gradient->mRadialSize.GetIntValue();
         AppendASCIItoUTF16(nsCSSProps::ValueToKeyword(intValue,
                                nsCSSProps::kRadialGradientSizeKTable),
                            aResult);
       }
       aResult.AppendLiteral(", ");
     }
 
@@ -970,17 +974,17 @@ nsCSSValue::AppendToString(nsCSSProperty
     case eCSSUnit_Inherit:      aResult.AppendLiteral("inherit");  break;
     case eCSSUnit_Initial:      aResult.AppendLiteral("-moz-initial"); break;
     case eCSSUnit_None:         aResult.AppendLiteral("none");     break;
     case eCSSUnit_Normal:       aResult.AppendLiteral("normal");   break;
     case eCSSUnit_System_Font:  aResult.AppendLiteral("-moz-use-system-font"); break;
     case eCSSUnit_All:          aResult.AppendLiteral("all"); break;
     case eCSSUnit_Dummy:
     case eCSSUnit_DummyInherit:
-      NS_NOTREACHED("should never serialize");
+      NS_ABORT_IF_FALSE(false, "should never serialize");
       break;
 
     case eCSSUnit_String:       break;
     case eCSSUnit_Ident:        break;
     case eCSSUnit_Families:     break;
     case eCSSUnit_URL:          break;
     case eCSSUnit_Image:        break;
     case eCSSUnit_Element:      break;
@@ -1231,17 +1235,17 @@ nsCSSValuePairList::operator==(const nsC
 
 nsCSSValue::URL::URL(nsIURI* aURI, nsStringBuffer* aString, nsIURI* aReferrer,
                      nsIPrincipal* aOriginPrincipal)
   : mURI(aURI),
     mString(aString),
     mReferrer(aReferrer),
     mOriginPrincipal(aOriginPrincipal)
 {
-  NS_PRECONDITION(aOriginPrincipal, "Must have an origin principal");
+  NS_ABORT_IF_FALSE(aOriginPrincipal, "Must have an origin principal");
   mString->AddRef();
 }
 
 nsCSSValue::URL::~URL()
 {
   mString->Release();
 }
 
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -212,17 +212,17 @@ public:
 
   struct Image;
   friend struct Image;
 
   // for valueless units only (null, auto, inherit, none, all, normal)
   explicit nsCSSValue(nsCSSUnit aUnit = eCSSUnit_Null)
     : mUnit(aUnit)
   {
-    NS_ASSERTION(aUnit <= eCSSUnit_DummyInherit, "not a valueless unit");
+    NS_ABORT_IF_FALSE(aUnit <= eCSSUnit_DummyInherit, "not a valueless unit");
   }
 
   nsCSSValue(PRInt32 aValue, nsCSSUnit aUnit);
   nsCSSValue(float aValue, nsCSSUnit aUnit);
   nsCSSValue(const nsString& aValue, nsCSSUnit aUnit);
   nsCSSValue(Array* aArray, nsCSSUnit aUnit);
   explicit nsCSSValue(URL* aValue);
   explicit nsCSSValue(Image* aValue);
@@ -281,84 +281,85 @@ public:
 
   PRBool    UnitHasStringValue() const
     { return eCSSUnit_String <= mUnit && mUnit <= eCSSUnit_Element; }
   PRBool    UnitHasArrayValue() const
     { return eCSSUnit_Array <= mUnit && mUnit <= eCSSUnit_Calc_Maximum; }
 
   PRInt32 GetIntValue() const
   {
-    NS_ASSERTION(mUnit == eCSSUnit_Integer || mUnit == eCSSUnit_Enumerated ||
-                 mUnit == eCSSUnit_EnumColor,
-                 "not an int value");
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Integer ||
+                      mUnit == eCSSUnit_Enumerated ||
+                      mUnit == eCSSUnit_EnumColor,
+                      "not an int value");
     return mValue.mInt;
   }
 
   float GetPercentValue() const
   {
-    NS_ASSERTION(mUnit == eCSSUnit_Percent, "not a percent value");
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Percent, "not a percent value");
     return mValue.mFloat;
   }
 
   float GetFloatValue() const
   {
-    NS_ASSERTION(eCSSUnit_Number <= mUnit, "not a float value");
+    NS_ABORT_IF_FALSE(eCSSUnit_Number <= mUnit, "not a float value");
     return mValue.mFloat;
   }
 
   float GetAngleValue() const
   {
-    NS_ASSERTION(eCSSUnit_Degree <= mUnit &&
+    NS_ABORT_IF_FALSE(eCSSUnit_Degree <= mUnit &&
                  mUnit <= eCSSUnit_Radian, "not an angle value");
     return mValue.mFloat;
   }
 
   // Converts any angle to radians.
   double GetAngleValueInRadians() const;
 
   nsAString& GetStringValue(nsAString& aBuffer) const
   {
-    NS_ASSERTION(UnitHasStringValue(), "not a string value");
+    NS_ABORT_IF_FALSE(UnitHasStringValue(), "not a string value");
     aBuffer.Truncate();
     PRUint32 len = NS_strlen(GetBufferValue(mValue.mString));
     mValue.mString->ToString(len, aBuffer);
     return aBuffer;
   }
 
   const PRUnichar* GetStringBufferValue() const
   {
-    NS_ASSERTION(UnitHasStringValue(), "not a string value");
+    NS_ABORT_IF_FALSE(UnitHasStringValue(), "not a string value");
     return GetBufferValue(mValue.mString);
   }
 
   nscolor GetColorValue() const
   {
-    NS_ASSERTION((mUnit == eCSSUnit_Color), "not a color value");
+    NS_ABORT_IF_FALSE((mUnit == eCSSUnit_Color), "not a color value");
     return mValue.mColor;
   }
 
   PRBool IsNonTransparentColor() const;
 
   Array* GetArrayValue() const
   {
-    NS_ASSERTION(UnitHasArrayValue(), "not an array value");
+    NS_ABORT_IF_FALSE(UnitHasArrayValue(), "not an array value");
     return mValue.mArray;
   }
 
   nsIURI* GetURLValue() const
   {
-    NS_ASSERTION(mUnit == eCSSUnit_URL || mUnit == eCSSUnit_Image,
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_URL || mUnit == eCSSUnit_Image,
                  "not a URL value");
     return mUnit == eCSSUnit_URL ?
       mValue.mURL->mURI : mValue.mImage->mURI;
   }
 
   nsCSSValueGradient* GetGradientValue() const
   {
-    NS_ASSERTION(mUnit == eCSSUnit_Gradient, "not a gradient value");
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Gradient, "not a gradient value");
     return mValue.mGradient;
   }
 
   // bodies of these are below
   inline nsCSSValuePair& GetPairValue();
   inline const nsCSSValuePair& GetPairValue() const;
 
   inline nsCSSRect& GetRectValue();
@@ -369,24 +370,24 @@ public:
 
   inline nsCSSValuePairList* GetPairListValue();
   inline const nsCSSValuePairList* GetPairListValue() const;
 
   URL* GetURLStructValue() const
   {
     // Not allowing this for Image values, because if the caller takes
     // a ref to them they won't be able to delete them properly.
-    NS_ASSERTION(mUnit == eCSSUnit_URL, "not a URL value");
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_URL, "not a URL value");
     return mValue.mURL;
   }
 
   const PRUnichar* GetOriginalURLValue() const
   {
-    NS_ASSERTION(mUnit == eCSSUnit_URL || mUnit == eCSSUnit_Image,
-                 "not a URL value");
+    NS_ABORT_IF_FALSE(mUnit == eCSSUnit_URL || mUnit == eCSSUnit_Image,
+                      "not a URL value");
     return GetBufferValue(mUnit == eCSSUnit_URL ?
                             mValue.mURL->mString :
                             mValue.mImage->mString);
   }
 
   // Not making this inline because that would force us to include
   // imgIRequest.h, which leads to REQUIRES hell, since this header is included
   // all over.
@@ -527,22 +528,22 @@ protected:
 struct nsCSSValue::Array {
 
   // return |Array| with reference count of zero
   static Array* Create(size_t aItemCount) {
     return new (aItemCount) Array(aItemCount);
   }
 
   nsCSSValue& operator[](size_t aIndex) {
-    NS_ASSERTION(aIndex < mCount, "out of range");
+    NS_ABORT_IF_FALSE(aIndex < mCount, "out of range");
     return mArray[aIndex];
   }
 
   const nsCSSValue& operator[](size_t aIndex) const {
-    NS_ASSERTION(aIndex < mCount, "out of range");
+    NS_ABORT_IF_FALSE(aIndex < mCount, "out of range");
     return mArray[aIndex];
   }
 
   nsCSSValue& Item(size_t aIndex) { return (*this)[aIndex]; }
   const nsCSSValue& Item(size_t aIndex) const { return (*this)[aIndex]; }
 
   size_t Count() const { return mCount; }
 
@@ -735,24 +736,24 @@ struct nsCSSRect_heap : public nsCSSRect
   NS_INLINE_DECL_REFCOUNTING(nsCSSRect_heap)
 };
 
 // This has to be here so that the relationship between nsCSSRect
 // and nsCSSRect_heap is visible.
 inline nsCSSRect&
 nsCSSValue::GetRectValue()
 {
-  NS_ASSERTION(mUnit == eCSSUnit_Rect, "not a pair value");
+  NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Rect, "not a pair value");
   return *mValue.mRect;
 }
 
 inline const nsCSSRect&
 nsCSSValue::GetRectValue() const
 {
-  NS_ASSERTION(mUnit == eCSSUnit_Rect, "not a pair value");
+  NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Rect, "not a pair value");
   return *mValue.mRect;
 }
 
 struct nsCSSValuePair {
   nsCSSValuePair()
   {
     MOZ_COUNT_CTOR(nsCSSValuePair);
   }
@@ -819,24 +820,24 @@ struct nsCSSValuePair_heap : public nsCS
   NS_INLINE_DECL_REFCOUNTING(nsCSSValuePair_heap)
 };
 
 // This has to be here so that the relationship between nsCSSValuePair
 // and nsCSSValuePair_heap is visible.
 inline nsCSSValuePair&
 nsCSSValue::GetPairValue()
 {
-  NS_ASSERTION(mUnit == eCSSUnit_Pair, "not a pair value");
+  NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Pair, "not a pair value");
   return *mValue.mPair;
 }
 
 inline const nsCSSValuePair&
 nsCSSValue::GetPairValue() const
 {
-  NS_ASSERTION(mUnit == eCSSUnit_Pair, "not a pair value");
+  NS_ABORT_IF_FALSE(mUnit == eCSSUnit_Pair, "not a pair value");
   return *mValue.mPair;
 }
 
 // Maybe should be replaced with nsCSSValueList and nsCSSValue::Array?
 struct nsCSSValuePairList {
   nsCSSValuePairList() : mNext(nsnull) { MOZ_COUNT_CTOR(nsCSSValuePairList); }
   ~nsCSSValuePairList();
 
